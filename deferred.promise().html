<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title></title>
  <script src="js/jquery v1.6.1.js"></script>
</head>
<body>

</body>
</html>
<script>
  /*
    创建一个延迟的并设置两个基于时间的函数，以解决或拒绝一个随机间隔后的延迟。无论哪一个先开火“赢”，就会调用一个回调。第二个超时没有任何影响，因为延迟已经从第一个超时操作完成(在一个已经解决的或被拒绝的状态中)。还设置了基于时间的进度通知函数，并调用一个进度处理程序来添加“工作……”“到文件机构。
   */
/*function asyncEvent() {
  var dfd = $.Deferred();
  //随机间隔后解析
  setTimeout(function() {
    dfd.resolve( "hurray" );
  }, Math.floor( 400 + Math.random() * 2000 ) );

  //在随机间隔后拒绝
  setTimeout(function() {
    dfd.reject( "sorry" );
  }, Math.floor( 400 + Math.random() * 2000 ) );

  //显示“工作…”消息每秒钟
  setTimeout(function working() {
    if (dfd.state() === "pending" ) {
      dfd.notify( "working... " );
      setTimeout( working, 500 );
    }
  },1);

  // 返回承诺，这样调用者就不能更改延迟
  return dfd.promise();
}

// 为asyncEvent附加一个已完成的、失败的和进度处理程序
$.when( asyncEvent() ).then(
  function( status ) {
    alert( status + ", 事情进展顺利" );
  },
  function( status ) {
    alert( status + ", 这次你失败了" );
  },
  function( status ) {
    $( "body" ).append( status );
  }
);
*/

  //换到已存在的模块
  var obj = {
      hello: function( name ) {
        alert( "Hello " + name );
      }
    },
    //创建一个延期
    defer = $.Deferred();

  //设定目标为承诺
  defer.promise( obj );

  //解决延迟
  defer.resolve( "John" );

  //使用对象作为承诺
  obj.done(function( name ) {
    obj.hello( name ); // Will alert "Hello John"
  }).hello( "Karl" ); // Will alert "Hello Karl"
</script>