	html5+CSS3+javascript+jQuery 50~60%
	mui 移动端 20~30%
	react和angular框架 15%
	node.js 5%

	推荐编辑器sublime text3 【涩不来莫 台克特】和HBuilder【A 吃 piu 得】
chrome谷歌浏览器 常用调试快捷键
	F12直接打开
	【Ctrl+Shift+I】打开Elements元素CSS调试
	【Ctrl+Shift+J】打开console元素JS调试

【div+css设置】
	不懂没关系，先要背会标签英文单词，懂得什么意思就好，也多看下PDF,wode文档和【教程视频。至于不会读，可以今后再说。
	不会背，将单词分成中文拼音和中文字来强行记忆，来进行强行催眠，每天复习背的内容，多动手练习，无论手机还是电脑。
	电脑有txt,手机也有记事本和备忘录,书签。
	本人就是这样来记忆。
PS:因为零基础英语，以前也不常打英文，因为这样目前只能记,记,记。强迫自己记记记。如果记不会，你无法进行到下一步。【就好比婴儿要走路，首先得去学怎么爬，接下来学站立,站立以后才慢慢学走路】，重要的不是结果，而是学习的过程本身。

ps2:有英语基础的可以方便按读音轻松记，可直接跳过这步骤，去了解操作,先学会会用,再思考原理,接下来进行操作

基本html常用代码和CSS长宽高背景边,边框类都记会，接下来就去背怎样读。视频教程里有，如果不会读，将来别人说什么你也听不懂。这也是必须要掌握的

【会看】——【会用】这个是才真正第一步。
【会用】——【会读】——【会思考布局】这是第二步

【会思考布局】——【开始做静态网页】这是第三步
【静态网页】做出【响应式手机页面】这是第四步

最后考虑【兼容性】和jquery动态效果


第二步就是脑中布局,进行操作
	1.【从上往下,从左往右】非常重要,【不懂这,你就无法进行接下来操作】
	2.分大体框，框中分小框，小框分类框
	3.大框分顶部,导航,内容和底部栏
	4.顶部又分头部，logo,phone，搜索框类
	5.导航又分为列表和描文本框
	6.内容分大量列表和描文本或图片框，大部分设置都在这里
	7.底部也分列表和描文本，普通文本框

1.设置全局设置
标签,标签......{marin:0 pedding:0}
外边框0 内边框0


	body{backgtound:#000 text-family:"宋体"} 背景颜色 字体
	ul,ul{list-style:none;} 目录样式没有
	img{border:0;} 边为0
	a{text-decoration:none;} 文本修饰没有
	a:hvore{text-decoration:underline;} 鼠标点击 文本修饰

2.设置通用设置
	wp【居中设置】宽度设置 width高度自动height 自适应auto 外边框margin 
	.wp{width:}

【html初始设置】
	<div class="header"></div>
	<div class="nav"></div>
	<div class="bannet"></div>
	<div class="main"></div>
	<div class="footer"></div>

	之后扩充header头部，logo,phone两div

	main内容添加p，p里添加ul，ul里添加li，li里添加a，a里添加span不换行

	CSS里字体和阴影操作在 ul li里写，也可以border-top
	box-shadow:0px 55px 20px -50px #666
	图片里设置、位置
	链接里

【本人自我反省和要学习，解决问题】：
1.老把none写成nome【改坏习惯】
===========================================================
2.老把一些代码r写成t,t写成r【改坏习惯】比如banner,老写成bannet
===========================================================
3.不懂怎样x移动图片，外内边框头左右移动【记标签单词】
===========================================================
4.不懂如何不换行，在同一行显示 span【记住并运用】
===========================================================
5.图片路径必须做下划线/，不能写\右下划线，否则不能出现.【吸取失败经验，习惯运用】
===========================================================
6.老把auto写成0，【注意height写成0不显示才对】
===========================================================
7.老把banner写成bannet【把t和r调换】css无法调用图片，直接用html插入图片，CSS设置宽度100%
===========================================================
8.【wp居中必须在父标签下，否则自动居中】可以自定义选择器名，最好用简称,方便记忆
===========================================================
9.若顶部无法平铺背景色，【说明少了</div>加一个就好】
ps:若在父标签下还是居中，【那就是上一父标签缺少了/div结尾符】
===========================================================
10.为什么nav导航字体无法不换行显示，多添加了【ul和/ul】都去掉，把a全部包含一个ul就好
===========================================================
11.去掉ul前面符号【list-style:none】这样就取消
===========================================================
12.导航颜色实在CSS设置不了,使用行间样式表设置
===========================================================
13.margin：0 auto必须有宽度才行,0默认上下自动，左右居中.2个是上左,三个是上左下,四个是上右下左
14.给a转换块级元素并横向水平平铺，需要display:inline-block才行
===========================================================
15，若横向平铺后出现间隙,可以html删除</a>和<a>空格
    可以CSS使用margin-right: -3px【右边框负值来取消】，正去除空格值可自定义边距大小【推荐】
===========================================================
16.顶部div粘连，使用overflow:heidden
===========================================================
17.无法实现移动布局，直接ul>li拿div的class来设置
※div设置宽高,边,内外边框，上右下左位置 和overflow:hidden超出裁剪
※li 设置浮动左边，文本居中,字体加重,字体大小，字体颜色,边颜色大小
※a直接text-decoration:none不显示装饰,设置颜色 高宽,背景 display:inline-block;显示横向块级元素,之后和div设置相同 字体颜色,大小
※a:hover鼠标移动或覆盖text-decoration:underline  字体颜色,大小
===========================================================
18.下拉列表ul必须包括li>a,样式里li写display:none
font-weight:bold字体加重
===========================================================
19.图片img无法水平平铺,margin:0 auto；设置图片平铺，但必须设置宽度
===========================================================
20.ul里包含【li】,li包含ul>li
===========================================================
21.脑海整理，div设置空间位置【高,宽,背景色】
   ul设置位置方向【上下为0，溢出隐藏】
   li也能设置高宽,宽高类【浮动左右】
===========================================================
22.滚动条不显示了， 去掉body的overflow: hidden
===========================================================
23.怎么jquery弄tab切换，div里包含div2设置切换，再创建div3包含
===========================================================
<div class="1">
<div class="鼠标切换'>
	<ul>
		<li class="切换定位">
		</li>
	</ul>
</div>
<div class="切换内容">
<div class="切换定位">
	<p> <a> <span>
</div>
<div></div>.....

</div>
</div>
===========================================================
24.怎么禁止body横向滚动，使用overflow-x:hidden;overflow-y:auto
===========================================================
25.怎样设置jq设置下拉菜单？
先创建一个div包含一切，再创建一个ul包含内容。ul创建
<div class="nav">
<ul>
	<li>
		<a href="">首页</a>
			<div class="xiala">
				<ul>
					<li>
					</li>
			......</ul>
			</div>
	</li>

<li>
<a href="">第二页</a>
<div class="xiala">
<ul><li></li>......</ul>
</div>
</li>
......


</li>
</ul>
</div>

<script type="text/javascript">
$(document).ready(function() {
    $(".m2>ul>li").hover(function(){
		$(".m2>ul>li:eq("+$(this).index()+") .lie").toggle();
		});
});

</script>

</script>
25.不懂怎么去input边框
*.focus{outline:nome}
全局设置，包括input
input(outline:none;}
===========================================================
26.不懂inpu点击时去掉外边框
border:none;
===========================================================
27.鼠标点击按钮后出现边效果
解决方法:使用伪类:active来实现边效果

:link 另可 没点击状态 雷克
hover 哈我
:active【按钮点击下】阿克腾
:visited【点击后】菲斯列得
focus 焦点,选择单状态
first:child 【l或c】
last:chilcd
nth-childcn

firse【第一】烦死特
last【最后】
child【小孩】穿耳特
===========================================================
28.怎样button设置背景渐变
filter【过滤】费油特
webkit

button 宝特

moz【人名】
gradient【倾斜度】贵矜持
linear【直线的】
from【从】

设置button阴影
color: #4B5356;
border: solid 1px #F2F2F2;
border-radius:5px;
background: -webkit-gradient(linear, left top, left bottom, from(#F7F6F4), to(#D1CFD0));
/*【上面谷歌用】*/
background: -moz-linear-gradient(top,#D1D0CE,#FFFFFF);
/*【上面火狐用】*/
filter:  progid:DXImageTransform.Microsoft.gradient(startColorstr='#D1D0CE', endColorstr='#FFFFFF');
/*【上面IE用】*/

-moz代表firefox浏览器私有属性，
-ms代表ie浏览器私有属性，
-webkit代表safari、chrome私有属性。
-o欧朋浏览器

比如border-radius这个控制圆角的东东要想在谷歌的浏览器里面显示出来就得在前面加上-webkit呢!
===========================================================
29.html里写javescript代码，不显示

解决方法:去掉<script type="text/javescript">内的type="text/javescript",这样高版本浏览器才能支持解析生效。
===========================================================
30.不懂怎么做三角形
.box{
    width:0px;
    border-right:10px solid #DEDEDE;
    border-top:6px solid transparent;
    border-left:6px solid transparent;
    border-bottom:6px solid transparent;
}

解决方法:宽为0,有高度或宽度的设置颜色 其他边设置透明

===========================================================
31.从李洪军老师那代码学到【margin和padding复合写法】
【优点】:节省时间代码
【缺点】:必须【顺时钟】写，否则不生效。

PS:【border的复合写法不用规定必须顺序，可以像素+线类型+颜色，也可以调换】

   从简洁的纯CSS下拉菜单代码里学到了【font的复合写法】
【优点】:节省时间代码
【缺点】:必须按照【像素+字体状态+字体类型】写，否则不生效。中文必须要加""双引号
ps:字体状态可以不用写,正常或加粗,可能会失效，在span里测试失效
===========================================================
32.如果多个li里有不同div的话，导致出框外的话，使用float:ledt;这样就好了
===========================================================
33.好久不用忘了,平铺背景颜色,使用repeat-x平铺,不要x-repeat这样,x在前,这样会不生效。
===========================================================
34.padding在块集元素使用，比如在a里使用，而内联元素会撑大父级的框。
===========================================================
35.span内不可添加块级元素,包括a，但a元素可包含span
===========================================================
36.span默认具有换行,a里包含span，谨慎而为之
===========================================================
37.tab切换怎么做？
在一个大的div里放两个div，
第一个加ul>li,设置不同tab内容
第二个div里再加一个div，设置class名,里面再直接添加多个div，不设置类或ID名。
<div class="tab">
<div class="tablist">
<ul>
<li>这里切换目录</li>......
</ul>
</div>

<div class=""tabcon>
<div class="cur">
<p></p>
</div>

<div></div>
<div></div>......

</div>
</div>
===========================================================
38.a标签里可直接包含文字和图片；
===========================================================
39.单独写htnl内嵌样式表，记得给ul设置margin和padding为0。
===========================================================
40.怎样设置旋转和渐变
旋转:transfotm:rotate(45deg);
渐变:background:linear-gradient(45deg,red 30%,blue 40%); 【必须加背景颜色】逗号之间不用加空格也行。
PS:linear-gradient和gradient-linear可切换顺序，效果相同，建议前者,解释通顺
===========================================================
41.测试p标签
P和ul li一样必须得设置内边距和外边距为0，才能进行任意手动设置。
===========================================================
42.把ul li的宽去掉，就自适应里面字体大小覆盖
===========================================================
43.cursor:poin

ter在li里使用
cursor【光标】
pointer【指针】
===========================================================
44.设置文字环绕
   div包含一张图片或div,设置高宽并浮动左边
   大div也涉足浮动
默认:white-space:normal;
白色-间距-正常

【解决方法一】:
英文使用word-break:break-all;【浏览器不支持解析代码换行】
单词-间隔:下落-全部【断行】
word-wrap:break-word;【浏览器支持解析代码换行】
单词-包袱:下落-单词
【解决方法二】:
直接在html里，将要换行英文换行,浏览器自动将换行识别
===========================================================
45.html里不能直接使用html单个属性进行设置颜色，只能在body设置text=red全局颜色，或在用行内样式表设置颜色
===========================================================
46.快集元素使用align=center
===========================================================
47.浮动,在父级div框加浮动,子级继承父级浮动.
	若子级单个设置浮动,那么框上去,内容不上去
给父级设置oveflow;hidden;,子级没设浮动不会被影响
也可以清除浮动clear:both;
全局设置
div,p,h1,h2,h3,h4,h5,h6,ul>li>ol>li:after{
      content:"";
      display:block;
      clear:both;
  }
===========================================================
48.给未知高度div设置图片居中?[垂直居中]【垂直居中】
1.使用background:url() no-repeat centerr;
2.使用background:url() no-repeat 50%;
3.使用display:table-cell;
      vertical-align:middle;
===========================================================
display:table-cell只支持行内块img元素
===========================================================
49.2016-12-4日做京东首页,因为系统内存不同问题,注销后打开css,被清空代码,导致上午CSS代码白打,谨以此为教训,下次多备份
===========================================================
50,布局最重要使用margin和padding布局前，必须都线使用float浮动。再调整位置如果
===========================================================
51.如果要设置伪类下拉列表，必须下拉列表在子级，比如div:hover .hidden{}触发事件。

京东红#E4393C
===========================================================
52.自己做css库来调用，只能使用class类名,不能使用群组添加ID名，否则前面class名不生效
===========================================================
53.新发现，设置不规则图形，需要设置四个边颜色，根据自己需求调整位置
 width:27px;
    border-bottom:168px solid red;
    border-right:167px solid blue;
    border-top:-40px solid green;
    border-left:10px solid black;
使用transform:rotate(deg);旋转来解决问题
宽是头部宽度
===========================================================
54.描点文本不只a标签name能跳转，使用div,img的id也能实现
===========================================================	
55.实现图片切换，使用img{display:nome;}; 实现实现
===========================================================	
56.已测试,对四边更深了解,设置不规则多边形，设置width来设置以下bottom角度-宽度,利用border-top|right|bottom|left;来设置高度，调整位置
===========================================================	
57.rotateX和rotateY,rotateZ旋转不能用复合写法，只能单独写，且后缀是【deg】。
   但translate位移可以使用复合写法。translateX(value);translateY(value);和translateZ(value);复合写法是
   【translate(X,Y,Z)】
先转移角度,再转换位置

计算图片拉开Z轴px
	1.【(360 / 图片个数) = rotateY轴旋转度数】
		比如:(360 / 9) = 40deg
	2.【(图片宽度 / 2) = 得到每张图片距离】
		比如:(128 / 2) = 64px
	3.【(Y轴旋转度数 / 2) = 得到每张图标角度】
		比如: (40deg / 2) = 20deg
	4.→最重要 
	    【每张图片距离 / Math.tan(得到每张图标角度 / 180 * Math.PI)】
		比如:64 / Math.tan(20 / 180 * Math.PI) = 195.839px
	这样就得到translateZ的具体值
===========================================================
58.右面出现滚动条,只要在wp居中的代码里写overflow:hidden;就好了
   解决方法:把span或其他元素的display:bolck;去掉就好，这是它本身的问题，独占整体一行,增加宽度,导致横向滚动出现
	display: inline-block;边多出3像素
===========================================================
59.做幽灵按钮，使用ransition:all 4s ease;
===========================================================
60.p标签有时自带宽,导致影响布局,不推荐使用,建议使用<br />和span来操作
===========================================================
61.js里parseInt(怕是 因特)能转换变量Number数字类型,但是注意如果变量赋值不是字符串的数字,而是中文或英文的话,会提示NaN非数,要想各个变量类型转换,只要在前面添加类型名Number(变量) String(变量) Boolean(变量) 这样就好
===========================================================
62.在变量声明{}和[]数组都是Object(熬不解渴)类型
===========================================================
63.同级的if只能用一个，if子级第一个必须为if，第二个才可以用else if
===========================================================
64.switch结构,cese和defalut后面必须是【:】冒号，很重要，否则无法输出
===========================================================
65.for循环语句for(i = 1; i < 100; i++); 循环判断条件,第二步,如果循环变量初始化第一步为0,那么后者运算符必须 <小于多少,如果变量初始化第一步为1,那么后者必须<=大于或等于多少?
	因为计算两个数的对比,必须判断具体数值
	比如求20到30之间,必须使用 && 或者 符号
	0 >= 20 &&  20 < 30
===========================================================
66.for循环 (循环变量初始化;循环判断条件:循环步进)这三步后面必须是【;】引号.而不是【:】冒号
	严重注意:一旦写错了,那么就会显示错误,很难找到
===========================================================
67.switch判断步进一定要写在代码行下,否则会多执行一次循环
===========================================================
68.for循环,如果要输出循环全部结果,在for代码块下写alert或console,但如果要求循环结果总和,乘,除,则需要把alert或consol写在for循环下
===========================================================
69.for循环判断条件,不能加表达式,要加表达式,必须加在for后面,因为for只能用来判断结果,但却不能直接在for()中间加表达式,可以在【循环步进】里设置条件;比如( i+ )如果要加表达式,可以使用if,switch循环
===========================================================
70.最大公因数
	比如a = 12 / 2 = 6  : /2 = 3
	比如b = 16 / 2 = 8  : /2 = 4
		12 / 4 = 3例如
		16 / 4 = 3
	if
	a % i = 0 && b % i =0
	满足输出i
===========================================================
71.公约数就是可以被同一个整数除的，例如2,3,4是12的公约钱
公倍数就是可以整除某些数，就是这些数的公倍数,36是2,3,4,6的公倍数
===========================================================
【72.怎样算出最大公约数】
比如给两个数6和28
	2|6 24
	 |_______
	  3 12

	3|6 24
	 |_______
	  2 8

	6|6 24
	 |_______
	  1 4
 他们的公约数或者说能被相同的数整除,这里6和24的共同公约数就是2,3,6，最大的数5，那么自然最大公约数是6
	var num = parseInt(prompt('请输入第一个数字:'));
	var num2 = parseInt(prompt('请输入第二个数字:'));
		for(i = num; i > 0; i--){
			if(num % i == 0 && num2 % i == 0){
				alert('最大公约数' + i);
				break;
			} 
		}
那么怎样用js来计算，又怎样去表达:
	这里涉及的一个重点就是【逆向思维】
	设置变量1和变量2一个数值，
	【第一步】for循环() i = num 也就是设置i等于最大值，那么第二步i > 0就是设置从0开始到最大值，i--从最大值-1开始循环
	【第二步】if() num % i == 0其实就是说 6/1,2,3,4,5,6...... num/num*num个数，循环出能符合除与它自身的数字
	所以6能被6整除,取余是0，24也能被6整除也就是取余0；由此就可以if加个&&并且就能得出最后的最大公约数
	
===========================================================	
【73.怎样算出最小公倍数:】
比如给两个数6和28
	2|6 24
	 |_______
	  3 12
那么最小公倍数，就是2*3*12=72；公约数乘以无法相同除的数
	var num = parseInt(prompt('请输入第一个数字:'));
	var num2 = parseInt(prompt('请输入第二个数字:'));
		for(i = num ; i > 0; i++){
			if(i % num == 0 && i % num2 == 0){
				alert('最小公倍数为' + i);
				break;
			}
		}
那么怎样用js来计算，又怎样去表达:
	这里涉及的重点还是【逆向思维】
	还拿上面公式来比较说明
	之前求出的是公式左侧最大的公约数，或者说最大整除数。现在求的是两者包括整除数和余数乘积。
	【第一步】for循环() i = num 也就是设置i等于最大值，那么第二步i > 0就是设置从0开始到最大值，i--从最大值-1开始循环
	【第二步】if() i % num == 0其实就是说2 * 3 * 12 = 72，而这个72因为是6和24的分开公约数相乘，其实可以表达为
		（2 * 3 * 12 = 72）== （6 * 24）
			最小公倍数是两个数的乘积，那么这时i除与两个数肯定等于0.也就是通过这一步，我们可以输出结果
			最小公倍数 ==（72 % 6 == 0 && 72 % 24 == 0）
	260 / 20 = 
	260 / 13 =
	num/num*num个数，循环出能符合除与它自身的数字
	所以6能被6整除,取余是0，24也能被6整除也就是取余0；由此就可以if加个&&并且就能得出最后的最大公约数
	i = 两个数乘积总数
	然后if判断如果 总分数/num 或者 总分数/num2 =等于 0那么就输出最小公倍数
===========================================================
【74.怎样算出素数？还有指数是什么？】
	还是【逆向思维】先算出不是素数的数，素数是能被1和它自身，和不能被任意两个数整乘的是素数,比如【5,,13】，只能被它自身整乘,但不能被任意两个数整乘
	反过来就是先算不是素数的数，排除1，能被任意两个数整乘的数字，那么就要算平方根

	指数就是平方,也就是幂方,指数是平方的一种
 	j <= Math.sqrt(i)
	i = j x n； （这里n是定义的任意值1,2,3,4......infinite）求得i不是素数的数字
	n是大于等于2，排除1
	n >= j 如果n大于等于j
	i = j x n >=( j x j = j^2) j 的二次方 
	i >= j^2
	j <= 根号i == Mart.sqrt(i)
——————————————————
	用数学表示:
	比如i = 100； j = 2
	100 = 50 x 2；
	50 >= 2
	100 = 50 x 2 >= ( 2 x 2 = 2^2)
	100 >= 4
	50 <= 根号100(10) == Mart.sqrt(100)
	根号就是求两个相同数乘以等于它自身的数

//输出100-200之间所有的素数 
 		  var num = 0;  //声明一个变量来保存最后的值
 		  for (i = 100; i <= 200; i++) { //第一步是为了循环出第一步100-200之间所有数
 		  		var  ret = true; //第二步为了判断真和假，是与否
 		  	for(j = 2; j <= Math.sqrt(i); j++){ //第四步重点，为了排除i，那么j = 2; 如果i等于100.那么j 肯定小于i的平方根
 		  	}
 		  	 if(i % j == 0){  //第五步 就好判断多了，已经求出所有不是素数的数的话，那么 i%j也就是100%2，结果肯定为0,
 		  		ret = false; //因为求得是素数，所以这是假
 		  		break;       //然后结束循环，
 		  	 } if(ret){
 		  	 	num++;
 		  	 	console.log(i);
 		  	 }
 		  }
 		  console.log(num);
===========================================================
75.怎样使用for循环排除某些限制条件数:
【第一种】使用break判断真假，在for第一步循环给 赋值true真并设置变量,为了之后排除false条件，在if判断条件下再给之前得变量赋值false,这样就能排除if里的条件表达式内的数值。
var iNum = 0;
  for (var i=1; i<=10; i++) {
    true_false = true;
    for (var j=1; j<=10; j++) {
      if (i  == 5 && j == 5) {
        true_false = false;
        break;
      }
  iNum++;
    }
}
    alert(iNum);

【第二种】使用continue和标签语句排除，在for循环之前添加一个【变量名:】添加冒号代表引用，然后同样在if循环下添加【continue 变量名;】，这样也能排除if里的条件表达式内的数值。
var iNum = 0;
true_false:
  for (var i=1; i<=10; i++) {
    for (var j=1; j<=10; j++) {
      if (i  == 5 && j == 5) {
        continue true_false;
      }
  iNum++;
    }
}
    alert(iNum);
===========================================================
76.几次方用e多少表示，比如10e4就是乘以4的10次方
   想输出'就使用转义字符\',这样的话就能输出	
   	控制台或alert使用\\就是\
	使用\'输出就是'单引号
	使用\"输出就是"双引号
	使用\n输出就是换行
	使用\t输出就是tab，和空格差不多
	\nn，比如\x41是16进制A
	\unnn，比如\u03a3 是Unicode字符(0-F)
   	
.toString()
	box.toString(2)；//'1010'2进制
	box.toString(8)；//'12'  8进制
	box.toString(10)；//'10' 10进制
	box.toString(16)；//'A'  16进制
Nunber()

初始化Object;
	var box = null; 第一种
	var box = {}; 第二种 对面字面量创建方法
	var box = new Object(); 第三种 通过new创建一个对象
	Object()内可以传递任何类型，无论Nunber，String还是boolean类型
	创建后，可以使用运算符相加或拼接

	var box = new Nunber(60); =60 这种方式也是创建一个数值对象，它的类型还是Object
创建一个对象,然后使用：
    var box = {
    valueOf:function(){
      return 123;
    }
    };
    box++;
    console.log(box);
PS: return返回值可添加数值返回，只能设置数值型和字符串数值
	不设置toString或valueOf即为NaN非数
	var box = 100;
	 +box //正数，负数


	var box = '100';
	alert(typeof +box);自动转换Nunber类型
	+号除了转换还有拼接功能，+,-,*,/ %

	100/'== 0  引号被转换成了0,第二个数不能为0

	var box = 3 < 2；关系运算符大多返回的是一个布尔值

	var box = null ==0 false  null会主动转换为0，但在比较运算上，null和undefined没有自动转换,所以null不等于0
	var box = null == 0;	  相反字符串在比较时，会自动转换

	逻辑与(and)，逻辑或(or)，逻辑非(not)
	var box = (5 > 4) &&(3 > 2); //&&并且,表示两边都必须是true，最终才返回true
	【如果两边的操作符有一个操作数不是布尔值的情况下，与运算就不一定返回布尔值,此时，遵循以下规则:】
	var box = {} && 5; //第一个操作数是对象,则返回第二个操作数
	var box = 5 && {}; 或 var box = 0 && {}; //第二个是对象的时候，第一个如果是true,则返回第二个对象，否则返回false
	var box = null && 5 > 4;  有一个操作符是null，则返回null
	var box = undefined && 5 > 4;  有一个操作符是undefined，则返回undefined
	var box = 3 > 4 && undefined 如果第一个操作符是false，则不去运行第二个操作数了
	
	【逻辑或||】
	var box = (5 > 3) || (3 > 4); //||运算符，只有一边是true。那么整体返回就是true
	【如果两边的操作符不是布尔值的情况下，逻辑与运算就不一定返回布尔值，此时,遵循以下规则:】
	2.第一个操作符的求值结果为false，则返回第二个操作符；
	3.两个操作符都是对象，则返回第一个操作符
	4.两个操作符都是null,则返回第一个操作符
	5.两个操作符都是NaN，则返回NaN
	6.两个操作符都是undefined,则返回undefined;
	【逻辑非NOT】!
	逻辑非运算符可以用于任何值。无论这个值是什么数据类型，这个运算符都会返回一个布尔值。它的流程是:先将这个值转化成布尔值,然后取反,规则如下:
	1.操作数是一个对象，返回false；
	2.操作数是一个空字符串,返回true；
	3.操作数是一个非空字符串，返回true;
	4.操作数是数值0，返回true
	5.操作数是任意非0数值(包括Infinit),false
	6.操作数null，返回true;
	7.操作数是NaN，返回true
	8.操作数是undefined，返回true
	var box = !!{}; Boolean({})是一样的结果

	位运算符有七种,分别是:位移非not(~),位与and(&),位或or(|)，位异或xor(^),左移(<<),有符号右移(>>),无符号右移(>>>).
	var box =~ 25; //-26
	var box = 25 & 3；//1
	var box = 25 | 3；//27
	var box = 25 ^ 3；//26
	var box = 25 << 3；//200
	var box = 25 >> 3；//6
	var box = 25 >>> 3；//6

	var box =(1,2,3,4,5)
	【对象创建】
	var box = {
	1:2,
	3:4,
	5:6
	}
	alert(box[1]);
========================================================================
77.【绕脑题，正确理解后置++,前置++与+拼接字符】
	var a =10；
	var x =（b=a--）
	x,b,a分别是多少
	【- -】是没什么用
	a=a+++a+++a++  = a =a+(++a)+(++a)++
	最后的+没有任何意义,期间默认第一个+是拼接符，第二个是++变量，自加一，也就是1+2+3...以此类推，以上可得到结果3
	继续来个 a =1
	a = a+++a*a-- 等于多少 答案5
========================================================================
78.理解老师讲最大公约数
  用户输入两个数，求最大公约数思路计算:
var a = parseInt(prompt('请输入第一个数字'));
var b = parseInt(prompt('请输入第二个数字'));
var ret = a < b = a : b;
	for(i = ret; i > 1; i--){
		if(a % i == 0 && b % i ==0){
	console.log(i);
	break;
	}
}
1.也就是用户输入两个数
2.定义一个变量，用三目比较其中一个数；
3.用for循环，i代替ret，求得公约数，用递减方式计算,
4.用if判断，两个数除与他们共同的公约数能出除进，那么就输入结果,使用break终结循环。
========================================================================
79.理解老师讲最小公倍数
	var a = parseInt(prompt('请输入第一个数字'));
	var b = parseInt(prompt('请输入第二个数字'));
	var ret = a < b = a : b;
		for(i = ret; i > (a * b); i--){
			if(a % i == 0 && b % i ==0){
		console.log(i);
		break;
	}
	}
	如上
	最小公倍数
	比如2和3，他们最小公倍数就是6，因为6既能被1整除,又能被2整除。
	同时得出2*3=6，也就是求出最小公倍数，只要循环判断变更为i <= a * b
========================================================================
80.【解决思路的难题:】
var i = 0;
var j = 0;
  for(t=0;t<=10;t++){
      i+=t;
      if(t==5){
          continue;
      }
      i+=j++;
      if(j==6){
          break;
      }
  }
算出公式:
====================================
i=0  0 1 4 9  16 25 36 49 	56 
t=7  0 1 2 3  4  5  6  7	8 【56+8=64】
j=8  1 2 3 4  5  6  7  跳出  等于8跳出不计算
     1 4 9 16 25 36 49		0
====================================
结果:64
PS:就算更改数值,原理也不会更改
========================================================================
81.【for循环从本质上的理解】
1.外层for循环是求出题目的最大数或最小数,进行递增【按照金字塔，就是计算列】
2.内层for循环是求出题目的每个公式【按照金字塔，就是计算行的单元格】
3.第三层就是计算单元格不同处，用公式算出来
========================================================================
82.小错误,老把month月写成mouth,要谨记教训,不犯错 
83.2017/1/18 13:16大错误,当if里{}和else{}大括号里嵌套if和else时,【必须】,【死活】,【一定】,【无论如何】,【千万】要对齐括号,无论如何不能少写if,否则的话会导致控制台也正确无法识别你哪一行错误,导致你按控制台提示去找错误,可能导致找几个小时也找不到原因,所以一定要注意.

如果真的到了粗心犯了少括号和id的时候,自己就是觉得写得对的,没错误.但也找不到哪出错
	使用唯一能解决方法,把和你写得一样正确代码,每一小段复制进来,把你的注释起来,浏览器查看下效果,如果还有错,说明你的代码这一行没问题,从下往上,或从上往下,继续【复制,注释,查看】,直到浏览器能正确出现效果,那么就可以得到结果,肯定是这一段哪有错,对【对齐你注释错误代码】和【有效果正确代码】,哪有不同,不同处就是你犯的错误,下次就要【谨记,刻在脑子.里】,不要再犯同样的错误
========================================================================
83.选择排序思路
	 选择排序,数组中的元素进行升序/降序排列
	 规则:数组的第一个位置上的数字，跟它之后的所有数字进行对比,选出最小值(最大值),排在第一个位置之后第二个位置上的数字,与其后所有数字再进行比对,选出最小值(最大值)排在第二个位置，以此类推，直到排列完毕 
		var arr = [3,4,1,5,2];
	 	//从小到大进行排序 升序排列
	 	for(i = 0; i < arr.length; i++){
	 		for(j = (i + 1); j < arr.length ; j++){
	 			//判断
	 			//第一个位置上的数i=0 跟内层j循环一轮的内层js进行比较，求最小
	 			if(arr[i] > arr[j]){
	 				var temp = arr[j];
	 				 	arr[j] = arr[i];
	 					arr[i] = temp;
	 			}
	 		}
	 	}
		console.log(arr);

	为什么循环求最小对比在左边
	比如 1 < 3 <5 < 6 【升序，从小到大】 要对比两个数哪个小，判断 【min > arr[i]】 或【arr[i] < min】
	     6 > 5 > 4 > 3 > 2 > 1【降序，从小到大】 要对比两个数哪个大，判断 【max > arr[i]】 或【arr[i] < max】
     	  3【新的变量存放】对比后面的值	
	 /\
	/  \
       1----2
	首先定义变量num3,,把num2后面的值赋给3，这样相当做了个备份,为了之后调用,num赋值到num2,接着再把3备份赋值到num1，这样就顺理成章替换了两个数大小。进行了排列
	var num3 = num2；
	    num2 = num1；
	    num  = num3;
【示范】:
	  2
	 /\
	/  \
       7----2
	也就是【min > arr[i]】假设第一个值大于第二个值情况
	再简单说就是只要记住，箭头前面永远是第二个数，箭头后面永远是第一个数，那么就不会出错

	还有重要一点:当arr[i] < arr[j]是降序，改成 > 大于号是升序
		也就是记住排序时>是升序【从小到大】
				<是降序【从大到下】


【另一种方法】冒泡排序
	 var arr = [3,4,1,5,2];
	 	//从小到大进行排序 升序排列
	 	for(i = 0; i < arr.length; i++){
	 		for(j = 0; j < arr.length - 1 ; j++){ //arr.length变换arr.length - i 也没影响
	 			//判断
	 			//第一个位置上的数i=0 跟内层j循环一轮的内层js进行比较，求最小
	 			if(arr[j] > arr[j + 1]){
	 				var temp = arr[j + 1];
	 				 	arr[j + 1] = arr[j];
	 					arr[j] = temp;
	 					
	 			}
	 		}
	 	}
	 	console.log(arr);
【第三种】
	var arr=[3,4,1,5,2];
	//升序排列
	
	for(i=0;i<arr.length;i++){
		var min =arr[0];
		if(arr[i]<min){	
			arr[0]=arr[i];
			arr[i]=min;
		}
	}		
	for(i=1;i<arr.length;i++){
		var min1 =arr[1];
		if(arr[i]<min1){	
			arr[1]=arr[i];
			arr[i]=min1;
		}
	}	
	for(i=2;i<arr.length;i++){
		var min2 =arr[2];
		if(arr[i]<min2){	
			arr[2]=arr[i];
			arr[i]=min2;
		}
	}
	for(i=3;i<arr.length;i++){
		var min3 =arr[3];
		if(arr[i]<min3){	
			arr[3]=arr[i];
			arr[i]=min3;
		}
	}	
	for(i=4;i<arr.length;i++){
		var min4 =arr[4];
		if(arr[i]<min4){	
			arr[4]=arr[i];
			arr[i]=min4;
		}
	}	
		console.log(arr);

【第四种】选择排序,和之前原理相同
var arr = [100,1,5,2,4,9,12,55];
	for(i = 0; i < arr.length - 1; i++){
		for(j = 0; j < arr.length - i - 1; j++){
			if(arr[j] > arr[j + 1]){
				var sum = arr[j];
				    arr[j] = arr[j + 1];
					arr[j + 1] = sum;
			}
		}
	}
	document.write(arr);
========================================================================================
84.
	//用函数编程 求出1 - 1/2 + 1/3 - 1/4…..1/100的和
	/*
	 	  1         1		     1
	 1 + ( - ____) + ( ____)...... + (- ____);
	 	  2         3		    100
	 */
		var num = 0;
		var n = 1;
		for (i = 1; i <= 100; i++) {
			num += 1 / i * n; 
			n *= -1;
		}
		document.write(num);

	奇数为正,偶数为负,所以n *= -1;
	1 = 1 * -1;
	为了将偶数时转换为负,负数转换为正
	* n就是为了转换正负数才添加
========================================================================================
85.给空数组分类查找数据
第一种:stringArr.push(arr[i]);
第二种:numArr.unshift(arr[i]);
第三种:booArr.splice(0,0,arr[i]);
第四种:undeArr[undeArr.length] = arr[i];


第二,三种是在开头添加
第一,四种是在结尾添加
第四种利用length长度比索引值多1的特征，来添加数据
========================================================================================
86.将字符中大写单词前用空格隔开,第一个首字母保持大小，其他转换小写
	function fn(str){
		var str = 'HelloMyWorld';
		var pattern = /[A-Z]/g; //先查找A-Z，所有大写字母
		var subStr = str.substr(1); //截取从开头字母之后并保存，防止之后输出首字母后有空格
		var newSubStr = subStr.replace(pattern,function(item,index,str){
			return " " + item.toLowerCase(); //在查找大写字母前，添加空格并转化小写
		});
		var newStr = str.charAt(0) + newSubStr; //合并原字符串代码并合并
		return newStr;
	}
	console.log(fn());
========================================================================================
87.验证手机正则表达式
	/^1\d{10}$/ 
	是一段正则表达式，/正则/，^表示开头，$表示结尾，\d表示数字，{10}表示前面的\d有10位，
	看样子是一个简单的验证手机号码是否正确的正则表达式……
========================================================================================
88.如何解决明明没写错，却无法正确输出结果
	Uncaught TypeError: str.charAt is not a function

	at rightTel (02_homework判断是否是一个合法的手机号.html:34)

【解决方法】很重要：
	可能是输出时:var str = parseInt(prompt('请输入11位手机号'));
	加了【parseInt】,只要去掉就好了
========================================================================================
89.当使用for循环判断两步或以上条件：
	比如【打印1-100中的所有偶数，并且每5个偶数进行换行】
	必须要在for循环上步创建空变量名来接收，第二步要进行判断数值，使用【变量++】递增来二次赋值得到数据，这么一来就能进行下一步操作和判断；
========================================================================================
90.使用var flag = flase(true);最后必须要进行if判断
	if(flag == flase(true)){} else{}
	如果要调用函数，一定要返回return 变量名;【非常重要】否则无法调用自定义的函数
========================================================================================
91.想把数组的进行字符串拼接，首先在【for循环外】声明空数组变量，然后在循环判断内进行【变量 += arr[i]】最后输出就好。
示范:
	function fn (str) {
		var arr = str.split('').reverse();
		var newArr = [];
		var strArr = '';
		for (i in arr) {
			if(newArr.lastIndexOf(arr[i]) == -1){
				strArr += arr[i];
			}
		 	 
		}
	console.log(strArr);
	}
	fn('iOS Android HTML5 Java');
========================================================================================
92,分析析式子:1+11+111+1111几次幂
	1=（10 ^ 0 * 1） 【公理】:10的次幂就是1
========================================================================================
93.【点击按钮背景颜色切换】从标签,元素名和class来进行操作
//页面中有5个按钮,点击按钮,该按钮背景颜色显示为红色,其他按钮背景颜色不变.
	var btns = document.getElementsByTagName('input');
		for(i = 0; i < btns.length; i++){
			btns[i].onclick = function () {
				for (j = 0; j < btns.length; j++) {
					btns[j].className = "";
				}
				this.className = 'cur';
			}
			console.log(btns[i]);
		}
========================================================================================
94.老把date写成dete，一定要注意
========================================================================================
95.setFullYear不能加新的变量存储，也不能直接setFullYear()输出，否则就会显示NaN非数
var date1 = new Date();
		date1.setFullYear('2017');
		date1.setMonth('2');
		date1.setDate('14');
		date1.setHours('21');
		date1.setMinutes('13');
		date1.setHours('14');
		document.write(date1);
========================================================================================
96.【如何正确调用函数】
		前提:如何调用函数呢?
		首先调用函数必须要传入实参	
			因为要调用的大部分函数体内都没有输出结果,所以必须自己在外部进行声明变量,再进行变量,否则的话就会无法输出结果
		函数名(实参);
		实参可以使自己创建的变量名
		比如 var ret = prompt('请输入你想输入数值');
			之后:document.write(函数体(变量名); 
				document.write(函数体(ret);
			
				console.log(函数体(变量名));
				console.log(函数体(ret));
		有几个形参,就传入几个实参变量
			比如document.write(函数体(变量名,变量名); 
			实参内用,逗号分隔
			

		PS:一个形参用【return 表达式;】直接返回
			等于二个或以上，用多个变量名，得到调用的实参
			若用来判断的功能，需要使用flag标记true和false判断，再进行【return flag;】



	※注:形参前面若有【...】代表传入多个参数,并且返回的是数组,实参无论什么类型都行
========================================================================================
97.【如何正确算出钟表角度公式】
	比如:
	0时10分秒0秒
	0时0分30秒
	600 / 120 = 5
	【每格6度】,每份5个格,也就是【分钟30度】,不变的死规律
	【秒针计算】
	小时 * 6; //这里的6就是6度
	0 * 6;
	【分针计算】
	每分钟角度30度
	分钟 * 6 + 秒 / 10;
	10 * 6 + 0 
	0 * 6 + 30 / 10； //求30秒后，也就是分针角度的一半，【也就是3度】
	【时针计算】
	小时 * 30 + (秒 + 分 * 60) / 120;
	0 * 30 + （0 + 0 * 60）/ 120; //每小时5个格，也就是30度,时针算的是下一针,分针算的也就是下一针30*2,所以60,
		【0时10分0秒】0 * 30 + （0 + 10 * 60）/ 120;
			600 / 120 = 5 //求快到1小时时,快到第一个刻度(每格)的 5/6.
========================================================================================
98.【注意使用外部调用点击事件】
	//点击全选按钮，所有复选框选中
	inpus[4].onclick = function () {
		//复选框选中
		for(i = 0; i < inpus.length; i++){
			if(inpus[i].type == 'checkbox'){
				inpus[i].checked = true;
			} else{
				inpus[i].checked = false;
			}
		}
	}
	1.一定要在存放元素,标签名 变量后添加【索引值】，之后再进行循环判断
	2.索引标签名或class一定要在判断里添加【存放变量名[i]】再进行判断,否则不会成功
	3.进到if判断内,要进行更改,true/false判断的话，也必须添加【存放变量名[i]】 = 【true/false】或表达式,条件

	【总结，但凡不是获取ID，获取Element,class,name都必须使用循环来遍历,之后再进行判断,获取具体的位置（索引值,下标）,再进行操作】
========================================================================================
99.怎样使用【存放父级ID,class】函数
【第一步】DOM文档加载完成,自动运行
	使用【onload = function() {}】前面不用加window也能解析执行
 	onload = function() {
		 var oUl = document.getElementById('ul1');
		 var aBox = getByClass(oUl,'box');
		 var i = 0;
		 for(i = 0;i < aBox.length; i++){
		  aBox[i].style.color = 'red';
		 }
	}

【第二步】普通函数调用执行
function fn() {
		 var oUl = document.getElementById('ul1');
		 var aBox = getByClass(oUl,'box');
		 var i = 0;
		 for(i = 0;i < aBox.length; i++){
		  aBox[i].style.color = 'red';
		 }
	}
	fn();
========================================================================================
100.使用getElementById()是伪元素,不能再后面添加[0]索引,而已ID本身就是独立的,所以没必要,如果添加了反而会报错.
	getElementsByTagName()Iindex];数组,可以自定义索引值

	示范:
	var myDiv = document.getElementById('div');
	var my =document.getElementsByTagName('div')[0];
========================================================================================
101.在函数内部调用【获取节点变量.onclick = function{};】无法生效解决方案
 	function click_action() {
		alert('第一次');
		var click_action2 = alertMsg("第二次了！");
		document.getElementById("enjoy").onclick = click_action2; //不可以.
	}
	//在函数内部要重复触发onclick事件调用,必须要在外部声明函数解决
	function alertMsg(t) {
		return function() {
			alert(t);
		}
	}

	【obj.focus()】 给指定元素设置焦点 
	【obj.blur()】 取消指定元素的的焦点
	【obj.select()】 这个方法是选中指定元素里面的文本内容

	首先在 IE下的方法：obj.attachEvent(事件名称,事件函数)  比如：
	obj.attachEvent('onclick',fn1);
	obj.attachEvent('onclick',fn2 );

	fn1(){ 
  		alert(this); //window
	}
	fn2(){ 
 		 alert(1 );
	}

// 标准 IE下弹出： window   1 
// 非标准 IE下弹出：1     window
这样就给同一个事件绑定了多个函数，且不会相互覆盖。

but由上 我们需要注意几点：

	1 在非标准IE下是没有事件捕获的，也就是说这个方法绑定函数，不存在事件捕获 
	2 事件名称是带on的  
	3 事件执行的顺序  标准IE下正序，在非标准IE下反序
	4 函数里this指向 window（这一点如何解决，请参考以前得到博客 JS的this指向，再继续阅读下面的）

	相对应的取消事件： 【obj.dettachEvent(事件名称,事件函数)】

接下来看标准浏览器下：【obj.addEventListener(事件名称,事件函数,是否捕获)】；（第三个参数默认是false ：代表冒泡　true:代表捕获）,（需要注意的是标准IE也有这个方法，也就是说标准IE下，这个方法和上面那个方法，它都具有）具体用法如下：
	【obj.addEventListener('click ',fn1,false);】
	【obj.addEventListener('click ',fn2,false);】
	fn1(){ 
  		alert(this); // obj 
	}
	fn2(){ 
  		alert(1); // 1
	}

	//点击obj 弹出顺序： obj ，1


第三种
	btn.onclick = null;



	【canvas.addEventListener('mousedown',dealMouse);】
	【Listener】倾听者
	【dealMouse】分配 鼠标
	【mouse】鼠标

	【loadeddata】加载成功触发的事件
	myPlayer.addEventListener("loadeddata",function () {
			})
	

========================================================================================
102.在函数内部使用for循环,调用i下标，必须得多加一步赋值
	遍历元素名[i].index = i; //必须在onclick之前添加才行
循环内容操作用
	遍历元素名[this.index]代替循环内[i]下标，也就是获取元素0,1,2,3,4......节点
========================================================================================
103.使用js使用css样式方式
	元素名.style['text-align'] = 'center'; //第二种，数组方式,不但换成驼峰命名法能用，用css样式也能使用【推荐使用】
	元素名.style.textAlign = 'center'; //第一种，横杠必须去掉,右面换成驼峰命名法


如果调用$css($('这里是id或元素名称'),'这里添加属性名','这里添加属性值，如果要初始化，直接添加引号就行');
========================================================================================
104，dom出现问题
	一定要从前往后检测，并检测创建的元素是否正确，否则会无法显示，也不报错。非常难检查===
			还有就是如果如果提示【is not defined】先去确认变量创建哪一行代码是否正确
	另外firefor火狐浏览器控制台是中文，【Ctrl + Shift + J】打开火狐控制台检测，比较齐全，很适合js检查
					   【Ctrl + Shift + K】和Chrome浏览器的【Ctrl + Shift + J】相同，打开console控制台在下方
========================================================================================
105，使用js正向,反向运动使用定时器时,如果使用
	【使用第一种方式】
	var 定时器变量名(function() {代码块},毫米);在这里面终止定时器,再点击时会出现卡顿和不断循环现象
	【推荐使用第二种方式】var  定时器变量名(fn函数名,毫米) function 函数名(){代码块};
				函数名();调用一次,这样才不会卡顿

	var timer = setInterval(function () {
			$ele('div')[0].style.left= $ele('div')[0].offsetLeft - 10 + 'px';
		var result = $ele('div')[0].offsetLeft - 0;
			if(Math.abs(result) <= 0){
		//if($ele('div')[0].offsetLeft <= 0){
			$ele('div')[0].offsetLeft = 0 + 'px';
			clearInterval(timer);
			}
		},100);
	}
========================================================================================
116.取消定时器,后面要加【.】点,不是【,】
	比如clearInterval(ele,timer); X错误
	    如clearInterval(ele.timer) √正确
========================================================================================
117.直接调用自定义的函数,$ele('ui')[0]和$q('li')[1]部分会出现undefined错误,要多加注意,除了ID外,尽量多使用getElementsTagName和queryElement.
	$q('li'); 会返回[]空数组,但无法使用索引值
========================================================================================
118.微信对话项目他人发现自己代码错误
	1.代码位置不对
	2.没写function img(){}调用
	3.class名写错,onclick写错成id
	4.图片路径文件名写错

【以后必须要细心,注意不要写错】
========================================================================================
119.【调用函数,封装自己库】
	1.调用函数必须放上面,最好用外部js文件,在<head></head>标签调用,如果在底部调用,会有一定几率出现各种奇葩问题,明明没错,就是报错,这就是调用函数放在下方的原因,只要放在要调用函数代码上面就可以解决了
========================================================================
120.使用DOM创建并操作页面元素时,【一定要记得给父级创建的元素再声明个变量来索引位置,否则直接用创建页面元素的变量后面添加，会出现无法添加问题出现】	
	var body = document.getElementsByTagName('body')[0]; //如果是在body添加,这一步必须的
	var div = document.createElement('div'); //创建div
		body.appendChild(div); //把div放到body内
	var txt = document.createTextNode('这是一个文本'); //创建一个文本
	    div.appendChild(txt); //√对,只有父级元素创建完成,这时在创建的元素后添加内容,就能把内容添加到div内

	PS:当页面有了元素标签时,js再创建标签,会覆盖前面创建的标签,必须再声明变量,来查找创建标签的位置,推荐使用TagName,其他的ById,ClassName,ByName根据情况来选择使用.
========================================================================================
121.创建元素后,添加时,要注意【append】后面不是【Node】,而是【Child】
========================================================================================
122.元素名.appendChild(6添加元素);
	注意appendChild后面不是【=】,而是【()】
========================================================================================
123.要同时使用cloneNode克隆和insertBefore在之前插入,必须要考虑清楚节点
	【insertBefore】前不能在同级节点创建插入,必须在父节点插入

比如:
	<tbody>
		<tr>
			<td>
				<input tyoe="button">
			</td>
		</tr>
	</tbody>

要点击input想插入tr,必须先获取input的爷爷级,要想插入必须,获取input的爷爷级的父级才能插入,否则不生效

  //点击当前button,对爷爷级的tr或其他爷爷级标签前进行复制(克隆)
 function $addFn (target) {
		//对爷爷级标签,也就是父级的父级进行复制
		var cloneTr = target.parentNode.parentNode.cloneNode(true);
		//背景色
//		clone.styleTr.background = $colorStr(); //要想插入随机颜色函数,需调用另一个函数
		target.parentNode.parentNode.parentNode.insertBefore(cloneTr,target.parentNode.parentNode);
	}

target.parentNode.parentNode.parentNode爷爷的父亲级也能直接用父级标签来代替使用,没影响

如果是在html文档内创建的,就必须在行内标签添加:onclick="$自定义函数(this);"
如果是在js内创建的,则必须:
createElement的input变量.setAttribute("onclick","$自定义函数(this)");
否则无法生效
========================================================================================
124.要删除节点的话,同样必须站在父节点角度删除,要删除的节点后面必须加[i],否则无法成功,就会提示
	且被删除节点必须站在孙子角度去删除,否则无法生效,比如:
	ul.removeChild(div[i].parentNode);
【父节点.removeChild(子节点,需循环遍历[i].parentNode.parentNode);】,因为每删除一行,长度都会改变,循环遍历后面一定要加
【i--;】


	Uncaught TypeError: Cannot read property 'parentNode' of undefined
	【Uncaught TypeError：无法读取定义的属性的父节点的】

	html:186 Uncaught NotFoundError: Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.
	【
HTML 186捕获的notfounderror：执行失败的removechild '结'：要移除的节点不是此节点的子。】

	TypeError: Failed to execute 'removeChild' on 'Node': parameter 1 is not of type 'Node
TypeError：	
	【执行失败的removechild '结'：参数1类型不是节点

Cannot read property 'parentNod' of undefined

	【无法读取定义的属性的parentnod”】

	PS:使用var ck = document.querySelectorAll('[name="ck"]');会出现只能删除删除一行问题,说明querySelector选择器只能选择某个特定的元素节点,多个节点不能获取】

	所以尽量使用var ck = document.getElementsByName('ck');
========================================================================================
125.注意封装函数时,不要在[]内添加形参,比如[num],这样会无法成功调用,应该连同获取元素和下标一起作为形参传给用户,这样才能正常使用
========================================================================================
126.js运动框架怎么计算
	首先X轴, 
	if(x < 0){
		【x = 0;】
		【speedX = speedX * -1;】//speedX就是定义随机数速度
	} else if(x > (当前函数内this指针.创建div元素变量.offsetWidth - 当前函数内this指针.width)){ //这里width或,height是自定义的随机高度
	【x = 当前函数内this指针.创建div元素变量.offsetWidth - 当前函数内this指针.width;】
	【speedX = speedX * -1;】

	}
	X轴同理
这就是运动框架原理,公理
========================================================================================
127.js中不能用alert作为变量,否则会错误.谨记
========================================================================================
128.全部删除按钮必须for循环再里面,否则会报错undefined
clear.onclick = function () {
			for (i = 0; i < tInp.length; i++) {
			if(tInp[i].checked == true){
			tbody.removeChild(tInp[i].parentNode.parentNode);
			i--;
			}
		}
	}
========================================================================================
129.使用parentNode才能返回父级,不要搞错用成parentChild
========================================================================================
130.innerHTML和innerText都能替换标签(元素)内的文本,注意outerHTML和outerText会将自身元素给替换,需谨慎处理
========================================================================================
131.previousSibling和nextSibling也会获取到换行符,首要手动去掉换行符,否则会提示#text,没有文本,也可以使用调用函数,去除换行,空格
========================================================================================
132.使用均速和缓动运动公式时,后者为什么要加【-this.index * 500】
	因为后者target这个公式,【-】号其实就相当于CSS的向左负值移动,
	【this.index】其实就相当于多个获取标签(元素)的下标(数目)
	【500】就是要移动的标签(元素)的宽度,在这里,前者移动的是【ul】,后者移动的是【li】,因为ul设置2000%,向右移动li,其实就是向左移动ul,所以speed速度就是li的宽度乘于要移动哪一张图片的下标,就得到当前移动位置
========================================================================================
133.使用ul轮播图开启定时器setInterval时,后面会有空白,需要DOM动态添加li>img的src第一张图片,这样才能避免

另外DOM动态添加图片路径时,不能用.setAttribute('src','路径');
	img.setAttribute('src','images/1.jpg');
用的话会使定时器不生效,必须使用DOM添加方法.src = '路径'方法才能生效
	ps:['src','路径']也不能生效
========================================================================================
134.点击大div,不停止图片自动滚动
	原因是没个定时器赋值到变量timer内,只要声明timer变量就好
		var timer;
		    clearInterval(timer);
		    timer = setInterval(fn,15);
		PS:使用定时器,一定要记得清空定时器,以防出现不必要的BUG
	也可以使用if判断,使用【true false】来停止计时器
========================================================================================
135.使用同一个定时器,毫米时间必须相同,否则会出现抖动
	否则因为轮播图片的速率超过了setinterval的时间间隔
	同时,均速和缓动运动公式不能同时使用,只能选其一来使用
========================================================================================
136.Jquery使用留言板,删除,必须放在点击[提交]按钮事件里,并且使用回调方法,否则无法成功
========================================================================================
137.使用对象遍历循环时,使用for(i in obj.data){}
	这里面i代码对象左侧属性,obj.data代表右侧属性值
比如ajax中
	str += i + '=' + obj.data[i] + '&';
========================================================================================
138.想得到字符串内重复个数
	用lastIndexOf() - indexOf() + 1
	lastIndexOf()不是从右往左,也是从左往右,它返回的是从左往右最后一个索引值
	indexOf是返回的头一个索引值
	charAt()是搜索有没指定的字符, 有的话返回,无的话返回-1
	一般使用循环,再查找指定字符
========================================================================================
139.必须脑子清晰弄清
	splice是Arrary数组对象的方法
	字符串的截取字串只有
	str.substr()和str.sunstring()
	这两个相同处在于都是以索引0开始查找,并且有一个参数时,都是从当前参数开始截取
			两个参数时,参数是结尾索引值,也是相同,和第一个参数原理相同,如果要截取指定索引位置到结尾字符串,压根没必要再填第二个参数,没任何意义,除非要动态指定,用length代替
		不同之处两个参数时
		substr()第二个参数是从第一个参数后面算起截取长度
		substring()第二个参数从第一个参数后面算起-1得到的截取长度，其实就是计算当前字符串的长度数截取

	比如 var str = 'abcdef';
		str.substr(1) :bcdef
		str.substr(1,4):bcde
		str.substring(1):bcdef
		str.substring(1,4):bcd
========================================================================================
140.在a标签使用调用函数,可以在href内后添加"javascript:fn();"函数名
	当然直接在后面添加onclick="fn()"也可以
	但要注意,使用onclick="fn()时,href内一定要填【#】或【javascript:;】,否则要双击两次才能触发onclick事件,因为前面href为空时,其实相当于又添加了一步点击事件
========================================================================================
141.对不支持javascript或IE下被阻止的ActiveX控件提示
	要在html内添加<noscript>这里只能添加文本内容</noscript>双标签
	里面添加text文本内容,用来提示用户原因,提高用户体验
========================================================================================
142.判断checkbox复选框是否选中
	除了用变量获取元素,
	if(form.checked == true)这样判断是否选中外
	也可以if(form.isDisabled == true)这样来判断是否选中
	
	设置禁止选中,只要form.disabled = true就好
注意:禁止选中不能再true添加,否则不生效
	
PS:isDisabled判断是否为禁止状态.disabled设置禁止状态 
========================================================================================
143.在对象里设置私有属性,使用函数回调时,若第一个不加【,】而是【;】,第二个不加【var】声明变量,那么在第二次相同私有属性,实例(创造对象)里,最后一个会返回一个list{end}的对象,
	解决方法一:
		只要把【;】改回【,】就能解决这个问题
	解决方法二:
		把和创建对象名相同的属性改成不同的就好
  function list(x,y,z){
    var a = x;  //a是私有成员，在对象外不能访问
        b = y;      //b是私有成员，在对象外不能访问
    this.c = z; //c是公有成员，在对象外能访问，可通过“.”修饰符访问
    this.geta = function (){
        return a; //这个方法返回a
      }
    this.getb = function (){
        return b; //这个方法返回b
      }
  }
  var a = new list(1,2,3);
    console.log(a.a);
    console.log(a.b);
    console.log(a.c);
    console.log(a.geta());
    console.log(a.getb());
  var b = new list(4,5,6);
    console.log(b.a);
    console.log(b.b);
    console.log(b.c);
    console.log(b.geta());
    console.log(b.getb()); //list{6}

	为什么会得到对象6,这是因为在第二步时,
	b = y 是全局 所以b此时是5,
	然后退出构造函数,输出第二个的结果后,再次进行解析实例,
	因为实例和属性相同名相同,所以b = {},这时再返回第三个值,它会自动添加到自身的对象里,所以得到结果是list{6};
========================================================================================
144.使用面向对象,如果子类和父类有相同方法(函数),怎样调用父级的方法(函数)?
 function 生物(){
    this.eat = function(){
      console.log("生物可以做出物质交换");
      }
  }
  function 牛(){
    this.eat = function(){
      console.log("牛可以吃草");
    }
  }
  牛.prototype = new 生物(); //牛“继承”了生物的属性
  var a牛 = new 牛();
  a牛.eat(); //返回的是子类牛的属性

下面的例子使牛的eat方法调用父类生物的eat 方法
        function 生物(){}
        生物.prototype.eat = function(){
                alert("生物可以做出物质交换");
        }
        function 牛(){}
        牛.prototype = new 生物(); //牛“继承”了生物的属性
        牛.prototype.eat = function(){
            return 生物.prototype.eat.apply(this);
        }
        var a牛 = new 牛();
        a牛.eat();

	1:创建父类function函数,并为空
	2.给父类function函数添加property原型方法
	3.创建子类function函数并为空
	4.给子类function函数,clone拷贝父类函数()
	5.调用子类函数property原型方法,并添加function功能,在代码块添加
			【return 生物.prototype.eat.apply(this)】回调给子类的原型方法
	这样子类就继承了父类的property原型方法

	上面不能直接写【牛.prototype.eat = function(){return 生物.prototype.eat();}】,只能用apply来调用父类的eat方法，			→※注:apply的参数决定基于哪个对象调用父类的eat方法。
========================================================================================
145.什么是闭包?【闭包】
【闭包函数是指内层函数可以调用外层函数的参数和该函数的变量】

在javaScript语言中，函数闭包是指在函数顶层可以再定义函数，即函数可以嵌套的。简单地说，闭包也就意味着内层的函数可以引用存在于包围它的函数内的变量及该函数的参数，即使外层函数的执行已经终止。这个特征非常强大和复杂。JavaScript闭包函数使用的主要场景主要有以下3点：
		1.保护函数的变量安全，在内存中维持一个变量，通过保护变量的安全实现JavaScript私有属性和私有方法。
		2.在网页中实现动画效果
			主要利用JavaScript脚本语言和CSS来改变文档对象的属性，其中主要是改变3个CSS属性: 透明度,大小,位置
========================================================================================
146.【表格合并单元格】【合并边框】【合并表格边框】【表格边框】[表格边框]
	把table设置为border：0;
	第一种:
		border-spacing:0;
		caption间隔
	第二种：
		border-collapse：collapse;
		collapse折叠/倒塌
========================================================================================
147.【一定要注意】
	Bootstrap一旦上面使用【container】布局。下方就不能使用【container-fiuid】流式布局,因为下方会继承上方container布局。
相反头部栏使用【container-fiuid】流式布局，下方使用【container】布局就完全没问题
========================================================================================
148.CSS怎样自适应图片
	只要在img的CSS样式内添加
	display:block;
	min-width:100%;
这样就实现了所有宽度自适应的效果
========================================================================================
149.【自适应留白】
	为什么使用自适应的布局，使用width:100%；缩小或放大一定程度，出现右面留白呢？
这是因为一旦放大宽度大于浏览器窗口宽度，那么100%就会自动撑开，所以右面会有留白。
【解决方法】:
	只要在使用width:100%;的样式内，添加【min-width:1263px】就好了
========================================================================================
150.CSS用百分比时想设置等高的,圆角矩形，只要设置【border-radius:20px】就好
========================================================================================
151，修改Bootstrap的样式，如果有上下左右空白，直接在CSS里改它的样式,后面添加【!important】，以防无法更改情况
========================================================================================
152,【实例化】是什么?
	【实例化】从字面意思就是【实现类的某些方法】
========================================================================================
153.用js创建svg内元素,必须使用
	【document.createElementNS(网址,添加元素名)】
	var xmlns = "http://www.w3.org/2000/svg"
	var rect2 = document.createElementNS(xmlns,"rect");

	也可以放在一行内
	var rect2 = document.createElementNS('http://www.w3.org/2000/svg',"rect");
========================================================================================
154.e.offsetX(event.offsetX)或e.offsetY(event.offsetY)提示【undefined】
	这是因为使用HTML-DOM操作.并在事件后面内添加了【this】,这时this指向window,所以才提示undefined,只要把this去掉就好了

========================================================================================
155,jQuery jq获取元素名(标签名),一定要在后面加[0]索引值,否则不生效
	同理,class和name属性名也一样
	或直接在$(this),this必须用$()包起来,否则会不生效
========================================================================================
155,jq中使用z-index提升/降低层级不能使用,.css({})和animate({})会不生效会出现无法生效情况
	直接在css定义个class,使用.addClass()和removeClass()就不会有这情况
========================================================================================
156.jq中不能直接用for循环,必须包在function函数体里,并执行一次,之后才能使用,且循环数组的对象JSON格式时,不能使用【for in】循环,否则不生效
========================================================================================
157.jq中创建DOM元素,要记住添加元素要用【append()】来添加
	而不是使用【html()】来添加,【html()】不受循环限制,只能添加一次,而【append()】却能根据循环几次添加多少次
========================================================================================
158.在jq事件内,必须使用【$(this)】才行,否则不生效
========================================================================================
159.在javascript或jquery事件中,onclick,不用声明变量,直接【this.变量名】就等于设置了匿名变量,因为this指向的是当前事件,当前时间内其实也是局部函数,所以可以用这招解决老声明变量的问题.
========================================================================================
160.不要直接在js中使用【top】,【left】和【bottom】,【right】,因为window对象有相同名的方法,会冲突无法执行,需要使用时,用新的变量来存放
========================================================================================
161.使用jq使用ajax动态生成JSON数据文件
	先获取
	var url = "http://127.0.0.1/api/artist/public/index.php?m=music&a=list";
	var img = 'http://127.0.0.1/api/artist/';
	mui.get(url, {}, function(result) {
		var obj = JSON.parse(result);
			content = obj.data;
	循环遍历
	for(var i in content) {
	var $li = '<li>'
		  + img +....//再要添加数据的时,换行并在前面+,后面空格,这样会显得更公整
	}

	※注:在动态添加图片不要加/号,否则会报错
	比如:
	    src='
		+ img + content[i].img_url
		+ '/>'
	这样就会失败,必须去掉后/,才能成功显示图片
========================================================================================
162.jq动态生成audio必须在js变量里添加src=""和controls="controls",否则无法正常显示.
========================================================================================
163.→原生js动态ajax生成json文件,重复添加第一个解决方法
	比如
		【categoryTag = newLi.querySelector('.cell-category')】
	
	变量右面 的左面的newLi是克隆的li,查找每次循环下克隆的li下的元素,这样才能添加json全部数据,如果写成【document.querySelector】就会从window全部查找,会将数据克隆成一样的数据
========================================================================================
164.→使用原生js用ajax获取服务器数据,不用加[index],因为DOM不是数组,使用jq时,要加index],因为jq是数组的集合体
========================================================================================
165.在jq事件内,可以直接this来代替$(this),这样可以直接使用DOM操作方法,真是超方便
	默认在$(function(){this})入口函数,指定的是documnet
	而在js中指向的是window
========================================================================================
166.如果有相同功能的js和jq,会优先执行原生js.
========================================================================================
167.如果mui.openWindow点击没反应,不跳转,说明a默认为空,默认为空会刷新本页面,href没添加【javascript:;】或【#】,没清除默认样式,否则会在跳转之前就刷新,只要在href添加以上两个才能生效
========================================================================================
168.如果使用jq时,localStorage获取元素ID值,如果一直提示【undefined,undefined,undefined,undefined,undefined】但是页面已经获取了id,就只能是
		var obj = JSON.parse(result); ←不是引号,是冒号
		     content = obj.data;
	不使用多个var变量声明,用逗号隔开多个变量名并赋值
	※注:一定,一定,一定不要犯这种低级错误,否则你可能死活找不到原因,因为出现undefined,你一定回去找id是否存在,但要是存在的话,你却死活获取不到,你又会去换种方式获取,要是还是获取不到,就容易陷入死胡同,一定要,一定要每步都检查,这样才不至于以后犯致命的错误
========================================================================================
169.mui用axjx下载json文件
	mui.get(url1,{},function(result){}
	这二个若使用GET方式传输,不用加{}也行
========================================================================================
170.注意API接口,只要变量保存,就自动保存了,不用二次赋值,相当于快捷方式保存
========================================================================================
171.→一定要注意,在mui的ajax内生成数据,若想获取并给予事件的话,那么必须在mui.get()内写事件,否则会不生效.
========================================================================================
172.→原生js拷贝时,给元素自定义属性setAttribute并赋值,再进行获取getAttribute,不要直接用新拷贝变量获取,直接使用【this】就好,包括事件源,也必须是自定义属性的变量才行
========================================================================================
173.→→→→→【从hbuilder左侧栏复制文件,一定要注意【Shidt + delete】永久删除,或直接移动,可能会导致文件被误删,导致之前做的功亏一篑.
	2017/4/7 4:29犯了大错误,导致上午做的【简约-项目文档项目-豆瓣爱搜索】全完了,以后一定要注意,新建项目文件夹再保存,更保险起见,在文件夹里做完复制一份,或压缩一份以防万一】
	在此起誓:这是第一次也是最后一次犯得重大错误
========================================================================================
174.改滚动条CSS,只有IE和Chrome webkit内核能使用,其他浏览器不支持
	::-webkit-scrollbar {
		width: 0;
	}
	scrollbar-face-color: transparent;
	scrollbar-highlight-color: transparent;
	scrollbar-arrow-color: transparent;
	scrollbar-3dlight-color: transparent;
	scrollbar-base-color: transparent;
	scrollbar-darkshadow-color: transparent;
	scrollbar-shadow-color: transparent;
	scrollbar-track-color: transparent;
	
	移动端
	-webkit-overflow-scrolling:touch;
	overflow-scrolling:touch;
========================================================================================
175.jq轮播图，jquery轮播图
	//显示第一张图片
	$(".banner>ul>li").eq(0).css("display", "block").siblings().css("display", "none");
	//动态生成小圆点
	$(".banner>ul>li").each(function() {
		var $round = $("<span></span>");
		$(".mark").append($round);
	})
	//第一个按钮样式改变
	$(".mark>span").eq(0).addClass("first");
	//保存num用于自动轮播
	var  num=0;
	//点击切换图片
	$(".mark>span").click(function() {
		$(".banner>ul>li").css("display", "block");
		$(".banner>ul>li").eq($(this).index()).css("opacity", "1").siblings().css("opacity", "0");
		$(this).addClass("first").siblings().removeClass("first");
		//保存下标，如果没有点击num=0;点击了num=下标值
		num = $(this).index();
	})
	//自动轮播
	setInterval(function(){
	$(".banner>ul>li").css("display", "block");
			$(".banner>ul>li").eq(num).css("opacity", "1").siblings().css("opacity", "0");
			$(".mark>span").eq(num).addClass("first").siblings().removeClass("first");
			num++;
			if(num==4){
				num=0;
			}				
	},2000);
========================================================================================
175.为什么重复点击同一元素事件,点击恢复,只有点击成功,恢复失效
	1.【不要把外部判断的falg=true/false或i=0】放在事件里面,否则不生效,必须放在事件外面才能生效
	2. 【$(this).find('#Off').removeClass('off').addClass('on');】要删除当前class再设置新的class.一定要添加id来获取.因为一旦删除class,就获取不到了,自然无法得到后面的class进行else操作
========================================================================================
176.让图片,文字在未知div宽高水平,垂直居中
	【display:table-cell;】
	【text-align:center;】
	【vertical-align:middle;】
========================================================================================
177.让页面在宽度小的时候,内容长的句子不自动换行,显示省略号.
	【overflow:hidden;】
	【text-overflow:ellipsis;】
	【white-space:nowrap;】
		nowrap不包裹
========================================================================================
178.※→注意:在解决问题,比如获取input的value值,然后判断时,不要以正面思维,去想怎样实现flag=true,而要用逆向思维,先去想如果不等于flag=true;也就是flag=false该怎么去处理.这样能够解决很多正向思维无法解决的问题.
========================================================================================
179.→【怎样往对象里添加数组的属性名和属性值】[对象添加数组][对象添加字符串]	
	往对象添加数组,一定要记住【=】前面对象[]里面是属性名,【=】后面是属性值
		以下arr[i]是属性名,1是属性值,因为要循环遍历,每次都会是第一个数组
		和数组的正好相反,一定要注意,i是索引值,arr[i]是元素.
	var obj = {
			arr = 1,
			arr = 2,
			arr = 3,
	  }
  		var arr = ['a=1','b=2'];
  		var obj = {};
  	for(var i in arr){
		arr = arr[i].split('='); 
		obj[arr[0]] = arr[1];
  	}
	//结果 {a:1,b:2};
========================================================================================
180.设置[标签栏图标][head图标][头部图标][网页][网页图标][网页头部图标][顶部图标][头部ico]
	在<head></head>头部添加
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="Bookmark" href="favicon.ico" type="image/x-icon">
	shortcut捷径
	Bookmark书签
	→注:图标名必须是【favicon.ico】否则火狐不生效
	→如果放子目录下,在IE下如果要显示,必须写绝对路径http://域名/favicon.ico 否则不显示
	火狐放相对/绝对都显示
========================================================================================
181.如果浮动时,只有左面浮动,右面浮动却下去了,而高度也没问题,那么可能出的问题只有:
	给父级设置浮动就好
========================================================================================
182.jQuery写[三级列表][三级菜单][分类导航][分类列表][三级分类导航]时,不要把要点击的标签和要显示放在同一个父级,它们不能兄弟级,否则jQuery获取元素,会出现无法正确获取索引值情况
	
【三级列表】【三级菜单】【分类导航】【三级分类导航】[三级列表][三级菜单][分类导航][三级分类导航]
	示范:
    <!--1.要在最外层添加div-->
    <div id="container">
        <!-- 2.在里面写个h1标签,这是为了实现点击一级列表显示 -->
        <h1>所有产品分类</h1>
            <!-- 3.给要显示所有菜单设置大div -->
            <div class="lists-container">
                <!-- 二级左侧列表 -->
                <ol class="list-2">
                    <li class="list-2-menu"><a href="javascript:;"></a></li>
                    <li class="list-2-menu"><a href="javascript:;"></a></li>
                    <li class="list-2-menu"><a href="javascript:;"></a></li>
                
                </ol>
                <div class="list-3-container">
                <!-- 三级列表右侧大div -->
                    <div class="list-3-item">
                        <!-- 三级列表 -->
                        <ul>
                            <li class="list-3-menu"><a href="javascript:;"></a></li>
                            <li class="list-3-menu"><a href="javascript:;"></a></li>
                            <li class="list-3-menu"><a href="javascript:;"></a></li>
                           
                        </ul>
                        <!-- 三级列表子列表 -->
                        <div class="list-3-children">
                            <ul>
                                <li class="list-3-item"><a href="javascript:;"></a></li>
                                <li class="list-3-item"><a href="javascript:;"></a></li>
                                <li class="list-3-item"><a href="javascript:;"></a></li>
                               
                            </ul>
                        </div>
                    </div>
                     ......
                </div>

            </div>
    </div>

	用for循环或事件委托来实现效果,首先按顺序考虑

二级列表:
	1.先循环所有二级列表
	2.给每个二级列表设置索引值 =>元素[i].index
	3.触发悬停事件
	4.用if(!$hacClass(this,class))来判断,如果是true的话添加class
		也可以使用ES6直接判断,
		!this.classList.contains('lihoverstyle')
	5.显示所有子菜单
	6.移除所有的二级列表class
	7.给当前添加class
	8.隐藏所有子菜单内容
	9.if判断(ele[this.index])是否不为空,是的话显示当前三级子列表,使用[this.index]

	注:二级列表显示/隐藏,都得在循环内才行

三级列表:可独立for操作
	1.先循环遍历所有三级列表.
	2.元素[i].index保存索引值
	3.触发点击事件
	4.移除当前点击列表内所有的class
	5.给当前点击添加class
	6.隐藏所有三级子列表
	7.if判断(ele[this.index])是否不为空,是的话显示当前三级子列表,使用[this.index]
	
	
	事件委托-获取当前元素索引值
	var menuList = menu.getElementsByTagName('li');
	var current = e.target || e.srcElement;
	//判断如果是li标签子元素话赋值到li
	    current = (ev.target.tagName == 'H3' ) ?  ev.target.parentNode : _current; 
	    current = (ev.target.tagName == 'A' ) ?  ev.target.parentNode.parentNode : _current; 
	
	【Array.prottype.slice.cell(menuList).indexOf(current);】
========================================================================================
183.【js原生class切换】【js类切换】[js类切换][js原生class切换]
		用事件委托来切换

		→首先,【ClassName+=】也就是先给子级属性添加class,相当于jQuery的addClass()
		1.当移除时,使用【classList.remove】移除对应所有的class
		2.使用String的replace替换方法,前者要替换的class,后者为空,也变相的删除class
		3.通过一个变量保存移入事件前的class,当要移除时,替换这个变量保存得之前的class,相当于jQuery得attr('class','要替换的class')方法
		
		//获取城市最外层
		var cityWarp = document.getElementById("J_cityWarp")
		//获取城市名称
		var cityName = document.getElementById('J_cityName');
		//获取城市列表
		var cityList = document.getElementById('J_moreCity');
		//保存原来的class值
		var classPlay = cityName.className;
		//鼠标移入
		cityWarp.onmouseover = function(){
			cityName.className += ' ' + 'city-active';
			cityList.style.display = 'block';
		}
		//鼠标移出
		cityWarp.onmouseout = function(){
				//第一种
//				cityName.classList.remove('city-active');
				//第二种
				cityName.classNmae = cityName.className.replace('city-active','');
				//第三种
//				cityName.classNmae = classPlay;
				cityList.style.display = 'none';
		}
========================================================================================
184.事件委托比for循环比较?
	优点:减少事件注册,节省内存空间,
		1.每个点击事件都是个函数,点击越多,占用内存越多.
		2.每一次for循环都进行DOM交互,交互越多,性能越差
	
========================================================================================
185.[js动画效果封装][js动画封装]
	1.首先要得到两个值,第一个ele,另一个移动value
		function(ele,moveNum){}
	2.先停止定时器clearInterval(ele.times);
	3.开启定时器ele.times = setInterval(fn)
	4.获取padding-left值,为了防止是负数,用parseInt()转整数
		var pLeft = ele.style["padding-left"] || 0
	5.运动速度判断
		(1)添加变量 speed = 0;
		(2)如果moveNun大于0,那么(位置+10) /10,使用缓动公式
		speed = parseInt(pLeft + 10) / 10;
		【元素位置 = 元素当前位置 + (target - 元素当前位置) / 10;】
		(3)如果位置大于等于速度,停止定时器.并返回return;
		(4)否则的话,负(位置+10) /10,使用缓动公式;
		(5)如果位置小于等于速度,停止定时器.并返回return;
		(6)最后再进行三目判断,速度是否大于0,是的话就是整数,就向下取整,否则的话就是小数,向上取整
		(7)把(当前位置 + 速度) + 'px'赋给当前元素的padding-left就行了
	示例:
	paddingMove : function  (ele,moveNum) {
		clearInterval(ele.times);
		ele.times = setInterval(function  () {
			//获取当前元素paddingLeft
			var pLeft = parseInt(ele.style["padding-left"] || 0);
			//运动速度
			var speed = 0;
			if(moveNum > 0){
				speed = parseInt(pLeft + 10) / 10;
				if(pLeft >= moveNum){
					clearInterval(ele.times);
					return;
				}
			} else{
				speed = -parseInt(pLeft + 10) / 10;
				if(pLeft <= moveNum){
					clearInterval(ele.times);
					return;
				}
			}
			speed = speed > 0 ? Math.floor(speed) : Math.ceil(speed);
			ele.style["padding-left"] = (pLeft + speed) + 'px';
		},20)
========================================================================================
186.怎样实现自动时间刷新页面,在head标签内添加[自动刷新]
	【<meta http-equiv="refresh" content="5">】
========================================================================================
187.给标签背景设置图标定位,必须分开才能显示效果[背景图标][背景定位]
	background-image:url(images/commodityList/desc.png);
	background-repeat:no-repeat;
	background-position: 90% 7px;
	background-size: 20px 20px
========================================================================================
188.给图片div设置宽度px或百分比,设置max高度,然后图片宽100%,高100%,这样图片就会根据外层div来设置高宽
========================================================================================
189.设置背景图大于实际需要大小,该如何处理?[精灵图][精灵图太大][背景图太大][背景图片太大][背景图大]
解决方法:
	DOM结构:
	<div id="box">
        	<span></span>
    	</div>


	CSS样式:
	#box{
            width:100px;
            height:100px;
            border:1px solid red;
        }
        #box span{
            display: block;
            /*当精灵图大于你想要的大小时,外层设置宽,内层图标不要设置width宽,否则无法成功更改大小,直接设置高和背景大小就好,但也可以设置width:100%;继承父级宽度*/
            /*width:50%;*/
            height:50%;
            background: url(btn_tel.png) no-repeat 52px 9px;
            margin: 5px auto 0;
            background-size: 36px 80px;
        }
========================================================================================
189.[复选框][CSS单复选框技术][CSS3单复选框技术][属性选择器]
	兄弟选择器
:checked + .box { /* IE9+选中效果 */ }
[checked] + .box { /* IE8选中效果 */ }
[defaultChecked] + .box { /* IE7选中效果 */ }
	→:不支持IE6及以下

包括CSS 2.1水平的属性选择器
	[attr], [attr="val"], [attr~="val"], [attr|="bar"]以及CSS3水平的属性选择器[foo^="bar"], [foo$="bar"], [foo*="bar"]
	所有这些属性选择器IE7浏览器都是支持的

	【[attr~= "val"]】匹配属性有后面指定单词,单词前必须有空格,或为空,且符合单词属性
	这个表示，属性值中间，有匹配val的单词，注意这里的名词——“单词”。CSS3中有一个[foo*="bar"]，表示，属性值中间，有匹配的字符内容，这里这里的名词——“字符”。大家都知道，CSS选择器这东西是老外弄出来的，老外的的母语是English, English的句子都是一个单词+空格+一个单词实现的。这这里的[attr~="val"]
	【[attr|="bar"]】指开头必须是后面指定单词,后面必须为空,空格或者单词-
	这个表示，属性值开头必须是bar的单词，或者开头是bar-。CSS3中有一个[foo^="bar"]，表示属性值以bar字符开头即可。类似上面的单词和字符的区别，因此有：

	 【first-child】伪类选择器
	IE7浏览器还支持:first-child伪类，可以选择第一个子元素。

	但是呢，与之对应的:last-child伪类却不支持，别说IE7浏览器了，IE8浏览器也不支持:last-child伪类，一直到IE9浏览器才支持。

	【position:fixed】固定定位
	IE6浏览器只支持absolute定位，IE7——开始支持fixed定位，也就是浏览器观点，元素位置不变，纹丝不动，不被滚走。

	【min/max-width/height】最大/小宽度高度
可以实现特定宽度区间内的自适应布局。例如：1024像素到1280像素，就可以使用min/max-width/height控制，不需要JS参与，兼容IE7+浏览器。

	【png alpha】透明
以前IE6浏览器只支持索引透明，IE7浏览器下面，不仅索引透明支持，Alpha通道透明也支持。于是乎，我们的布局更自由，图片资源利用率更好了，因为PNG图片适用于各种场景各种背景，从此告别传统年代图标的毛刺的效果图。

	【border-color:transparent】透明
以前IE6浏览器，边框颜色设为transparent实际上显示的是黑色，但是IE7浏览器支持边框透明色，使用border模拟图形的时候，就少了很多阻碍。========================================================================================
190.[裁剪图片][裁剪绝对定位]
	可以用来隐藏自身和裁剪图片
	DOM结构:
		<input type="radio">
    		<input type="checkbox">
    		<input type="submit">
	CSS样式:
		input[type='radio'],
        	input[type='checkbox'],
        	input[type='submit'] {
            	position: absolute;
            	/*以下这是隐藏自身  分别为clip:rect(top, right, bottom, left)*/
            	clip: rect(0 0 0 0);
        	}
========================================================================================
191.[清除浮动][浮动清除]
	 触发了haslayout清除浮动
	haslayout 是否有 布局 (哈是 类页)
	
	第一种:最常用【不推荐】:
		是在需要清除浮动的地方加个div.clear或者br.clear，我们知道这样能解决基本清浮动问题。
	但是这种方法的最大缺陷就是改变了html结构，虽然只是加个div。
	.clear{
		clear:both;
		height:0;
		overflow:hidden;
	}
	第二种【推荐】:
	    最优浮动闭合方案（这是我们推荐的）
        .clearfix:after {
            content: ".";
            display: block;
            height: 0;
            clear: both;
            visibility: hidden
        }

        .clearfix {
            *+height: 1%;
        }
	用法很简单，在浮动元素的父云素上添加class=”demo clearfix”。	你会发现这个办法也有个弊端，但的确是小问题。改变css写法就ok了：

	第二种-改:
	.demo:after, .demo2:after {
            content: ".";
            display: block;
            height: 0;
            clear: both;
            visibility: hidden;
        }

        .demo, .demo2 {
            *+height: 1%;
        }
	以上写法就避免了改变html结构，直接用css解决了。

	页面中class为clearfix
	其中*htnl 和*+html 都是IE特有的标签
	height：1%  clearfix里在你上一层的div中的高取百分之一
	也就是100px 就是1px

	第三种:
	.clearfix {
        	overflow: hidden;
        	_zoom: 1;
    	}

	
========================================================================================
192.触发haslayout(哈是 类页)元素?
        * body and html
        * table, tr, th, td
        * img
        * hr
        * input, button, file, select, textarea, fieldset
        * marquee
        * frameset, frame, iframe
        * objects, applets, embed
        对于并非所有的元素都默认有布局，微软给出的主要原因是“性能和简洁”。如果所有的元素都默认有布局，会对性能和内存使用上产生有害的影响。
        如何激发 haslayout？
        大部分的 IE 显示错误，都可以通过激发元素的 haslayout 属性来修正。可以通过设置 css 尺寸属性(width/height)等来激发元素的 haslayout，使其“拥有布局”。如下所示，通过设置以下 css 属性即可。
        * display: inline-block
        * height: (任何值除了auto)
        * float: (left 或 right)
        * position: absolute
        * width: (任何值除了auto)
        * writing-mode: tb-rl
        * zoom: (除 normal 外任意值)
        Internet Explorer 7 还有一些额外的属性(不完全列表):
        * min-height: (任意值)
        * max-height: (除 none 外任意值)
        * min-width: (任意值)
        * max-width: (除 none 外任意值)
        * overflow: (除 visible 外任意值)
        * overflow-x: (除 visible 外任意值)
        * overflow-y: (除 visible 外任意值)
        * position: fixed

	zoom 总是可以触发 hasLayout(哈是 类页)，但是在 IE5.0 中不支持。
	对 IE6 及更早版本来说，常用的方法被称为霍莉破解(Holly hack)[读音:耗类 哈克]，即设定这个元素的高度为 1%(height:1%;)。需要注意的是，当这个元素的 overflow 属性被设置为 visible 时，这个方法就失效了。或者使用 IE的条件注释。

	对 IE7 来说，最好的方法是设置元素的最小高度为 0 (min-height:0;)。

	haslayout 问题引起的常见 bug
	1.IE6 及更低版本的双空白边浮动 bug
	  bug 修复: display:inline;
	2.IE5-6/win 的 3 像素偏移 bug
	  bug 修复: _height:1%;
	3.IE6 的躲躲猫(peek-a-boo) bug
	  bug 修复: _height:1%;
	4.IE6/7负margin隐藏Bug：
	  bug 修复:去掉父元素的hasLayout；或者赋hasLayout给子元素,并添加position:relative;	需要注意的是，hasLayout属性是微软特有的过时属性，在IE8、IE9中，hasLayout属性已经被废弃。上文中的InternetExplorer都是指IE7、IE6及以下版本。
	

	在一个div#box里面放置一个浮动的div#float（例如：里面的内容是2行文字）和一个没有任何 CSS样式的div#content（例如：里面的内容是1行文字），然后在它们的下面放置一个div#clear（例如：里面的内容是1行文字）
	这样的话在IE7及其它标准浏览器浏览是没有问题的，分别显示出这3块文字内容，但是在IE下浏览时就只显示出了div#float、div#clear里面的内容(演示)，div#content就莫明奇妙的消失了，在哪里？你把鼠标放在应该显示的地方划一划，就出现了本该出现的内容。也就是在变化背景的时候它就会出现，你也可以在div#clear下面放置很长很长的内容，也就是使浏览器出现滚动条，你向下拖动滚动条再拖回来，它一样也出现了，这样就明白了它为什么叫Peekaboo！
	→修复Peekaboo Bug几种方法:
	●1(br生效).不要在div#box里面使用背景
	●2(br不生效).保持div#clear和div#float在一起。
	●3(br不生效).给div#box一个明确的“宽度”或“高度” 。#box { height: 100%; /* kill peekaboo bug in IE */}
	●4(br生效).把div#box和div#float的定位类型都设置为“相对”。
	
	
	*html与*html是IE特有的标签,firefox暂不支持  IE6到以下
	*+html 为IE7特有标签

	注:*+html对IE7的hack保证html顶部有如下声明:
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
            "http://www.w3.org/TR/html4/strict.dtd">



	#container{
		min-width:600px;
		width:expression(docuemnt.body.clientWidth < 600 ? "600px" : "auto");
	}


















































【】
[记录]【记录】




.不懂那些选择器需要设置那些代码【死记硬背,目前只能如此】
.不懂各种框父子关系【记录,练习,脑海扩充。随着经验来记忆】
.不懂js【将来学】
.不懂jq【将来学】
.不懂bootstrap里面选择器英文名，和为什么要那样设置，等html5+CSS+JS都熟练后差不多就能理解
.不懂PHP,SQL,SEO,网络运营,自己做站长赚钱【最终目标,一定有时间学】



【第一部分】全局设置
.*【外边距和内边距为0】{marin:0; padding:0}
.body【背景颜色 字体类型】{background:#000; font-family:"宋体"}
.ul li【列表格式没有】{list-style：none}
img【边框设置0】{border:0}
a【文本修饰没有】{text-decoration:none}
a:hover【鼠标点击 文本修饰为下划线】{text-decoration:underline;}

【第二部分】通用设置
.wp{width:px； height:auto; marin:0 auto; overflow:hidden;}【居中,页面宽度设置，高自动； 边框0 自适应；溢出隐藏】

【第三部分】头部设置
.head 【宽auto自动 高设置 背景图片平铺x】
.ding 【溢出隐藏 高设置 border-top设置】
.logo 【浮动左边 border-top】
.search 【搜索框 浮动右面】
.searich input搜索框 输入【宽设置 高设置 背景图平铺x】
.search button搜索框 按钮{宽设置 高设置 背景图:平铺x；边框1ox 颜色 固定； 边框:圆角矩形5px；颜色 边框:左-10px；位置:相对； z索引1}

【第四部分】导航设置
.nav【设置高】
.nav ul{}
nav ul li【设置浮动 宽设% 文本排列居中 边框左1px 固定 颜色 同右,颜色更改 高更改 外边缘头px】
.nav ul li:first-child{ border-left:none;}【第一 产物 边左没有】
.nav ul li:last-child{border-right:none;}【最后 产物 右边距没有】
.nav ul li a{  font-size:14px; color:#000;}【字体大小 颜色设置】
第二种
.nav{}【同上】
nav ul li【同上】
.nav1 ul li:f【同上】
.nav1 ul li a【字体大小更改 颜色更改 外边距左1px 固定 颜色 外边距1px 固定 颜色更改 显示块元素】display:block;
.nav ul li:first-child【同上】
.nav1 ul li:first-child a【最后 产物 左边距没有】
.nav1 ul li:last-child a【最后 产物 右边距没有】

list-style:none;margin:0px;【取消列表前缀点】

【第五部分】banner图片
.bannet【宽度自动 高设置； 设置背景图 居中；】失效
第二种
.bannet1【宽自动 高设置 设置背景图 背景大小:居中】
第三种
.bannet2【同1】
.banner2 img【宽100%】

【第六部分】中部内容
.main{}
ul li{} 【浮动左或右 宽改 外边距[两个] 边框改】
ul li:last-child{border:none;}【最后孩子 不显示】不让列表内容竖列,横列并取消无序列表符号
img【】宽度能设100%，外边距
a【】交互式设置1.?? rem

di【设置宽度% 外边框px 自适应】

title{}【设置外边框 自适应】



font-size:2rem【为别的电脑做准备】



父标签可以【外补白或内边框 调整高度距离】
ul li【宽% 浮动 外部白 自适应 字体类型】
ul li img【设置浮动 右外部白】
ul li a【字体类型 大小 颜色 行高】
ul li p【字体类型 大小 颜色】

h1~7和span直接设置颜色或字体类型，颜色，大小
footer【宽高自适应 溢出隐藏 内部白10 0；背景色】
文本需要文本对齐


input输入框【宽高设置 背景颜色 边设置实线 颜色； 颜色 轮廓0 外边框设置 内边框左设置】
textarea多行输入框【宽高设置 背景颜色 边设置实线 颜色 颜色 外边框设置 内边框头设置】




margin：0 auto；【居中】

【0=none】
.div{border:1px solid #ccc; border-style:none solid;}
.div{border:1px solid #ccc; border-width:0 1px;}
.div{border-left:solid 1px red;border-right:1px solid red;}
.div{border:1px #ccc solid; border-top:0px; border-bottom:0px;}
.div{border:1px #ccc solid; border-top:none; border-bottom:none;}
字体左边添加横线


 ____________________________
|                           |_______________________________________
|       【html5表】   	    |                                       |
|                           |________________________________|     |
|___________________________|                                |     |
                                                              \   /
                
                                           \ /
                                                                -
积木为我

doctype【文档类型】

index【索引】一带得埃尔斯
enbede【嵌入插件】因背的
object【html4 也插入】偶不见特 实线flash插件的播放
aidio【音频】
video【视频】
canvas【动态图像
source,track【媒体资源】
controls【设置好。显示播放按钮插件】 肯超死
preload【预先载入视频】=none|metadata加载第一帧| auto加载完 
autoplay【立刻播放视频】
loop【重复播放】卢坡
_________________________
form【表单】放热
name【名称】乃木
action【提交页面】比如超链接 在form后
methhd【提交方式】 get和post 在form后
input【选择】因普特
autofocus【鼠标聚焦在input，用户直接输入】
disabled【禁止输入】
value【输入值固定】歪楼
form="register"【挂钩】input后 form加id
register【登记,注册】


label for挂钩【点击前面自动光标移动到输入框】

fieldset分组
type【类型】忒剥 =submit【提交】撒布米特
=reset【重置】瑞赛博
datalist【数据列表】
required【提示用户输入字符】
readonlu【设置文本框只读】
datalist【只读状态】
password【密码】爬死玩的
placeh

radio【单选框】性别 type
checked【默认选】
submit【提交】萨铺米特
file【上传】 accept【文件类型】="image/gif"

select【下拉框列表】是雷乐色特
textarea【多行文本框】带思科日额瑞
output【计算结果】欧特普特 javescript for
multiple【设置多选】

optgroup【进行分组】
option【分组名称】selected【默认选定】
disabled【禁用】
rows【行高】 textarea
cols【列高】 textarea
name:conter【针对】
wrap="saft"

number [input type="num1" id=] 后面[lutput for="num1 num2" name="nane"]  挂钩form iniou="res value = num1.valueAsNumber * num2.valueAsNumber"
Oninput=
res【结果集】
placeholder="" 好惹 input type"text" pattern="^[/d]{2,4}\-[/d]{6,8}$"
^开头 $最后

place地方
holder持有者


meta name="author" content="bnbbs"
author【作者】
content康腾特
descripton【描述】
keywords【关键字】
gennerator【编码工具】
content【人名】

<meta name="Generator" contect="">说明生成工具
meta【分配】设置元数据
follow【康特】
Generator创始
KEYWords
DEscripton【描述】
Author contect="姓名"【作者】
Robots机器人 all|none|index|noindex|follow|nofollow

all【文件和链接都查询】SEO常用
nome【文件,链接不可查询】
follow跟随【链接可查询】
follow【链接可查询】
noindex【文件检索,链接不可以查询】
nofollow【文件不检索,链接可以查询】

valign垂直对齐
top,middle,bottom
middle中间 克雷都
表格
cellpadding【内边距】
cellspacing【外边距】
bgcolor【表格背景颜色】


【表单】input type=""
按钮
radio【发送】
checked默认选中【侧科特】
reset【重置】锐赛特
checkbox多选,方型加输入框
submit提交框
button按钮

type=file 选择框
file【发送】

<details>
  <summary>下拉名称</summary>
下拉内容
</details>

details【详细资料】
summary【总结】

section【部分】
article【文章】
aside【侧边,旁边】

entype【表单编码】



disc实心圆
circle空心圆
square实心矩形


object【物体】熬不解渴


&nabsp;空格
&lt;左尖括号
&gt;右尖括号
&laquo;<<
&raquo;>>



&copy; c商标
&trade;tm商标
&hearts;心符号
&reg; r商标
&quot; ""

select选择
option选项

<select name="" id="" size=3 multiple>
multiple【多个的】劳特跑

© : &copy;” : &quot;
& : &amp;® : &reg;
♠: &spades;
♣: &clubs;
♥: &hearts;
♦: &diams;

语法：<a></a>  ,anchor 缩写(锚)
href链接路径
target目标
_self在当前页面打开 晒负
_blank新标签打开    布兰科

anchor描文本,a的全名
mailto:867258173@qq.com




disc : 实心圆(默认)
circle : 空心圆
square : 实心矩形

<label for="male">用户名</label>
<input type="radio" name="sex" id="male" /


22.label的作用是什么？是怎么用的？
例子1: 点击" 用户名:" 就可以定位光标到输入框
<form>
	<label for="myid "> 用户名:</label>
	<input type="text" id="myid" />
</form>
例子2: 点击" 用户名:" 或按键alt+1, 都可以定位光标到输入框
<form>
<label for="myid" accesskey="1"> 用户名:</label>
<input type="text"  id="myid" tabindex="1" />
</form>
		
female女性的
gender性
male男性的


scroll!important (卷页,重要) 印谱特泰特
返回首页




cursor: pointer;




<a href="" traget="_parent">默认本页面
<a href="" traget="_self">
topmargin 页面上方
leftmargin 页面左面
rightmargin 页面右面
bottommargin页面下面

<hr noshade>
#00ff00 绿色
#ff0000 红色
#ooooff 蓝色
#cccccc 灰色
#FF00FF 紫色
circle 圆环
disk 圆点
square 方块

alt当图片未显示时出现的文字
<input type=iamge>
<form method=?>,
method方法

alink=red正在被点击链接颜色
<cite></cite>斜体
<tt></tt>打印字体

<table frame=box>全部边看
<table frame=above>上面边框
above上面
below下面
lhs左面
rhs右面
vsides左右两边
hsides上下两边
void空的

<table rules=all>
只显示行与行之间的分隔线
rules组

groups隐藏分割线
rows 只显示行与行之间的分隔线
cols 只显示列与列之间的分隔线

<spacer type=" vertical " size=#>
竖直空白高度
<multicol cols=#> ... </multicol>
列的数目
<select multiple> 
多选式选单
创建一个滚动菜单的HTML代码是？
<form></form> 
html语言中，设置围绕表格的边框的宽度的标记是
<table width=# or%> 
能够设置成口令域的是
只有单行文本域

设置围绕表格的边框宽度的HTML代码是？
<table border=#> 


<input type="text" placeholder="">
搜索框点击输入文字，隐藏value字符串

组合表单中的相关元素
<form>
  <fieldset>
    <legend>health information</legend>
    height: <input type="text" />
    weight: <input type="text" />
  </fieldset>
</form>
	【legend】 元素为 fieldset 元素定义标题（caption）。
	【fieldset】 元素可将表单内的相关元素分组。

<fieldset> 标签将表单内容的一部分打包，生成一组相关表单的字段。

当一组表单元素放到 <fieldset> 标签内时，浏览器会以特殊方式来显示它们，它们可能有特殊的边界、3D 效果，或者甚至可创建一个子表单来处理这些元素。









【figure】图解,使用图片说明的hml5新标签
	<figure>
		<img src="" />
	<img src="" />
	</figure>

img下方会有空隙:
	只要加【vertical-align:middle;】垂直居中就好


【html类】
html类

github源代码分享平台


[git]
	git快捷键:
	【psd】查看当前路径
	【ls或dir】显示当前所有文件和文件名
	【Ctrl + Ins】 复制
	【Shift + Ins】 粘贴 
	【git log】 查看日志	

Windows命令	Linux命令	意义
cd e:\xxx	cd /e/xxx	切换到xxx目录
cd	pwd	显示当前目录路径
dir	ls	列出当前目录内容
copy nul xxx.txt	touch xxx.txt	生成名为xxx.txt的空文件
del xxx.txt	rm xxx.txt	删除xxx.txt文件
md xxx	mkdir xxx	建立xxx目录
rd /s xxx	rm -r xxx
删除xxx目录

	2.github-右上角【设置】
	3.点击SSH and GPG keys【SSH和GPG密钥】
	4.点击SSH keys【SSH密钥】右侧New SSH key【新的密钥】
	5.title随便写,key把【id_rsa.pub】文件打开密钥复制进去
	6.点击Add SSH key【添加新的SSH密钥】
	7.git config --global user.name "waecy"
	8.添加自定义电脑名称和邮箱
	git config --global user.name "waecy"
	git config --global user.email "wang867258173@gmail.com"
	git config --global push.default simple

	cd users/
	cd ECY
	cd 1/
	9.更新文件或目录.
	//更新所有文件
	git add .
 
	//更某个文件
	git add 文件名
 
	//更某个目录
	git add 目录名/


	全局添加:
		set PATH=%PATH%;C:\Program Files\Git\bin

 	git add README.md
	git commit -m "提交注释"




　  git init
　　touch README.md
　　git add README.md
　　git commit -m '提交文字'
　　git remote add origin https://github.com/waecysj/learngit.git
　　git push origin master


    git add .
　　git commit -m 'first_commit'

　　git remote add origin https://github.com/waecysj/learngit.git
　　git push origin master
提示出错信息：fatal: remote origin already exists.
解决办法如下：
    1、先输入git remote rm origin
    2、再输入git remote add origin git@github.com:waecysj/learngit.git 就不会报错了！
    3.git push -u origin master
  
    如果【git push 失败 failed to push some refs to git】
	说明github没有这个文件或文件夹,先同步下
    先本地仓库和github代码合并
    git pull --rebase origin master
    再进行推送
    git push -u origin master


	下一次更新,只要简单添加/提交---推送就没问题了
	git add 文件名
	git commit -m '提交文字'
	git push -u origin master
	

	不要用/正下划线,要用\下划线
	github不允许推送空文件夹
【html5】
	//获取标签和绘图上下文
	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');
	【canvas.getContext('2d')】
	Context上下文

	//绘图填充代码
	ctx.fillStyle = 'red';
	【ctx.fillRect(50,50,100,100);】

	fill充满
	//绘图普通矩形,只有边
	ctx.strokeStyle = 'blue';
	【ctx.strokeRect(100,100,100,100);】
	stroke画
	Rect建立

	//绘图普通矩形 -设置宽度
	ctx.lineWidth = 5;
	ctx.strokeStyle = 'blue';
	ctx.strokeRect(150,150,100,100);
	【ctx.lineWidth = 5;】

	//绘图代码
	ctx.strokeStyle = 'red';
	ctx.moveTo(100,100);
	ctx.lineTo(200,200);
	ctx.stroke();
	【moveTo】
	【lineTo】

	//多条线段代码
	ctx.strokeStyle = 'red';
	ctx.moveTo(100,100);
	ctx.lineTo(50,200);
	ctx.lineTo(150,200);
	ctx.lineTo(100,300);
	ctx.stroke();


	//新的概念,多个线段,多个圆组合构成一个图形
	ctx.beginPath();
	ctx.moveTo(100,100);
	ctx.lineTo(50,200);
	ctx.lineTo(100,300);
	ctx.lineTo(150,200);
	ctx.closePath();

	【ctx.beginPath();】
	【beginPath)】 开始 路程
	【closePath()】 关闭 路径


	//绘制
	//ctx.strooke();
	
	圆形
	【ctx.arc(200,200,100,0,Math.PI * 2,0);】
	
	//设置字体
	ctx.font = '60px Arial';

	//显示实心文字
	ctx.fillText('hehe',100,100);

	//显示空心文字
	ctx.strokeText('hehe',100,200);

	图片
	var img =  img = new Image();
	img.src = 'bea.jpg'
	//判断图形是否加载
	img.onload = function () {
		//显示图像
		//参数1:图形对象
		//参数2:x
		//参数3:y
		//参数4:w
		//参数5:h
		ctx.drawImage(img,0,0,240,150);
		ctx.drawImage(img,0,150,240,150);
	}
	【draw】绘画

	//椭圆
	ctx.save();//保存绘图状态
	ctx.scale(1,0.5);
	ctx.beginPath();
	ctx.arc(100,100,100,0,Math.PI * 2,0);
	ctx.closePath();
	ctx.stroke();
	ctx.restore(); //恢复绘图状态

	//绘制圆
	//x 圆心x
	//y 圆形 y
	//r 半径
	//a1 开始角度
	//a2 结束角度
	///option 顺时针/逆时针
	ctx.beginPath();
	ctx.arc(100,300,100,0,Math.PI * 2,0);
	ctx.closePath();
	ctx.stroke();

	//正方形
	ctx.fillRect(20,100,100,100);

	【save()】保存
	【restore()】恢复


	//创建渐变色
	//参数1:第一个点x
	//参数2:第一个点y
	//参数3:第二个点x
	//参数4,第二个点y
	var grd = ctx.createLinearGradient(0,0,0,400);
	【createLinearGradient(X,Y,X2,Y2)】
	//设置开始颜色(0)
	grd.addColorStop(0,'red');
	【addColorStop(个数,位数)】

	//设置开始颜色(1)
	grd.addColorStop(1,'blue');

	ctx.fillStyle = grd;
	ctx.fillRect(0,0,400,300);

	ctx.fillStyle = 'white';
	ctx.font = '50px Arial';
	ctx.fillText('Wait You',100,100)

	//创建放射性渐变
	//6个参数
	//三个参数 圆x,y,r
	//三个参数 圆x,y,r
	var grd = ctx.createRadialGradient(200,200,50,200,200,100);
	//设置开始颜色(0)
	grd.addColorStop(0,'#333');
	grd.addColorStop(0.2,'yellow');
	//设置开始颜色(1)
	grd.addColorStop(1,'#eee');

	ctx.fillStyle = grd;
	ctx.fillRect(0,0,400,300);

	ctx.fillStyle = 'white';
	ctx.font = '50px Arial';
	ctx.fillText('Wait You',100,100)

	【ctx.clearRect(x,y,w,h)】



SVG介绍
	是什么
	HTML5提供一种绘图技术,svg是可缩放的矢量图形标记语言,常常用于描述二维矢量图形

		特点:
			1.和canvs一样都是绘图技术
			2.矢量绘图技术,缩放不失真
			3.使用XML标签描述各个图形
			4.包含常见的各种绘图的API,例如矩形,圆形......

	绘图的各个图形都放在svg中
		标签:【rect】
			必选属性:
			x:
			y
			width
			height

			可选属性:
			fill 填充色
			stroke 边框

	圆使用标签【circle】

			必要属性:
			cx 圆心x
			cy 圆心y
			r 圆半径

			其他属性:
			fill
			stroke
			stroke-width
	椭圆:【ellipse】
			必要属性:
			cx 圆心x
			cy 圆形y
			rx x上半径
			ry y上半径

			其他属性:
			fill
			stroke
			stroke-width

	画直线:【line】
		必要属性:
		x1 起点x
		y1 起点y
		x2 终点x
		y2 终点y
		stroke 线的颜色

		其他属性
		stroke-width 线宽

		stroke-dasharray 设置虚线,两个值(每个线段长度和间隔)

	文本: 【text】
		必要位置:
		x x位置
		y y位置
		标签内放置内容

		其他属性
			fill 文字颜色
			stroke 边框颜色

	折线:【polyline】
		poly 聚
		必要属性:
		points 折线所有的点
			points道岔
			格式 "x1,y1,x2,y2,"
		stroke
		fill = "transparent"

		其他属性
		stroke-width 线宽

	多边形:【polygon】

			必要参数:points
				
			其他参数:
				stroke
				fill
				stroke-width
	图形:【image】

			必要属性:
			x 图形左上角x
			y 图形左上角y
			width 图形宽度
			height 图形高度

	svg提供【path】标签,功能非常强大的标签
			path路线
				M 移动
				L 线
				A 圆
				Q 二次曲线
				C 贝塞尔曲线
				Z 结束路径

		A指令 7个参数
				rx,ry 椭圆的半径大小
				xrotation 椭圆的x轴与水平方向的顺时针夹角
				flag1 -弧线角度,1表示大小,0是小角度
				flag2 时钟方向,1.是顺时针 2是逆时针
				x,y 终点坐标

		M0,100移动扇形的起点
		
	<!--三个函数,旋转,缩放,设置原点/位移-->



	
	用js创建svg内元素,必须使用
	【document.createElementNS(网址,添加元素名)】
	var xmlns = "http://www.w3.org/2000/svg"
	var rect2 = document.createElementNS(xmlns,"rect");

	也可以放在一行内
	var rect2 = document.createElementNS('http://www.w3.org/2000/svg',"rect");
	



	【画遨游logo】
	<svg width="400px" height="400px">
		<!---g表示group,即分组的意思,g添加子标签-->
			<g transform="translate(100,100)"></g>
			<circle cx="100" cy="100" r="100" stroke="#aaa" stroke-width="" fill="lightblue"></circle>
			<circle cx="100" cy="100" r="95" stroke="" stroke-width="" fill="#3b99e3"></circle>
			<rect x="40" y="60" width="120" height="80" stroke="" fill="white" stroke-width="" rx="5" ry="5" transform=""></rect>
			<rect x="77" y="97" width="45" height="45"  stroke="#3b99e3" fill="transparent" stroke-width="20" rx="" ry="" transform=""></rect>
			<path d="M140,60 A20,20 0 0 1 160 80 L160,60 Z" fill="#3b99e3"></path>
	</svg>


	【环形进度条】
		需要与【<input tyoe="range">】共同使用
		自定义的话在【stroke-dasharray="0 628"】添加两个值
		定义变量获取input元素,这里value获取了元素
		var proress = value / 100;
		//根据进度计算圆环中实线和虚线的长度
		var rl = 628 * proress;
		var vl = 628 * (1 - proress);
		var track = document.getElementById('track');
		track.setAttribute('stroke-dasharray',rl + ' ' + vl);


【input相关html5新属性值】
	【时间选择】
		type类型
		【time】时间 需在vakue值自定义时间,格式为【13:07】
		【data】日期 需在vakue值自定义时间,格式为【2017-03-10】
		【datetime-local】日期时间 可在vakue值自定义时间,也可以直接使用onchange(this)在js获取值
				2017-03-10T13:07-
		【mouth】 月份 可在vakue值自定义时间,也可以直接使用onchange(this)在js获取值
				2017-03
		【week】 年份周期 可在vakue值自定义时间,也可以直接使用onchange(this)在js获取值
				2017-W10

	【颜色选择】
		【color】 颜色选择 可使用onchange(this)获取颜色

	【url或email验证】
		必须使用<form action="" method="post">表单和submit提交按钮
		type类型:
		【email】邮箱地址
			格式有@,并且前后有值就正确,否则错误
			PS:检测机制有些低,如果今后需要正确验证,建议大家使用正则来验证
		【url】域名(网址)
			前缀是http://,并且后面有值就正确
			如果http://1 也正确
		PS:检测机制有些低,如果今后需要正确验证,建议大家使用正则来验证
		
	【数字控件】能选择数字,适合购买商品,选择个数
		type类型:
		【number】 可用onchange(this)获取值

	【滑动控件】
		type类型:
		【range】范围 可拖动左右,自身有值,可用onchange(this)获取值,用来改变进度条的值

	属性	描述
	【max】	设置或返回滑块控件的最大值
	【min】	设置或返回滑块控件的最小值
	【step】	设置或返回每次拖动滑块控件时的递增量
	【value】	设置或返回滑块控件的 value 属性值
	【defaultValue】	设置或返回滑块控件的默认值
	【autofocus】	设置或返回滑块控件在页面加载后是否应自动获取焦点


	【输入自动提示】比如搜索栏,搜索关键字,下方自动给出关键字
		必须有<form action="" method="post">表单
		【list】input新属性,且type必须为text
		【datalist】html5新语义标签 两个单词拼在一块,简单说就是【数据列表】
			必须有id,且和list数值相同才行,下面添加【option】选项.在value自定义关键字,当符合关键字时inout下方会自动提示
		

	重点说明下:
		【onchange()】这个事件,是当前元素更改后显示,一般可以用来当value值改变时,会进行触发事件
	onchange 事件发生时执行的 JavaScript 代码。当一个 select、input、或 textarea 多行文本域失去焦点或更改value值时触发的事件。 


 	使用video标签播放一个简单视频
			重要属性:
			【src】表示视频地址
			【width】视频宽度
			【height】视频高度
			【controls】是否显示控制按钮
				controls控制机构
	video src="h5.mp4" width="400px" controls=""></video>

		常用属性:
			【src】视频文件路径
			【poster】视频封面
				poster海报
			【preload】是否预加载
			【autoplay】是否自动播放
				play比赛
			【loop】循环播放
				loop圈,环
			【controls】设置是否显示控制条
			【width】播放区域宽度
			【height】播放区域高度

			js操作属性:
			【currentTime】当前时间
			【startTime】 开始时间
			【duration】持续时间(视频长度)
				duration持续
			【paused】是否暂停
			【played】返回已播放区域
			【ended】是否结束
			【autoplay】是否自动播放
			【loop】是否循环播放
			【play】播放
			【pasue()】 暂停

			js事件
			【loadstart】开始加载
			【error】加载错误
			【play】play()触发播放
			【pause】pause()暂停
			【playing】播放
			【ended】播放结束
			【timeupdate】播放时间改变
			【volumechange】音量改变
				volume音量
				change改变

	【当前时间 / 总长度】 获取当前位置
	【e.setoffX / 宽度 /视频总时间】

		【data-index】标签自定义属性,data-xxx 从0开始


		全屏方法:
		       【requestFullScreen()】
		chrome谷歌,opera火狐:【webkitRequestFullScreen()】
		firefox火狐:【mozRequestRequestFullScreen()】
		IE微软:【msRequestFullscreen()】
		※☞ 千万要记住()是执行,在if判断是否有这个函数时,要去掉()
			比如:if(requestFullScreen){ ☜判断是否有这个函数
				requestFullScreen();☜有的话执行
			}

		request 需要
		full 满的
		screen 屏幕

	※☞Chrome不支持拖动进度条功能,firefox支持,测试时用火狐测试,或用兼容全浏览器的插件【plyr-master】,【VideoJS】进行设置
	
		视频全屏
		//设置点击全屏,兼容各大浏览器
		function repeat(tag){
			if(myPlayer.webkitRequestFullScreen){
				myPlayer.webkitRequestFullScreen()
			} else if(myPlayer.msRequestFullscreen){
				myPlayer.msRequestFullscreen()
			} else if(myPlayer.mozRequestFullScreen){
				myPlayer.mozRequestFullScreen()
			} else{
				myPlayer.requestFullscreen()
			}
		}


HTML5 视频和音频的 DOM 参考手册
	HTML5 DOM 为 <audio> 和 <video> 元素提供了方法、属性和事件。
这些方法、属性和事件允许您使用 JavaScript 来操作 <audio> 和 <video> 元素。
HTML5 Audio/Video 方法
	方法 描述 
	【addTextTrack()】 向音频/视频添加新的文本轨道 
	【canPlayType()】 检测浏览器是否能播放指定的音频/视频类型 
	【load()】 重新加载音频/视频元素 
	【play()】 开始播放音频/视频 
	【pause()】 暂停当前播放的音频/视频 
HTML5 Audio/Video 属性
	属性 		描述 
	【audioTracks】 返回表示可用音轨的 AudioTrackList 对象 
	【autoplay】 设置或返回是否在加载完成后随即播放音频/视频 
	【buffered】 返回表示音频/视频已缓冲部分的 TimeRanges 对象 
	【controller】 返回表示音频/视频当前媒体控制器的 MediaController 对象 
	【controls】 设置或返回音频/视频是否显示控件（比如播放/暂停等） 
	黑字【crossOrigin】 设置或返回音频/视频的 CORS 设置 
	【currentSrc】 返回当前音频/视频的 URL 
	【currentTime】 设置或返回音频/视频中的当前播放位置（以秒计） 
	【defaultMuted】 设置或返回音频/视频默认是否静音
		DOM defaultMuted 属性
		true 指示音频/视频默认是静音的。 
		false 默认。指示音频/视频默认不是静音的。 
	【defaultPlaybackRate】 设置或返回音频/视频的默认播放速度 
	【duration】 返回当前音频/视频的长度（以秒计） 
	【ended 返回音频/视频的播放是否已结束 
	【error】 返回表示音频/视频错误状态的 MediaError 对象 
	【loop】 设置或返回音频/视频是否应在结束时重新播放 
	【mediaGroup】 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） 
	【muted】 设置或返回音频/视频是否静音
		true 指示应该关闭音频/视频的声音
		false 默认。指示应该打开音频/视频的声音
	【networkState】 返回音频/视频的当前网络状态 
	【paused】 设置或返回音频/视频是否暂停
	【playbackRate】 设置或返回音频/视频播放的速度
	【played】 返回表示音频/视频已播放部分的 TimeRanges 对象 
	【preload】 设置或返回音频/视频是否应该在页面加载后进行加载 
	【readyState】 返回音频/视频当前的就绪状态 
	【seekable】 返回表示音频/视频可寻址部分的 TimeRanges 对象 
	【seeking】 返回用户是否正在音频/视频中进行查找 
	【src】 设置或返回音频/视频元素的当前来源 
	【startDate】 返回表示当前时间偏移的 Date 对象 
	【textTracks】 返回表示可用文本轨道的 TextTrackList 对象 
	【videoTracks】 返回表示可用视频轨道的 VideoTrackList 对象 
	【volume】 设置或返回音频/视频的音量 
HTML5 Audio/Video 事件
	事件 		描述 
	黑字【abort】 当音频/视频的加载已放弃时 
	【canplay】 当浏览器可以播放音频/视频时 
	【canplaythrough】 当浏览器可在不因缓冲而停顿的情况下进行播放时 
	【durationchange】 当音频/视频的时长已更改时 
	黑字【emptied】 当目前的播放列表为空时 
	黑字【ended】 当目前的播放列表已结束时 
	黑字【error】 当在音频/视频加载期间发生错误时 
	【loadeddata】 当浏览器已加载音频/视频的当前帧时 
	【loadedmetadata】 当浏览器已加载音频/视频的元数据时
	【loadstart】 当浏览器开始查找音频/视频时 
	黑字【pause】 当音频/视频已暂停时 
	黑字【play】 当音频/视频已开始或不再暂停时 
	黑字【playing】 当音频/视频在已因缓冲而暂停或停止后已就绪时 
	【progress】 当浏览器正在下载音频/视频时 
	黑字【ratechange】 当音频/视频的播放速度已更改时 
	黑字【seeked】 当用户已移动/跳跃到音频/视频中的新位置时 
	黑字【seeking】 当用户开始移动/跳跃到音频/视频中的新位置时 
	黑字【stalled】 当浏览器尝试获取媒体数据，但数据不可用时 
	黑字【suspend】 当浏览器刻意不获取媒体数据时 
	黑字【timeupdate】 当目前的播放位置已更改时 
	黑字【volumechange】 当音量已更改时 
	黑字【waiting】 当视频由于需要缓冲下一帧而停止 



想让html5的video和audio标签能在所有浏览器上工作，必须在页面的head内部加入以下一行代码：
 	<script src="html5media.min.js"></script>  
然后你可以使用以下代码加入一段视频：
 	<video src="video.mp4" width="320" height="200" controls preload></video> 
你还可以使用以下代码加入一段音频：
 	<audio src="audio.mp3" controls preload></audio>  

##9.本地存储(localStorage)
	学习什么what:
		h5提供两个用于存储的技术,存储持久化数据

		持久化数据/网页关闭之后依然存在,下次程序启动能获取的程序

		两个知识点:
			【localStorage】(主要,用的多)
			【localStorage.removeItem('isLogin')】移除数据
				Item条款	
			【sessionStorage】

			Storage 贮存
			session 会议,一段时间
		为什么学习why:
			解决了两个问题
				(1)页面关闭需要存储数据,下次打开使用
				(2)两个界面传值的问题

		如何学习how:
			案例1: 基本使用,基本语法
			案例2: 存储值,下次打开显示
			案例3: 界面1存储值,界面2获取值

		细节问题:
		数据存哪儿?
			存到浏览器的本地存储区了,浏览器关了,下次打开还能用
		如何查看数据?
			打开浏览器的控制器,一般在resource或者application中
			A浏览器存的,不能再B中使用
		只能存字符串吗?
			是的,只能存字符串,其他可以转化JSON字符串,存进去
		如何程序健壮性?
			使用之前检查window.localStorage是否存在
			使用localStorage某个值,最好也检查这个是否定义

		localStorage和window.localStorage有什么区别
			没区别




	原生js设置类
	//【classList】类的列表
	支持浏览器 chrome(8.0) IE(10.0) 火狐(3.6) safari(5.1) opera(11.5)

	//常用4个函数
	【add(class)】添加一个类,相当于jQuery的【addClass()】方法
	【remover(class)】移除一个类,相当于jQuery的【removeClass()】方法
	【toggle(class)】切换(原有有,移除,原来没有,添加) 相当于jQuery的【toggleClass()】方法
	【contains(class)】 判断class是否存在,是的话true,否则false,相当于jQuery的【hasClass()】方法
	button.classList.add('button-oprater');
	显示有
	

	必须先获取元素,使用document.getElementsByClassName('btn')[0]或document.querySelector('.btn')
html5不常用标签:
	【<area>】地区 →在指定图片点击跳转
        <img src="clip.png" border="0" usemap="#planetmap" alt="Planets" />
        <map name="planetmap" id="planetmap">
          <area shape="circle" coords="180,139,14" href ="venus.html" alt="Venus" />
          <area shape="circle" coords="129,161,10" href ="mercur.html" alt="Mercury" />
          <area shape="rect" coords="0,0,110,260" href ="sun.html" alt="Sun" />
        </map>
	【<base>】根据 →放在<head>内,让页面所有链接都以新标签打开
		<base target="_blank" />
	【<col>】 标签为表格中一个或多个列定义属性值。如需对全部列应用样式，<col> 标签很有用，这样就不需要对各个单元和各行重复应用样式了。
	【<command>】命令 →没有浏览器支持 <command> 标签。只有 Internet Explorer 9 （更早或更晚的版本都不支持）支持 <command> 标签。
	command 元素表示用户能够调用的命令。<command> 标签可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键
	<menu>
		<command onclick="alert('Hello World')">
		Click Me!</command>
	</menu>
	【<embed>】把..嵌入 <embed> 标签定义嵌入的内容，比如插件。比如swf
	【<keygen>】<keygen> 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。
		所有主流浏览器都支持 <keygen> 标签，除了 Internet Explorer 和 Safari。
	【<param>】param 元素允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 <object> 或者 <applet> 标签提供参数。
	【<source>】 根源 →标签为媒介元素（比如 <video> 和 <audio>）定义媒介资源,
<source> 标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择。
`	<audio controls>
		<source src="../i/horse.ogg" type="audio/ogg">
		<source src="../i/horse.mp3" type="audio/mpeg">
	</audio>
	【<track>】轨道
		kind方法
		srclang语言差不多
		label标记
	播放带有字幕的视频：
	<video width="320" height="240" controls="controls">
  		<source src="forrest_gump.mp4" type="video/mp4" />
  		<source src="forrest_gump.ogg" type="video/ogg" />
  		<track kind="subtitles" src="subs_chi.srt" srclang="zh" label="Chinese">
  		<track kind="subtitles" src="subs_eng.srt" srclang="en" label="English">
	</video>
	Internet Explorer 10, Chrome 以及 Opera 支持 <track> 标签。
	【<wbr>】





















	【transition:all 0.2s;】过渡
	【transition: stroke-dasharray 0.5s;】过渡
		
	→【width: calc((100% - 20px) / 3);】
	clac() 函数是css3提供计算值函数,
		 使用100% - 10px - 10px
		 注意: 操作符 + - 两边有空格


[html5][h5]【html5】【h5】


_____________________________
|                           |_______________________________________
|  【div+CSS3层叠样式表】   |                                      |
|                           |________________________________|     |
|___________________________|                                |     |
                                                              \   /
                                                               \ /
                                                                -
	header【标头】害的
	sublime【撒步澜特】台式的3
	style【样式】丝带楼

语义化标签
	section部分
	article文章
	aside侧边栏
  	 <head></head>:网页头部 【不需要包含h1~h6】div也不需要添加标题
  	<nav></nav>:网页导航 【需要包含h1~h6符合规范】
  	<section></section>:小节 【需要包含h1~h6符合规范】
 	 <article></article>:文章内容，网页具体内容
  	<aside></aside>:侧边栏
 	 <footer></footer>:网页底部

背景图[CSS背景][CSS背景定位][背景定位]
	repeat【平铺】瑞皮特
	backgtound【背景】班可固瑞的
	attachment【附件】他吃蒙特
	fixed【固定】肺腑的
	size【尺寸】晒子

	[背景定位]

        /*背景定位图片,必须要给父级添加,子级添加无效*/
        background-color:red;
        background-image:url(xing.jpg);
        background-repeat:no-repeat;


        /*上居左*/
        /*background-position:top left;*/
        /*上居中*/
        /*background-position:top center;*/
        /*上居右*/

        /*右居中*/
        /*background-position:right center;*/

        /*右居下*/
        /*background-position:right bottom;*/

        /*下居中*/
        /*background-position:bottom center;*/

        /*左居下*/
        /*background-position:left bottom;*/
        /*左居中*/
        /*background-position:left center;*/

        /*============百分比调位置  ←最常用,调整小图标==============*/
         /*左面调整*/
        /*background-position:20% center;*/
        /*用px调整*/
        background-position:20px center;

        /*右面调整*/
        /*background-position:90% center;*/

         /*最后用背景大小调整位置*/
        -webkit-background-size:10% 10%;
        background-size:10% 10%;

	【top center】
	【top right】
	【center left】
	【center center】
	【center right】
	【bottom left】
	【bottom center】
	【bottom right】
	如果您仅规定了一个关键词，那么第二个值将是"center"。
	默认值：0% 0%。

	x% y%	
	第一个值是水平位置，第二个值是垂直位置。
	左上角是 0% 0%。右下角是 100% 100%。

	xpos ypos	
	第一个值是水平位置，第二个值是垂直位置。
	左上角是 0 0。单位是像素 (0px 0px) 或任何其他的 CSS 单位。
	如果您仅规定了一个值，另一个值将是50%。
	您可以混合使用 % 和 position 值。

边框
	border【边框】报的热
	top【套破】
	left【左】莱福特
	right【右】软特 
	bottom【下】奥特
	width【宽】万特
	solid【实线】扫里的 配合边框使用
	dashed【虚边】搭设的
	dotted【点线】刀提特 IE6不认
	radows【半径】瑞都是  
	transparent【透明】串次怕瑞特
	outline【轮廓】

	nome【没】nei磨

	clear: left;【清除浮动】
	伪类【必须加前缀】
	ul li:first-child【开头元素】
	ul li:last-child【最后 元素】
	ul li:only-child【唯一 子元素使用】
	div > p:only-of-type【选择指定类型元素】div有p+span 下面有div>p+p
	of【关于】
	ul > li nth-child(2)【第几个 元素】
	nth-last-child【从后往前数第几个元素】
	div > p:nth-of-type(2)【特定子元素第二个】
	div > p:nth-lest-of-type(2)【特定子元素第二个】
	input:enabled{}【启用】
	input:disabled{}【禁用】
	<input type="checkbox" checked>
	checkbox【检验栏】
	checked【方格复选框】
	input:checked{display:nome;}【点击显示隐藏】
	input:invalid【无效 输入验证合法显示】email 应剥乐特
	input-required{}【必须填】瑞卡耶特
	input-optional{}【可选】奥克斯no
		a:link{}【未访问a设置】比如颜色,大小
	a.visited{}【已访问a设置】外赛黛得
	active【激活 点下去不搜】阿克特服
	input:focus【集中 光标移到框内】三课时
	focus【鼠标按下后更改】


	action【行动】阿克斯
	method【方法】满分特
	value【给】维拉有
	get【得到】甘特
	textarea【多行文本输入框】穿克斯追呀
	rows【行】骨软我司
	cols【列】康市
	content【内容】康泰特
	a:not([href*="baidu"]){};设置百度其他a元素
	not【不】no特
	p.empty{display:none;} 空元素设置,隐藏
	empty【空的】艾默贼


	letter-spacing【字符间距】文字间距

	color【颜色】卡楼
	RGB
	red【红】软的
	green【绿】顾瑞
	blue【蓝】布鲁
	yellow【黄】耶喽【大概】
	pink【粉红】喷可
	azure【天蓝色】阿热
	black【黑色】布兰科
	white【白色】外特
	gray【灰色】桂瑞
	color:rgba(0,128,128,0,0.5)最后透明意思
	color:hsl(120,100%,30%) H色相,S饱和度,L明度
	hsla也能加透明度



	【font-style:normal】【正常】no惹目
	【font-style:italic】【斜体字】因他利特
	【font-style:oblique】
	oblique 倾斜的
	normal去除默认em倾斜
	overline【上划线】
	【text-indent】文本 缩进
	【padding:inherit】内边距 继承[内边距继承]

	【background:inherit】[背景继承]
	【text-decoration:underline】昂斗来 [下划线][CSS下划线]
	【text-decoration::line-through】行穿过 [删除线][CSS删除线]


section【部分】
提示:
	1.背景图片可以 先颜色 图片 样式 是否平铺
	2.设置浮动左右后,只能设置外部白浮动位置【设置上下左右距离】margin-top，right，bottom，left



[CSS选择器][CSS3选择器]
	[]元素名选择器.可以用其他的[type="password"]

	[元素名和符号:=""] href="" 【^】开头httm:// 【$】刀了尾cn 【~】模糊查询baidu |可匹配-比如语言en-u

	【input type="text"】选择框，也可以体会text为password
	p b{}【匹配下级，不匹配p内包含b儿子,孙子级】
	ul > li{}【匹配儿级，孙级不适用】
	p + b{}【相邻兄弟元素】
	p ~ b{}【匹配不相领兄弟元素】

	::flirst-line{} 佛斯特【块级元素首行设置】.前面加选择器，可限定条件，比如p
	::flirst-letter雷特 英文首字设置。英文首字也有效
删掉块级元素，span会被当做body有效

	a::before{content:'点击';}【前插入】
	a::after{content:'搜索';} 文本前插入
	a::before{content:'请进';}文本后插入

	::selection{}【选择 选中文本后变设置】史莱克神
	chrome,IE支持,火狐不支持

        CSS3代码记录
        install安装
        
        address
        
        ftamaset
        
        scrolling
        
        sider
        
        Recipes
        
        @import url()ie4,5支持
        
        flot权限
        
        justify左右
        
        
        scroll滚动条位置 overflow
        
        letter-spacing字符间距
        
        word-spacing单词间距
        
        text—indent首行缩进
        
        Keyframes 动画效果
        
        
        背景图attachment:foxed
        
        panrent链接到父级，首页
        
        search搜索
        
        select选择
        
        option选择权置
        
        
        attachment他吃蒙特 虚线
        
        start从ol几个序号统计 死他热特
        
        &lt;figure&gt;&lt;figcaption&gt;使用插图
        
        colspan td横向合并
        
        rowspan th增加后合并 竖行合并
        
        capttion表格标题
        
        colgroup设置列
        
        hgroup包含群组
        
        section文档主题
        
        article添加独立成篇文档
        
        aside注释，侧栏
        
        iframe src nome=in嵌入另一个文档，target"in"
        
        embed 嵌入插件
        
        canvas动态图像
        
        source,track媒体资源
        
        
        autofocus鼠标自动到输入框，用户直接输入
        
        disabed禁止输入
        
        maxlength 设置最大输入字符
        autofocus获取焦点
        placeholder 输入时提示
        submi提交 撒不米特
        reset重置瑞赛博
        limportant强制优先级
        ::first-line伪元素选择器 块集 佛寺特
        letter累特&nbsp; 字母
        only唯一
        nth第几个
        
        
        input checkbox检验栏
        input checked方格复选框
        input—required必填
        required必填
        
        optional可选
        
        duration
        
        filter:alpha(opaciy=
        <a href="tel:100">
            100
        </a>
        )
        
        filter过滤器
        alpha开端，最初
        opaciy不透明度
        
        zoom 等级缩放,可触发IE6使用
        haslayout ie显示机构，和bfc很像 害死来特
        vertical-align:top 外籍q&nbsp; 垂直
        opacity不透明度 偶破谁听
        filter:alpha(opacity=50)
        
        过滤 第一 不透明度
        &lt;！--[if ie]--&gt;
        我是ie
        &lt;！--[endif]--&gt;
        &nbsp;
        
        在input添加required
        input:valid有效
        input:invalid不合法
        input:required；必须要填设置
        input:optional可选择的，也就是不验证的
        a:not([href *="baidu"])选中百度之外的a标签
        p:empty{display:none}将空标签隐藏，去除换行和空白
        input:checked
        input:default复选框默认选中选中隐藏
        :lang 和属性选择器相同，但这个得自定义语言
        :tarset通过url#描点定位才能显示，标签设置id
        
        
        WebSocket插座
        WebWorker工人
        
        
        
        display:-webkit-box
        -webkit-box-orient:vertical
        -webkit-line-clamp:3
        
        

	
【hover】
	a:link {}	 /* 未访问的链接 */
	a:visited {}	/* 已访问的链接 */
	a:hover {}	 /* 鼠标移动到链接上 */
	a:active {} /* 选定的链接 */


	overflow:heidden【溢隐藏出】溢出裁剪
	auto【溢出出现滚动条】
	scroll【预留滚动条】

清除浮动
	clear【清除】
	none  :  默认值。允许两边都可以有浮动对象 
	left  :  不允许左边有浮动对象 
	right  :  不允许右边有浮动对象 
	both  :  不允许有浮动对象 

父级:after【在..之后】插入内容【啊福特】{centent:""; display:block; clear:both;}


position位置
	【position:relative】相对【软擂忒tei】相对自身
	【position:absolut】e绝对【奥不斯雷特】绝对定位相对父级或以上的relative,如果父级有则相对父级,没的话一直往上寻找

	【position:static】正常[定位正常][恢复定位][定位恢复]

	has layout【有布局】焊丝莱特
	zoom【变焦】
	vertical-align：top【垂直的】外籍Q

	gligh【水平居中】
	valigh【垂直居中】

W3C规范:结构 样式 行为

IE6 BUG

	1.盒模型必须要精确，否则IE低版本显示不同效果

	2.需要浮动把宽度撑开。div里有块级属性，内嵌h1~h6,块级属性设置了浮动，子级也必须设置浮动，	否则显示不正常

	3.在IE6,7下需浮动排同一行 margin-left:100px; 设置块级移动位置,IE会显示空隙，必须所有元素都加	float:left;

	4.p元素内不能添加块级元素 解决方法:displa:inrline；转换内联属性

	5.ie默认最低高度19px，解决方法:overflow：hidden;

	6.IE下border：1px dotted red;点线不支持，改成虚线  IE下不支持1px点线 解决方法:切背景平铺backgtound:url() x-repeat;

	7.在IE下父级有边框的时候，子元素的margin会失效,margin会穿透父级。overflow：hidden;或zoom:1或解决
PS:父级元素添加border:1px; 在IE下没用

大部分兼容性的has layout属性，尽量去触发has layou属性，减少IE兼容问题

	8.IE6下双边距情况，块元素有横向margin的值的时候,横向margin扩大2倍，使用displa:inrline；转换内联属性解决

	9.在IE 6,7下,li本身无浮动,li里面内容有浮动,li下会产生一个间隙。需要给父级添加浮动或添加vertical-align：top

	11.在IE6最小高度和li间隙问题共存时,给li加浮动
PS：vertical-align：top不好使

	12.IE6 下margin-bouuom失效， 解决方法:父级加宽度和overflow:hidden，子级转换内联元素
PS：父级用浮动不生效
	【12】.IE6当一行子级元素宽度之和和父级宽度相差3像素或子级元素没满行的时候，最后一行的margin-bouuom会失效
	宽度超出3像素塌陷bug，div宽度没满行

	13.IE 6下文字溢出BUG,子元素的宽度和父级的宽度如果相差小于3px的时候，两个浮动元素之间有注释或内联，就会出现文字溢出，内联元素越多,溢出越多box1设置400px
	right设置宽度399px会出现,改成397px就好了
解决方法:
	用块元素标签，把注释和内联元素包起来就好了

	<div class="box">
	<div class="left"></div>
	<!-- 这是注释-->
	<span></span>
	<div class="right">这里是文字</div>
	</div>

14.IE6下，当浮动和定位和兄弟关系的时候，绝对定位会失效，
解决方法:
	不让浮动元素和定位是兄弟关闭，让div或其他标签把a包起来
	ul下自己直接a标签使用绝对定位absolute,IE6不显示，需要新建div，包含a标签

15.在IE6,7下子级元素有相对定位position:relative，父级overflow:auto包不住子级元素
解决方法:
	给父级也加相对定位position:relative

16.在IE6下，如果绝对定位的父级宽高是奇数时,子级元素right和bottom值会有1px的偏差

17.fixed固定在I6不生效
	opacity【不透明度】 哦破谁听 IE6,7，8不认
	opacity:0.5;
	filter:alpha(opacity=50);
解决方法:必须写以上两行命令
	filter【过滤器】
	alpha【第



18.在IE6，7下 输入型的表单控件上下会有1px的间隙。
解决方法：给input加浮动

19.解决IE6图片不透明状态
http://www.dillerdesign.com/experiment/DD_belatedPNG/
使用调用外部DD_roundies_0.0.2a.js
* DD_roundies.addRule('.your .example img');

20.注释通过条件在IE6，7，8显示
	<!--[if ie]>
	我是IE
	<![endif]-->

	<!--[if ie 6]>
	我是IE6
	<!endif>

	<!--{if ie 7]>
	我是IE7
	<!endif>


【条件注释语句】


21.CSS海克 css hack
	+background:yellow;←【IE5,6,7支持】
	*background:black;←【IE5,6,7支持】
	_background:yellow;←【IE 5,6】ie7以下能识别,不包括IE7
	background:black #;←【IE5支持】
	background:black \9;←【IE9以下显示】除了IE9
	background:black\9;←【IE5,6,7,8,9】IE9及以下显示,包括IE9,以上10,11没测试
	background:black \0;←【支持IE8,9,应该也支持10,没测试】
	background:black\0;←【支持IE5,8】
	background:black\9\0;←【支持IE8,9】10没测试

PS:background:black \9\0;←【支持IE5,8】也就是优先执行\0 →错误写法

background:black!important;←【强制显示】
      background:black!important;【IE7,8,9支持,IE7以下不支持】加空格没影响
      background:red;

      :root div【IE9支持CSS样式】以上版本没测试,理论支持
//================================================================
	.test{ 
		color:#000000; /* FF,OP支持 */ 
		color:#0000FF\9; /* 所有IE浏览器(ie6+)支持 ；但是IE8不能识别“*”和“_”的		css hack；所以我们可以这样写hack */ 	
		[color:#000000;color:#00FF00; /* SF,CH支持 */ 
		*color:#FFFF00; /* IE7支持 */ 
		_color:#FF0000; /* IE6支持 */ 
	}

color:#0000FF\9; ;/*ie6,ie7,ie8*/ 
*color:#FFFF00;/*ie7*/ 
_color:#FF0000;/*ie6*/
来区分IE的各个版本。
说明：在标准模式中 

“-″减号是IE6专有的hack 
“\9″ IE6/IE7/IE8/IE9/IE10都生效 
“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack 
“\9\0″ 只对IE9/IE10生效，是IE9/10的hack

body:nth-of-type(1) .CH{
&nbsp;&nbsp; color: #FF0000;/* 这是专门针对Chrome和Safari的CSS hack */
}
*html *前缀只对IE6生效 
*+html *+前缀只对IE7生效 
@media screen\9{...}只对IE6/7生效 
@media \0screen {body { background: red; }}只对IE8有效 
@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效 
@media screen\0 {body { background: green; }} 只对IE8/9/10有效 
@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效 
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效 
//================================================================
	background:yellow\9; ie 10之前的IE浏览器解析的代码
	+或*表达ie7包括7之前的IE浏览器
	_表示ie6包括6之前的ie浏览器
	*+为 IE7支持

	选择器 /* FireFox */
	*html 选择器  /* ie6 fixed */
	*+html 选择器  * ie7 fixed, 注意顺序 */

	注意:
	*+html 对IE7的HACK 必须保证HTML顶部有如下声明：

	1.高度默认19px；设置overflow：hidden；解决
	2.块级元素有间隙问题，给父级li加float:left;
	3.左右两边有间距时，转换displa:inrline；转换内联属性
	
==================================================================================
	gradient【倾斜度】贵进尺
	linear 直线
	action【活动】单科盛
	method【方法】


	transform: translate(50px,100px);
	transform【改变】
	translate【转化位置】想x,y
 把元素从左侧移动 50 像素，从顶端移动 100 像素。

	-webkit-transform: rotate(-90deg);
	rotate【旋转】
ps：必须加前缀限定浏览器条件，否则无法生效,后面必须加deg,否则也无法生效

	-webkit-【chrome和safari浏览器】
	-moz-【firefix浏览器】
	-o-【opera浏览器】
	-ms-【ie版本】

	Triangle【三角形】
	Parallelogram【平行四边形】
	Rectangle【矩形】
	Exact square【正方形】

	mymove【调用子程序】是个函数(程序)的名字,就是调用子程序。
	infinite【无限的】
	form【形状】
	from【从...向】

【CSS动画效果】[css动画][css3动画]
position:relative;
animation:mymove 3s infinite;
		}

@keyframes mymove{
		  from{left:-50px;}
		  to{left:500px;}
		  to{top:300px;}
}


	【transition: all 1s 0s;】 过渡
 	【animation-name:scolebing;】 动画名
     	【animation-duration:4s;】 动画持续时间
      	【animation-delay: 1s;】 动画延迟时间
      	【animation-iteration-count:2;】动画执行次数



【注意事项】
	1.动画div必须加绝对定位,
	2.且from和to只能进行二步操作，向进行多个操作，需要使用%分比,top和left来配合3.mvmove不是固定选择器，可通过自定义设置,但必须首字母英文才行。

	ol全名:Order List 奥德 雷斯特

	overflow:hidden;
	overflow:visible;
	overflow:scroll;

	dotted点线

	box-shadow:20px 20px 10px 0px #999 inset;
	box-shadow:0 0 10px #999; 设置四周颜色

	pink粉色
	border-image-source图片路径
	slice图片边框向内偏移

	box-sizing:border-box;

	#00f 全名#0000ff 海蓝
	#0ff 全名#00ffff我喜欢 浅蓝绿，水绿色【aqua
	#002A35不错的蓝色(0,42,53)
	lavender淡紫色
	


	cover扩大背景图像,使用背景图完全覆盖背景区域,直到碰到最后一个边缘次才停止,buttom和right
	contain碰到第一个边缘停止 碰到button停止

	background-attachment:scroll;定义背景图片随滚动轴的移动方式
	scroll | fixed | inherit

	background-images:contain;
	:background-position:x y;


-193px
-169px

padding不要超过16px

clip【裁剪】
	background-clip:border-box;
	background-clip:padding-box
	background-clip:content-box;

	no-repeat
	background-origin:border-box;
	background-origin:padding-box;
	background-origin:content-box;

	linear-gradient线性渐变
	gradient-gradient径向渐变

overline上划线
下划线
	首行文本缩进text-indent;


【单行设置省略号】←需设置以下三个属性
	【overflow:hidden;】
	【white-space:nowrap;】 不换行没省略号
	【text-overflow:ellipsis;】 省略号
	
三个加起来就是超出加省略号

【限制多行字数换行】[多行省略号] ←必须添加浏览器前缀,只支持中文,给要省略多行的标签,设置overflow:hidden;来隐藏多显示出的部分
	【overflow:hidden;】
	【display:-webkit-box;】
	【-webkit-box-orient:vertical;】
	【-webkit-line-clamp:3;】

	orient标定方向
	vertical垂直的
	clamp紧紧抓住,夹住
	PS:只支持中文,不支持英文和数字
【支持英文和数字,限制多行字数-换行】
	【word-break:break-all;】因为浏览器不支持解析英文和数字代码换行,需要添加这个属性才能支持英文和数字多行超出,添加省略号
	单词-间隔:下落-全部【断行】

	完整版就是:
	overflow:hidden;
	display:-webkit-box;
	-webkit-box-orient:vertical;
	-webkit-line-clamp:3;
	word-break:break-all;

17:29 2016/12/9【浏览器支持解析代码换行】
单词-包袱:下落-单词
	linear infinite
	before
	letter-spacing:-2px;        /* 字母间距 */  

	nth最大极限
	p:nth-of-type(odd){};
	odd奇数
	p:nth-of-type(even){};
	even偶数

	p:nth-of-type(3n+0){};
	3的n次方

	ovefkiw:visible;溢出可见

	border-width:
	border:color:
	border:style:solid/dashed/dotted/double

	solid 实线
	dashed 虚线
	dotted 点状线
	double 双线

	box-shadow:blur;模糊
	box-shadow:spread;展开
	box-shadow:inset;插入

设置透明度
	opacity:0.6; 不透明度
	filter:alpha(opacity=40); 过滤




LOGO优先使用img标签,方便后台修改

边框合并【border-coll】

clear清除浮动

vertical-align:top|middle|bottom;
只有行内框和表格能用,可以设置value值

	【cursor:pointer;】
	【cursor】光标
	【crosshaif】加号
	【wait:】等待
	【help:?】问法
	【text: |】
	【move: 】十符号
阴影给5或10;

	visibility:hidden 可见 隐藏
	repeat重复
	round 铺满
	stretch 拉伸

1、边框合并	属性:border-collapse	取值:		separate : 分离边框(默认)		collapse : 合并边框

图片300kb以下
CSS sprite【面试题】CSS精灵 把很多小图放一张大图,减少http请求次数,提高网站加载速度，提高用户体验

重复渐变

    	transform: translateX(-4px);
    	transition: transform .4s, -webkit-transform .4s, -moz-transform .4s;

opacity: 1; filter:alpha(opacity=100);

	[IE透明度]
	opacity: 0.5;
	-moz-opacity: 0.5;
	-khtml-opacity: 0.5;
	filter: alpha(Opacity=50);

	transition【过渡】
	transform【转换】
	duration【持续时间】

	translate【位移】

	transition:transform 2s;
	【transition:transform】
	transition-duration：2s;规定时间多少秒
	【transitionduration】
hover内
	tranform:translate(-5px,-5px);
和


transform【全名transform：function】
	属性值:
	旋转：rotate()
	位移：translate()
	缩放：scale()


	fonnt-weight:lighter定义更粗的字体
	inherit 规定应该从父元素继承字体的粗细


需要在body声明字体font-size:62.5%或0.675em ，这样1.2em等于12px;
	1.em是相对单位
	2.em具有继承性，若父级设置了1.2em，那么子级只能使用1em
	1em等于16px,em具有继承性，支持IE6下的字体缩放
	IE下设置body为62.5%字体2em，也就是12px会稍大一点，只要更改63%就能正常显示

rem实在html里根目录声明font-size:62.5%
PS:rem不支持IE8及以下版本


	display:inline-blockl[inline-blockl]有基线
	baseline: 默认值，盒子的基线与父级盒的基线对齐。如果这个盒子没有基线，就让这个盒子的 margin 底边缘和父级盒基线对齐。
	【middlen】: 将盒子的垂直中心点与父级盒子基线往上 X 一半高度的位置对齐。
	【subn】： 降低盒子的基线到父级盒合适的下标位置。
	【supern】： 提高盒子的基线到父级盒合适的上标位置。
	【text-topn】: 将盒子的顶部（top）与父级盒子内容区域的顶部对齐。
	【text-bottomn】: 将盒子的底部（bottom）与父级盒子内容区域的底部对齐。
	【%n】: 将盒子相对基线位置上移或下移多少位置（百分比的值时相对于行高 line-height ），” 0% “时位置与设置 baseline 一致。
数值： 将盒子相对基线位置上移或下移多少位置。0px 时位置与设置 baseline 一致。
	【topn】: 将盒子的顶部与行框 line box 的顶端对齐（行框的顶部就是这一行行内框的最高点）。
	【bottomn】: 将盒子的底端与 行框 line box 的底端对齐（行框的底端就是这一行行内框的最低点）。


	解决办法：
	1. 设置父元素 line-height 为0，基线和底线就会重合，间距就会消失。
	2.图片设置 vertical-aligh 为 bottom ，底线对齐。
	3.图片设置 display 为block，因为块元素没有vertical-align属性，所以不存在基线对齐。

上面三种办法中，1和3会影响父元素内的文字状态，所以第二种办法比较好。



	→【去除inline-block元素间间距的N种方法】
	二、方法之移除空格
元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以：

	<div class="space">
    		<a href="##">
   		 惆怅</a><a href="##">
   		 淡定</a><a href="##">
   		 热血</a>
	</div>
或者是：

	<div class="space">
    		<a href="##">惆怅</a
    		><a href="##">淡定</a
    		><a href="##">热血</a>
	</div>
或者是借助HTML注释：
	<div class="space">
    		<a href="##">惆怅</a><!--
   		 --><a href="##">淡定</a><!--
    		--><a href="##">热血</a>
	</div>

	四、让闭合标签吃胶囊
如下处理：
	<div class="space">
    		<a href="##">惆怅
    		<a href="##">淡定
    		<a href="##">热血</a>
	</div>
注意，为了向下兼容IE6/IE7等喝蒙牛长大的浏览器，最后一个列表的标签的结束（闭合）标签不能丢。

	在HTML5中，我们直接：

	<div class="space">
    		<a href="##">惆怅
    		<a href="##">淡定
    		<a href="##">热血
	</div>
好吧，虽然感觉上有点怪怪的，但是，这是OK的。

八、其他成品方法
	下面展示的是YUI 3 CSS Grids 使用letter-spacing和word-spacing去除格栅单元见间隔方法（注意，其针对的是block水平的元素，因此对IE8-浏览器做了hack处理）：

	.yui3-g {
    		letter-spacing: -0.31em; /* webkit */
    		*letter-spacing: normal; /* IE < 8 重置 */
    		word-spacing: -0.43em; /* IE < 8 && gecko */
	}		

	.yui3-u {
    		display: inline-block;
    		zoom: 1; *display: inline; /* IE < 8: 伪造 inline-block */
   		 letter-spacing: normal;
    		word-spacing: normal;
    		vertical-align: top;
	}
以下是一个名叫RayM的人提供的方法：

	li {
    		display:inline-block;
    		background: orange;
    		padding:10px;
    		word-spacing:0;
   	 }
	ul {
    		width:100%;
    		display:table;  /* 调教webkit*/
    		word-spacing:-1em;
	}

.nav li { *display:inline;}
也就是上面一系列CSS方法的组组合合。


CSS多列布局
	-webkit-columens:auto 4;
	-webkit-columens:120px 4;
	-webkit-columens-width:200px;没设置列数,但设置了宽度.那么会自动设置列数
	-webkit-columens-count:3; 列数
	-webkit-columens-gap:3 列间距
	-webkit-columens-rule:1px dashed red; 分割线
	-webkit-columens-span:all;设置大标题h1`h6在三列居中
columns栏


display:-wbkit-box;
	-webkit-box-orient:wvrtical;默认
	-webkit-box-orient:inline-axis;
	-webkit-box-orient:block-axis;转化块集,独占一行
	-webkit-box-direction:reverse;逆序排列
	-webkit-box-pack:end;设置父级div宽度100%,默认从宽度右侧排列
	-webkit-box-pack:centerr;从中间排列
	box-pack:justify;只支持-webkit-,等分

	-webkit- box-align:stretch;默认空白区域填充
	-webkit- box-align:start;清除第几排额外空间
	-webkit- box-align:end;以底部对齐.也清除第几排额外空间
	-webkit- box-align:end;以垂直居中对齐,清除额外空间
	-webkit- box-align:baseline;以基线对齐,默认开头



流媒体布局
	p:nth-child(1){
		-webkit-box-fiex:1;
	}
	p:nth-child(2){
		-webkit-box-fiex:3;
	}
	p:nth-child(3){
		-webkit-box-fiex:1;
	}
	也就是1代表20%,3代表60%,3代表20%,加起来就是100%;
	
	流媒体布局调整位置
	-webkit-box-ordinal-group:2;
ps:必须在每一个排版里设置它是第几列,然后进行调换,否则可能不正常调换


IE10伸缩布局使用
	display:-ms-flexbox;支持IE10
	-ms-flex-direction:row; 默认 从左往右
	-ms-flex-direction:column;设置从上到下排列
	-ms-flex-direction:reverse;逆序排列 
	-ms-flex-direction:row-reverse;从右往左
	-ms-flex-wrap:wrap;无法容纳自动换行
	-ms-flex-wrap:no-wrap;不换行


::selection被选中文本背景色

	perspective:50000px;透视
	transform-style:preserve-3d;【改变 样式 保持-3D】
	transform-origin:10% 10%; 起源

过渡属性,过渡时间,速度效果,延迟
	inherit继承

时间=距离/速度


哪些浏览器用的是-webkit-前缀，哪些是-o-前缀，哪些是-moz-前缀
-webkit-:chrome,safari;-o-:Opera;-moz-:firefox

浏览器内核
	Google Chrome谷歌、Opera欧朋、Safari、Microsoft IE、Mozilla Firefox火狐

.IE: trident内核
  Firefox：【gecko内核】
  Safari：【webkit内核】
  Opera：以前是presto内核】，Opera现已改用Google Chrome的【Blink内核】
  Chrome：【Blink】(基于webkit，Google与Opera Software共同开发)


	[CSS3属性][CSS3新属性][CSS属性][CSS新属性]
	【word-break:break-all】【自动换行】[自动换行]
	【text-transform: uppercase】把英文字母变成大写
	【text-transform: lowercase】把英文字母变成小写


	       
        在input添加【require】
        【input:valid】有效
        【input:invalid】不合法
        【input:required】必须要填设置
        【input:optional】可选择的，也就是不验证的
        【a:not([href *="baidu"])】选中百度之外的a标签
        【p:empty{display:none}】将空标签隐藏，去除换行和空白
        【input:checked】
        【input:default】复选框默认选中选中隐藏
        【:lang】和属性选择器相同,但这个得自定义语言
        【:tarset】通过url#描点定位才能显示，标签设置id






【使用百分比，只有宽度能设置，高度自适应】
【CSS类】【CSS】[CSS3][CSS]
==================================================================================
<div action="" method="get">
<input name="" type="text" value="姓名"><br/>

当前设置：HomeSite
菜单命令
【命令】—【Emmet】--【Numbers】--【Expand Abbreviation】

<textarea cols="" rows="">请输入您的留言内容</textarea>

</form>
形状


=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
	ul.nav>li>a.n_$*6                                                              =
                                                                               =
	ul.nav>li>a.英文参数名$*6                                                      =
	div*4
	【Ctrl+E】默认DW使用
                                                                               =
	【div】标签名后自动添加选择器
	【.】点后输入div class参数名
	【#】id选择器
	【$按顺序排序】
	【>】和【<】往下级扩充
	【*】星号添加多少个
	【a.】后添加class名
                                                                               =
        【html:4t】
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
        【html:4s】
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
	【html:xt】
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
	【html:xs】
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
	【html:xxs】
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
	【html:5】
	<!doctype html>






	当前设置：HomeSite
	菜单命令
	【命令】—【Emmet】--【Numbers】--【Expand Abbreviation】
                                                                               =
=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
	ul.nav>li>a.n_$*6
	ul.nav>li>a.英文参数名$*6
	div*4
	h${内容h$}*6 大括号是内容,内容里也可以写快捷键
	{双标签内容}
	[属性设置]
	 h$*6>{这是$级标题}设置标题
	div.box.div 这是链式设置,同时给多个div1设置box和div两个class,也可以使用.和#结合,同时设置有id和class的元素

	a*4+span*2 要设置两个a标签,里面要有两个span标签,要给前者也设置要生成多少个

	【Ctrl+E】默认DW使用，改成【Cltl+/】方便使用
	顺便把html注释改成【Ctrl+Alt+/】因为大多数操作都在CSS,这个其次
	把CSS改成【Ctrl+Shift+/】第二方便使用 打太多代码需要注释用

	【div】标签名后自动添加选择器
	【.】点后输入div class参数名
		如果要添加多个class,后面一直加点就好,比如:div.box.test 返回的结果就是<div class="box test"></div>
	【#】id选择器
	【$按顺序排序】
	【>】和【<】往下级扩充
	【*】星号添加多少个
	【a.】后添加class名

	在【{】选择参数+【Ctrl+/】自动配对:;可重复使用，非常方便,提高效率
	但不能配对直接是一大缺点{}
	参数名头缩写【-】参数名头缩写
	直接跳过：；

CSS
	在sublime text是可以CSS自动添加{}选择器
	虽然不能直接插入图片，但会提示图片名和常用值，【很方便】
	部分高宽自动匹配参数【非常方便】
	虽不能选择符，不断自动匹配，但支持模糊省略查找，自动匹配选择器【超方便】

Ctrl+Shift+P呼出界面

Tab【生成代码格式】
	Ctrl+Z【撤销上一步操作】
	Ctrl+Y【还原撤销格式】
	Ctrl+K+L【转换小写】
	Ctrl+/【行注释】
	Shift+"【自动添加""双引号】
	Ctrl+Shift+Alt【段注释】
	Alt+Shift+1（1-4）【分列】
	Alt+Shift+5【网格4个】
	Alt+Shift+8（9)【行2,3个】
	Ctrl+F【搜索】
	Ctrl+H【搜索+替换】
	Ctrl+P【选择所在行】
	Ctrl+K+B【显示隐藏左侧栏】
	Ctrl+Shift+home【选中光标前所有代码】
	Ctrl+Shift+end【选中光标后所有代码】
	Ctrl+Shift+D【复制当前行】
	【F7】打开自带控制台
	
	Shift+Alt+2【边栏共几个】
	Tag插件格式化html
	Ctrl+Alt+F【格式化源代码】

	Ctrl+K+L【改成小写】注意js,jquery不能转小写，一些首字母必须大写，否则无法运行
	Ctrl+K+U[【改成大写】
<style 或<script 再按Tab键,或自动生成type类型内容

	inout：类型，直接输出





选中代码
	Ctrl+D选中全部相似代码
	Ctrl+H全部替换代码



选中代码:
	Ctrl+D
支持自动保存 
首选项(N)-设置-用户【用户设置】
{
	"bold_folder_labels": true,
	"color_scheme": "Packages/User/SublimeLinter/Cobalt (SL).tmTheme",
	"font_size": 11,
	"highlight_line": true,
	"ignored_packages":
	[
		"Vintage"
	],
	"save_on_focus_lost": true,
	"scroll_past_end": true,
	"show_encoding": true,
	"show_full_path": true,
	"show_line_endings": true,
	"tab_size": 2,
	"translate_tabs_to_spaces": true,
	"trim_trailing_white_space_on_save": true
}

	Ctrl+Shift+上下【移动光标行】
	Ctrl+Shift+D【复制光标所在行】


	div.header+ding+wp>div.logo>div.pheone>ul*2>li*3>a+img


开启输入jq,选择下方提示出来的set Syntax:jQuery
	instell安装


css类型文件中
	【!+Tab键】,自动输出【!important】
	【@+Tab键】自动输出
	@font-face {
  		font-family:;
  		src:url();
		}
	【Shift+Tab键】自动取消缩进


	【更改默认Tab代码】重要,可自定义修改
	sublime主目录\Data\Packages\Emmet\emmet\snippets.json
	文件,更改文件快捷代码默认设置,使用Ctrl+F来搜索更改

	"script":"<script type=\"text/javascript\" />",
	"style":"<style type=\"text/css\" />",
	"style:src": "<style src=\"\" />",
	修改后面代码格式
	=后面必须用\转义


修改后删掉【sublime主目录\Data\Packages\User】文件夹再打开sublime
【Text】是菜单栏汉化


	lg(left; reg );【渐变快捷键】
	tf:r【旋转快捷键】


选中代码，默认ctrl+alt+a进行alignment格式化源码


	Emmet：流行的Html编写插件，是zed code升级版包含css编写
	SublimeCodeIntel：代码提示
	JsFormat：js代码提示 
	CSSComb：给CSS属性进行排序的格式化插件
	Alignment：对齐你的代码 
	Trmmer：会自动删除这些不必要的空格
	DocBlockr：对代码建立文档
	Snippets：快速书写代码 
	Soda：一个流行的主题，包含代码着色、标签、图标  
	Sublime Prefixr：CSS3 私有前缀自动补全插件
	JS Format：一个JS代码格式化插件。 
	SublimeEnhancements：边栏菜单带来扩充的功能
	SideBarEnhancements：一个左边栏增强
	SublimeLinter：行内高亮语法
	FileDiffs：两个不同文件的差异  
	jQuery：jQuery插件
	ColorPicker：调色板 
	SASS Build：CSS的预处理器 
	FTPSync：免费和易用的FTP工具
	Git：git的支持插件

更改默认打开浏览器快捷键
【首选项(N)----按键绑定-用户】进行更改

[
  //chrome浏览器
  { "keys": ["ctrl+b"], "command": "side_bar_files_open_with", "args": { "paths": [], "application": "E:/新建文件夹/Google【谷歌浏览器 (Google Chrome) 35.0.1916.114 绿色免安装版+便携版 - 精品绿色便携软件】Chrome_35.0.1916.114_PortableSoft/Google/Chrome/Application/chrome.exe", "extensions": ".*" } },

  {
    //火狐浏览器
  "keys": ["f12"], "command": "side_bar_files_open_with", "args": { "paths": [], "application": "E:/新建文件夹/pcxFirefox-46.0-zhCN-vc2013-x86-sse2-betterpgo-160430/firefox/firefox.exe", "extensions": ".*" } },

   {
    //360安全浏览器
  "keys": ["ctrl+f12"], "command": "side_bar_files_open_with", "args": { "paths": [], "application": "E:/新建文件夹/360安全浏览器/360se7.0.0.180/360se.exe", "extensions": ".*" } },
 ]


======================================================
【插件】
 "AlignTab",
        "All Autocomplete",
        "AutoFileName",
        "BracketHighlighter",
        "BufferScroll",
        "Color Highlighter",
        "ConvertToUTF8",
        "CSScomb",
        "CTags",
        "DocBlockr",
        "EditorConfig",
        "Emmet",
        "EncodingHelper",
        "HTML-CSS-JS Prettify",
        "JSHint Gutter",
        "LESS",
        "LiveStyle",
        "Markdown Preview",
        "Modific",
        "OmniMarkupPreviewer",
        "Package Control",
        "SideBarEnhancements",
        "SublimeCodeIntel",
        "Sublimerge Pro",
        "TabsExtra",
        "Terminal",
        "Theme - Phoenix",
        "Vue Syntax Highlight"
======================================================
【sublime】
=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
【EditPlus设置】埃迪特 普拉斯

	EditPlus主目录/template.html默认修改html打开代码断行

	htmlFormatte格式化html

	cscript /nologo "E:\新建文件夹\濡以沫o\编程\EditPlus v3.70/htmlFormatter.js"

	1.【工具-配置自定义工具】
	2.【首选项-工具-自定义工具】
	3.【组名（Z）】可自定义你想修改的名称
	4.点击【添加工具（J）>>——程序（C）】
	5.【菜单文本（W）】:就是名称,也可自定义,没影响
	6.【命令（M）】cscript /nologo "路径/htmlFormatter.js"
	7.动作(D)【筛选文本（替换内容）】
	8.确定

js调试
	1.javascript调试
	2.cmd /c
	3.cscript "绝对路径\jslint.js" < "$(FileName)"
	4.$(FileDir)
	5.捕获控制台输出

	【jsFormat】js排版
	【html2js】转html为js输出
	【htmlFormatte】格式化html
	【emmet_epp.js】自动补齐代码
	【Ctrl+1格式化源码】
	ps:不支持UTF-8格式文件格式化,否则GB2321,ANSI编码格式化中文乱码
	使用Unicode格式


	shift+alt选中当前行,同时点击↑↓切换当前行位置


	相同点一样,Tab缩进

	Ctrl+鼠标滚轮 增大或缩小




配置sublime编译js
打开sublime，选择菜单 Tools --> Build System --> new Build System...
中文版的话是 工具 --> 编译系统 --> 新建编译系统...


将下面的内容粘贴进去：

{
    "cmd": ["node", "$file"],
    "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)",
    "working_dir": "${file_path}",
    "selector": "source.js",
    "shell": true,
    "encoding": "utf-8",
    "windows": {
        "cmd": ["node", "$file"]
    },
    "linux": {
        "cmd": ["killall node; node", "$file"]
    }
}



接着保存为 javascript.sublime-build，保存位置默认即可。
第三步：测试
接下来新建一个demo.js文件，随便写点js代码按快捷键Ctrl+B或者F7测试一下：
sublime text 3 配置编译js环境（Windows）

下面有输出结果了，成功了~是不是有点小激动呢？这样就能在直接在sublime里调试js代码了。

=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
【HBuilder设置】[hbuilder]A 吃 biou 得
	【注意只能英文键盘模式，才能显示联想提示功能,中文状态下,可能部分会无法显示联想功能】
	Ctr+R默认打开charome默认第一个浏览器
	Ctrl + Shif t P 默认打开右侧内带Web浏览器设置,按1次不行,按2次或多下就好了.再按1次关闭
	Ctrl+/注释,js单行注释
	Ctrl+Shift+/ 选中后多行注释
	Ctrl+Shift+【+】是放大字体
	再Ctrl+【-】是缩小字体
	光标在当前行Ctrl+C复制再Ctrl+V粘贴当前行
	Ctrl+Enter回车键 直接所在行回车下一行空行,并跳转到下一行光标【无关当前所在行位置】
	Ctrl+Shift+Enter回车 直接所在行回车上一行空行,并跳转到上一行光标【无关当前所在行位置】

	Ctrl+↑向上移动当前行代码
	Ctrl+↓向下移动当年行代码
	
	Shift + Alt + P 查看代码提示,在标签内,提示属性,在html提供标签


	点击左侧文件名F2，重命名
	Shift+Enter回车\n转义换行,用在console.log和alert内
	
	html中s按回车直接<script></script>双标签
	ale按2直接输出alert();
	par按4自动输出parseInt
	pro回车直接输出promot
		按6直接输出prompt();
	con按2直接输出console，再输入.l回车，直接输出.log();

	if按3直接if(){}
	if按4直接if(){}else{}
	el按5直接输出else
	for按4直接for(){}
	switch按2直接代码块
	
	选中js代码，直接Ctrl + '或Ctrl + "完成被选内容注释

	va 按3直接输出var
	   按4直接输出var a=[];
	doc按1直接输出document，输入wr按1直接输出write;
	set按3直接输出setTimeout()
	选中替换内容【Ctrl + Shift + D】，会选中多个相同内容,然后进行Ctrl + V替换
	fun按3直接输出function function_name () {};
	


	快捷键
		按dg回车就是document.getElementById("")
		按dq回车就是document.querySelectorAll("");
		按dt回车就是date
		按dw回车就是document.write("");
		按dc按2就是document.createElement("")
		按dl按2就是$("")
		    按3就是$("#")
		    按4就是$(".")
		按al5就是alert();


	在CSS中,老被自动提示代码输入数字影响
解决方法:
	只要单词匹配加【_】下划线匹配就好
	比如输入=【f_l】就得到float: left;
		输入=【o_h】就得到overflow: hidden;
	

格式化代码
	Alt+E编辑 再Ctrl+Shift+F整理代码格式

【工具-选项-HBuider-编辑器】编辑器行为 选择【启动自动换行(需要编辑器,重新启动)】
	PS:设置样式时,不能有打开文件.必须关闭

【工具-选项-HBuider-工作空间】切换快捷键方案 选择【HBuider】选择运行至行

Library class/type就是【CSS属性名{}里面:前面设置】
	Tag attribute就是【lang,class,type设置】
	Number就是px前数值设置
	Keyword就是px,deg,for,i括号设置
	Comment就是注释

左侧点击文件名【F2】重命名
注意:不能加:冒号,否则重命名失败




工具(T)-选项(P)-Emmet-Snippets--新建(N)
	名称(N):写你自定义【Tab】的名称,
	描述(D):写这是什么功能
	模式(P):写你要Tab代码块

PS:只能用于htnl代码块,不能用于style和script内的css和js代码.

要想tab不出现多余的缩进,直接把要添加代码块在html内选中,使用【Shift+Tab】缩进到最前面,再把缩紧的代码复制到【模式(P)】内,这么一来下次缩进,就会在你光标所在位置,进行添加代码块,且不会出现多缩紧的情况发生


	clog回车console.log
	rtrue回车return true
	rfalse回车return fasle

→→→→→【从hbuilder左侧栏复制文件,一定要注意【Shidt + delete】永久删除,或直接移动,可能会导致文件被误删,导致之前做的功亏一篑.
	2017/4/7 4:29犯了大错误,导致上午做的【简约-项目文档项目-豆瓣爱搜索】全完了,以后一定要注意,新建项目文件夹再保存,更保险起见,在文件夹里做完复制一份,或压缩一份以防万一】
	在此起誓:这是第一次也是最后一次犯得重大错误.


	【在CSS中使用快捷键】:
	→※注:可以用【$】美元符,【%】百分号,【_】下划线,【@,!】分割字符
		比如c_ => color: #000;
		    o_h = overflow:hidden;
		    f_l

【hb】【hbuilder】[hb][hbuilder]
=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
【sublime颜色调配】
#002240

前景色 #CCCCCC 204 204 204
背景#002240 RGB 0 34 64


【html】
默认<!DOCTYPE html1>元素名
#87FFFF 135 255 255
还有个蓝很好102 217 239



线高亮,也就是选中代码当年行背景
#001629 0 22 41
选择背景色#86543A 134 86 57


插入符,也就是光标移上去颜色
#D0D4D7 208 212 215

class类与ID显示#3AD900 58 217 0


注释 #0088FF 0 136 255
【CSS属性名】
CSS属性名{}里面:前面设置】#9DF382 157 243 130


PX和rgba颜色 #FF9D00 255 157 0
rgba括号里颜色和200数值颜色 #EDF080 237 240 128


【js】
function颜色 #FFD163 255 209 99



【sublime类】[sublime类]
=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
【Emwditor类】
Alt选中多行,再按Alt+N键给纯文本文件每行前端加上自动编号

=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
【WebStrrm设置】
	【Alt+1】打开侧边栏
	【Ctrl+Shift+F10】打开自带控制台




 ___________________________
|                           |
| Javascript【加不四亏特】  |_______________________________________
| jquery【结酷瑞】          |                                      |
| Ajax【阿贾克斯】          |________________________________|     |
|___________________________|                                |     |
                                                              \    /
                                                               \_ /
                                                                
ECMAScript-262
简称ES


js最难:动画/算法/面向对象

1.核心(ECMAscrot) 语法
2.文档对象模型(DOM)倒摸
3.浏览器对象模型(BOM)报摸
                 
ECMAScript是宿主环境之一,不但支持web,还支持ActionScript,script等
组成部分为语法,类型,语句，关键字,保留字,操作符,对象等。
                                                                -
Netscape网景继承人Mozilla【莫雷拉】

firefox添加插件firebug 1.73


工具-附加插件
IETestar【IE模拟器】爱一 坦克特
chrome谷歌浏览器javescript控制台Ctrl+Shift+J


英文常用字体Arial字体
font: 12px/19px Arial, Helvetica, sans-serif;
推荐使用【sans-serif】

GB2312


区分大小写:text和Text是两种不同的标识符。<br>

标识符组成开头:a（字母）,_,和$<br>不支持数字开头

其他组成：a（字母）,_,和$,数字<br>

不能把关键字，保留字,true,false,null作为标识符<br>

100 数字字面量 <br>

'中文 字符串字面量<br>

false 布尔值字面量 true <br>

/js/gi 正则表达式字面量 <br>

null 对象 <br>

｛x:1,y:2｝对象字面量

[1,2,3,4,5] 数值字面量表达式

var【声明变量】


关键字:是程序中已经开始使用的字符
比如
ECMAScript-262关键字

	break
	case
	catch
	continue
	default
	delete
	do
	else
	finally
	for
	function
	if
	in
	instanceof
	new
	retum
	switch
	this
	throw
	try
	typeof
	var
	void
	while
	with

保留字
	abstract
	boolean
	bute
	char
	class
	const
	debugger
	double
	enum
	export
	extends
	final
	float
	goto
	implements
	import
	int
	interface
	long
	native
	package
	private
	protected
	public
	short
	static
	super
	synchronized
	throws
	transient
	volatile

	var【操作符】也是个关键字 中文叫【声明】或【定义】
		定义常量的关键字:【const】,定义变量的关键字:var
	undefined【未定义】昂迪凡得

	box变量名是标识符

	ps:换行后面可以不添加;分号,也能够执行语句
	ps:var后变量可自定义名，和class,id类名相同

	age【使】

	console控制台
	.的
	console.();
	
	arrow function
	这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多:
	function(i){ return i + 1; } //ES5
	(i) => i + 1 //ES6
	简直是简单的不像话对吧...
	如果方程比较复杂，则需要用{}把代码包起来：

	function(x, y) { 
    	x++;
   	 y--;
    	return x + y;
	}
	(x, y) => {x++; y--; return x+y}

	【ES6语法】
	【class】, 【extends】, 【super】
这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承...你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？

有了ES6我们不再烦恼！

ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。

class Animal {
    constructor(){
        this.type = 'animal'
    }
    says(say){
        console.log(this.type + ' says ' + say)
    }
}

let animal = new Animal()
animal.says('hello') //animal says hello

class Cat extends Animal {
    constructor(){
        super()
        this.type = 'cat'
    }
}

let cat = new Cat()
cat.says('hello') //cat says hello
上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。

Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。

super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。

ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。


	【class】
	【() =>】指向的是对象里的()函数体
class Animal {
    constructor(){
        this.type = 'animal'
    }
    says(say){
        setTimeout( () => {
            console.log(this.type + ' says ' + say)
        }, 1000)
    }
}
 var animal = new Animal()
 animal.says('hi')  //animal says hi

JAVA里System.out.println();

	alert【呃软特】
	charset 编码
	defer 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。大多数浏览器不支持，很少用
	language 蓝固瑞特
	type【台坡】类型

	window.alert('窗口的提示,警告');

【转义字符】
	\n 在提示框内输入,换行
	\t tab设置
	\r 换行，相当于一个回车
	\f 女符号字符
	\' 单引号字符
	\"双引号

测试f和t效果相同，字体变模糊
\t有兼容问题，测试IE5-8和firefox正常显示

\b退格
src:source(资源) js文件所在的路径
引入外部的js文件

	window.prompt(); 带有文本框窗口的提示

	alert(window.prompt('请输入名字：'));当点击确定时返回结果

	cofirm【确认按钮】肯少日
	点击确认true【真】肉
	点击取消false【假】放市

	document【文档】
	write【写】

【document.write('内容')】; //往网页中写内容
【能添加单个html和css行内样式表，不支持换行输入和多个标签使用
document.writeln()换行输出  已测试无效,可能是以前有效

头个"或'可换行，结尾不能
PS:嵌套字符串，外部使用单引号，内部使用双引号可运行，相反也行。

【选择变量不用加引号，字符串或特殊字符使用引号括起来】
	var a,b,c=""; 定义多个变量 不建议使用

驼峰命名法
第一个单词首字母小写，接下来单词首字母大写
	idCard:身份证
	productNum:产品数量

简单数据类型(基本数据类型)
	【Number】数字类型 乃播
	【String】字符串类型
	【Boolean】布尔类型 布林
	【undefined】变量未初始化 安迪凡的
	【null】 空类型 耐

复杂数据类型（引用数据类型）
	Object【对象】（引用）
	Array【数据】

整型数据
浮点型数据(小数)

布尔类型
	只有两个值true(初)和false(报是)
	真和假

.的
if如果
else否则
&&或者

	peter渐渐枯竭,减少



	NaN:全名(not a number)【不是一个整数】na

判断是否是数字:isNaN(x):is not a number【若x不是一个数字,那么返回true,若x是一个数字,那么返回false】

	infinity 无限大 var a=1/0; 除数不能为0

	total【总金额】图都
	money【收款金额】马蒂
	change【找零】橙汁

    var a=12;
      var b=15;
      var c=a+b;
      var d="aaa";
      var d=d+a;  //拼接运算可以根据表达式,等号变量左右顺序,来改变输出的值顺序
 		/*拼接运算可以根据表达式,等号变量左右顺序,来改变输出的值顺序*/
     console.log(c);
     console.log(d);
	==【恒等】全等
	!=【不等于】!不

	&&【有假则为假】 【逻辑与】(短路与)

	注意:若是表达式1为假,那么就不会再判断表达式2
	||逻辑或【有真则为真】(短路或)

	!逻辑非 (!相反)(短路非)



	parseInt(变量名/4)【帕西特】转化为整数,系统通过的功能,舍弃小数位  
将数字字符串或小数转化为整数

 JAVE 
	a instanceof 类型

	math.floor();

	alert(typeof new Object()); //可以直接使用字面量

	var box3=new Object();【返回object对象】
	function box4(){};【返回function函数】

运算符:?运算符,三目运算符


取余两种方法:
	一种使用系统自带功能parseInt(要除数/被除数);
	另一种数学算法(要除数-要除数%被除数取余)/被除数



递增运算a++,变量++自增1运算
递减运算a--,变量--自减1运算

	a++先用后加
	++a先加后用
	var b=a++【先赋值给变量b,然后a加1】
	var b=++a【先自增1,然后再使用】

【三位数计算】num % 10 + ((num - num % 10) / 10) % 10 + (num - (num % 100)) / 100
var b = (a - a % 1000) / 1000 + (a % 1000 - (a % 1000) % 100) / 100 + ((a % 1000) % 100 - ((a % 1000)% 100) %10) / 10 + a % 10;

【四位数计算】
(a - a % 1000) / 1000 + (a % 1000 - (a % 1000) % 100) / 100 + ((a % 1000) % 100 - ((a % 1000)% 100) %10) / 10 + a % 10; 

prompt【输入框】可以在后面添加第二个参数,prompt('11','22'),默认在输入框添加22,也可以在后面添加数字
	1234(123-1234%1000)

千位计算(a-a%1000)/1000
	1234-1234%1000=1000
	1000除法1000等于1

百位计算:(a%1000-(a%1000)%100)/100
	1234%1000=234
	(1234%1000)%100=34
	234-34=200%100
最终得到2;

十位计算:((a%1000)%100-((a%1000)%100)%10)/10
	1234%1000=234;
	234%100=34;

	1234%1000%100%10=4;
	34-4=30;
	30%10=3;

个位计算:a%10;
	1234%10=4;

?号判断只能添加一步,不能添加两步骤
	比如:a >  b ? c : d;

简单百分比计算:
  var ge=a%10;
  var shi=parseInt(a%100/10);
  var bai=parseInt(a/100%10);
  var qian=parseInt(a/1000);

Math.random();产生0(包含)-1的随机运算

	if双分枝
	if多分枝结构
	只要有一个执行,之后的不会被执行

	单分支if(){}如果...那么
	双分支if(){};else{}; 如果...那么...否则...;


isNaN认为空串和null是数字
当点击取消时,返回null


(a.trim() =="")修剪
	空格


选择嵌套

switch(变量){
		case "1":
		console.log('星期1');
		break;

		default;
		break;
}

	switch【开关】 是瑞特
	case【情况】 忒特
	break【打破】退出switch结构 布雷克
	default【未履行】 默认 dei放特

	case中的数据类型要和变量的相同


	如果不加break,就会出现case穿透情况发生.
}

	switch只能用于整型变量和字符串

三个数比较输出最大值,两个判断合并
	var max = a>b ? (a>c ? a : c) :(b>c ? b :c);
不是语法型BUG,而是业务型BUG

ASCII码
	字符串比较,使用ASCII码,每一个字符都跟一个数字对应
	通过一个字母一个字母的比较(内部会转换数字比较)
	"112" > "9" :false
	"112" > "111" :true
	"abc" == "bcc" :false

	a=97
	b=98

	BE[C-10,C+10]
	C-10 <= B <= C+10
	E=属于

	(身高-108)*2 = 体重 
	以10斤浮动来测量

	1.如果输入身高208
	2.那么根据公式,减去108乘2等于200;
	3.接下来根据浮动来计算,
 	 200-10=190
 	 200+10=210
	得到体重范围在190-210之间.
4.那么在输入体重,必须在在190-210之间方为正常,否则的话就是不正常

	Math.abs('绝对值');

作用域:不确切的说法 (编程时遵循),在哪儿定义在哪使用

	******
	*****
	****
	***
	**
	*
	1......6;
	2......5;
	3......4;
	4......3;
	5......2;
	6......1;
	line=n num=(总行数+1)-当前行
	

for循环
	表达式1:用于变量的初始化
	表达式2: 循环条件(满足什么条件,执行循环体中的代码)
	表达式3:循环条件中变量的增量

___________________正三角形_______________________

* 	line = 1 	num = 1
***	line = 2 	num = 3
*****	line = 3	num = 5
*******	line = 4	num = 7
	line = n	num = 2 * n - 1	

空格规律
	* 	line = 1 	num = 3
       ***	line = 2 	num = 2
      *****	line = 3	num = 1
     *******	line = 4	num = 0
		line = n	num = 总行数line - 当前行i
_________________倒三角形_______________________
*******		line = 1	num = 7
*****		line = 2	num = 5
***		line = 3	num = 3
*		line = 4	num = 1
		line = n	num = 2	* (总行数line - 当前行i) + 1

*******		line = 1	num = 0
 *****		line = 2	num = 1
  ***		line = 3	num = 2
   *		line = 4	num = 3
		line = n	num = 总行数line + 当前行i


var a = 10;
   for (var i = 1; i <= a; i++) {
      for(var k = 1 ; k <= a - i ; k++){
         document.write('&nbsp;');
      }
     for (var j = 0; j <  i * 2 - 1; j++) {
       document.write(" *");

     }
     document.write('<br />');
   }
document.write('===================================<br />');
 var b = 10;
  for (var i = b; i > 0; i--) {
      for(var k = 1 ; k <= a - i ; k++){
         document.write('&nbsp;');
      }
     for (var j = 0; j <  i * 2 - 1; j++) {
       document.write("*");

     }
    document.write('<br />');
  }


第二步
      j<=i是递增
      j<=j-1+1是递减

document.write();
	不用添加结束标签,浏览器会自动识别加结束标签识别

阶乘
	1*2*3*4*5得到最终结果

素数(就是质数)是这样的整数，它除了能表示为它自己和1的乘积以外，不能表示为任何其它两个整数的乘积。例如，15=3*5，所以15不是素数；又如，12=6*2=4*3,，所以12也不是素数。另一方面，13除了等于13*1以 
外，不能表示为其它任何两个整数的乘积，所以13是一个素数。

质数 不能被任何数整除 
	2 2 = 2



	for(①;②;④){
		③
	}
	①>②>③>④....>②>③>④......=②


	while:当...时候 【维尔】
语法:
	while(条件){
		//循环体	
	}

	while先循环再添加,表达式顺序不能更改
	for是先添加再循环,i++添加可以更改前后顺序

	var i =1; //1
	do{
	console.log(i); //2
	i++;  //3
}	while(i<1); //4


	跟while循环的不同,do-while先执行一次,然后判断,while循环先判断再执行
	do-while循环可以更改

	Break
	在swith提出swith结构
	用与退出循环结构
	do{
		var ret = prompt('请输入您的成绩');
			console.log(ret);		
	} while(ret!='n');


什么时候用到break?
	1.突发情况
	2.为了提高程序的执行效率
		continue 康忒丢 继续，连续
		用与退出本次正在执行的循环,执行之后的其他的循环
	str.length;
str是VB的一种函数，可以将数字型变量或常量改变成字符型变量或常量。

str.charAt字符位置

	getElementById
	得到 元素 通过 身份
	getElementsByTagName
	得到 元素复选 通过 附加 名称



4.8e3就是 e3乘于10的3次方 1000
	Number.MIN_VALUE 浮点型最小值
	Number.MAX_VALUE 浮点型最大值

	console.log(Number.POSITIVE_INFINITY) //正无穷
	console.log(Number.NEGATIVE_INFINITY) //负无穷
	pisitive正
	negative反

var box=100e10;
alert(isFinite(box));

	Finite有限的
	最高e100
	到e1000会提示infinite无限

var box14=0/0;                 //数字中第一个可以为0
	lee不能被转换整数


	toString


function f1(a,b){
          console.log(a);
          console.log(b);
          return 1;
        }
	return返回

console返回的是function整体内容,说明是function类型


arguments//函数内部有一个局部变量,arguments:数组,保存了函数调用时,所传入的实际参数
var a4 = new Function('alert("弹窗")')(); //直接创建函数对象,执行字符串函数体的代码

	arguments 参数对象  【arguments.callee】 参数对象所属函数


【循环类】
for(var 索引值  in 数组名){
		 		
		 	}

for of
	for(var 元素名  of 数组名){
				
	}

 变量名.forEach(function(元素,index){
		 });

var arr1 = [8,4,2];
		 arr1.forEach(function(ele,index){
		 	console.log(arr1 + '[' + index + '] = ' + ele);
		 });




==========================================================================================
【String】【String类型】【字符串】【字符串类型】[String][字符串]
【String字符串常见函数】
	【变量.charAt(index);】 返回i位置的字符串 【从index 0开始】()不写默认0;
		charAt():通过索引值来找到对应的字符
	 	character:字符
	【变量.charCodeAt(index);】 通过值查找到对应字符的ASCII值
	【String.fromCharCode(index);】 通过ASCII值来获取对应的字符
		console.log(String.fromCharCode(99)); //C
		console.log(String.fromCharCode(48)); //0
	【变量.indexOf("字符串");】在字符串中查找str第一次出现的位置,并返回,不存在则返回-1【对大小写敏感】
		【indexOf()】 查找指定字符在字符串中的位置,从左到右进行查找
		参数:指定字符
			也可以链各个参数 第一个参数 指定字符 第二个参数:开始查找的位置包括该位置
		返回值:-1;
			如果查找到了，返回的是符合条件的第一个字符的索引值
			如果没有，返回值为-1
	【变量.lastIndexOf("字符串");】
		lastIndexOf() 从右到左进行指定字符在字符串中的查找
		也可以链各个参数 第一个参数 指定字符 第二个参数:开始查找的位置包括该位置
		返回值:-1;
	返回值:如果查找到,返回的是对应字符的索引值，否则返回-1
		var str2 = 'abcdddefgdd';
		console.log(str2.lastIndexOf('d')); //10
		console.log(str2.lastIndexOf('d',2)); //-1
		console.log(str2.lastIndexOf('d',3)); //3
	【变量.split(str);】 根据str对字符串进行拆分 【一般用于英文,括号写' ',给句子每个单词添加,逗号,直接''给每个字母添加逗号,直接		.str.split(' ',3)是给3个字母单词切割添加,逗号并输出】
	【变量.replace("被替换字符串","要替换字符串");】将字符串中第一个s1替换为s2
	【变量.match();】 匹配
	 返回值:
	 	如果匹配成功，返回的是符合条件的第一个指定字符的索引值
	 	如果匹配不成功,返回值null
	【变量.search();】搜索指定字符
	 	如果找到，返回指定字符(第一个)所在的索引值
	 	如果没有，返回值-1
	【变量.substring(startIndex);】 截取字串
	 	从字符串下标startIndex开始，到字符串下标endIndex
	 	参数:
		【一个参数】 指定开始截取位置  一直截取到最后(包含开始位置)
	 		 可以为2个；开始位置,结束位置(截取的字串包含开始位置)
		【二个参数,第一个是索引值,第二个是指定length长度】

	【变量.substr();】 截取字串
	 		参数：
	 			一个参数:起始位置 (包含开始位置,一直截取到最后)
	 			二个参数:起始位置 截取的字串长度（包含起始位置)
		【二个参数,第一个是索引值,第二个是从第一个索引值开始后的指定length长度】

	【变量.toUpperCase();】 把字符串中所有小写字符变成大写
	【变量.toLowerCase();】把字符串中所有大写字符变成小写
	 	注意：原字符并未改变
Upper 上面的
Lower 下面的
Case 示例
	【变量.trim()】去除字符串的前后空格
		注意:原字符串并未改变
		trimLeft() 去除左面的空格
		trimRight() 去除右面的空格
	【变量.split();】把字符串分割为数组
	var str7 = 'ab#cd#ef#gn';
	console.log(str7.split()); //["ab#cd#ef#gn"]
	console.log(str7.split('#')); //["ab","cd","ef","gn"]
	
	var str8 = 'adcdefg';
	console.log(str8.split()); //["adcdefg"]
	console.log(str8.split('')); //["a","d","c"."d","e","f","g"]



	【unescape()】函数
	unescape(string) 
	参数	描述
	String 必须.需解码或反转义的字符串

	返回值
		string被解码后的一个副本

	说明:
		该函数的工作原理是这样的:通过找到形式为%xx和%uxxxx的字符序列(x表示十六进制的数字),用Unicode字符\u00xx和\uxxxx替换这样的字符序列进行解码.

	提示和注释
	注释:ECMAScript v3已从标准中删除了unescape()函数,并反对使用它,因此应该用decodeURI()和decodeURLComponent()取而代之	
	
实例

	【escape()】将字符串在页面编码
	【unescape()】将字符串在页面解码
	在本例中,我们将使用escape()来编码字符串,然后使用unescape()对其解码:
    	var test1 = 'VIsit W3School!';
        	test1 = escape(test1);
        	document.write(test1 + '<br />');

        	test1 = unescape(test1);
        	document.write(test1 + '<br>');

	
	//示范:
	 var a= '1';
     	 console.log(unescape(a)) //1

	※:在控制台输出.和if判断都会正常输出,但页面输出write和innerHTML都能编码和解码


====================================================================================================
	【形参】是function函数形体
	【实参】是函数调用的实际参数


【Date日期】
document.write('<br>' + d2.getFullYear() + '年' + (d1.getMonth() + 1) + '月' + d2.getDate() + '日'+d2.getHours() + '小时' + d2.getMinutes() + '分' + d2.getSeconds() + '秒 <br> 星期' + d1.getDay());

	【变量名.getFullYear()】;年份
	【变量名.getMonth();】 月份(0-11) 从0开始 获得自然月需要+1
	【变量名.getDate();】 日期数字(1-31)
	【变量名.getHours();】小时
	【变量名.getMinutes();】分
	【变量名.getSeconds();】秒
	【变量名.getMilliseconds()】 毫秒
	【变量名.getDay()】; 星期几(0-6)
	【变量名.getTime()】 获得时间的毫秒之(1970-1-1到现在)
	【变量名.toLocaleString();】将日期转换为本地日期显示格式,获取年月日
		也能和toString()方法一样将数组转换字符串,但不能像join()一样修改连接符
	【变量名.toLocaleDateString();】 获取年,月,日
	【变量名.toLocaleTimeString();】 获取时,分,秒

	【checkTime(date1.getMinutes());】获取当前年,月,日,需要前面先创建Date对象	
	【10以下部位0】
	function checkTime(i){ //将0-9的数字前面加上0，例1变为01 
		 return i < 10 ?  "0" + i : i;
	} 

	世界时 (UTC)
	【变量名.getUTCDate()】 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)
	【变量名.getUTCDay()】 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)
	【变量名.getUTCMonth()】 根据世界时从 Date 对象返回月份 (0 ~ 11)。
	【变量名.getUTCFullYear()】根据世界时从 Date 对象返回四位数的年份
	【变量名.getUTCHours()】根据世界时返回 Date 对象的小时 (0 ~ 23)
	【变量名.getUTCMouths()】 根据世界时返回 Date 对象的分钟 (0 ~ 59)
	【变量名.getUTCSeconds()】 根据世界时返回 Date 对象的秒钟 (0 ~ 59)
	【变量名.getUTCMilliseconds()】 根据世界时返回 Date 对象的毫秒(0 ~ 999)

	【变量名.data1.setTime()】以毫秒设置Date对象,乘以1000就是秒


	把get改成set就是自己修改
数学函数*静态方法 使用Math.函数名();

	var date1 = new Date();
	console.log(date1); //Thu Feb 09 2017 14:09:30 GMT+0800 (中国标准时间)
	console.log(date1.toLocaleString()); // 2017/2/9 下午2:09:31
	console.log(date1.toLocaleDateString()); // 2017/2/9
	console.log(date1.toLocaleTimeString()); // 下午2:10:29


【Math数学】
	【Math.abs(n);】求取n的绝对值
	【Math.sqrt(n);】开平方 (指数就是平方,也就是幂方,指数是平方的一种) 
	【Math.pow(n,3)】求幂方也就是相同两个数乘以等于n，比如这就是n的三次幂
	【Math.round(n)】四舍五入,得到整数 
	【Math.ceil(n);】向上靠拢截取数据,也就是说如果输出数字是5，那么输出5，如果是小数点1.4，那么自动去整2。和四舍五入不同，如果是小数点，直接加1取整
	【Math.floor(n);】向下靠拢截取数据，也就是如果输出5.1，那么自动输出6.如果输出是3.2，自动输出3.不管是不是四舍五入
	【Math.random();】随机生成0~1之间的任意一个值 (如果要大于10或100的随机数)只要相应乘于

	【Math.PI】 求圆周率
	

数组:
	JAVA int[] as = new int[10]; javaの长度不可变
js  数组长度可变,数据类型无限制
	一:var arr = new Array();
	二:var arr = [元素1,元素2,元素3,......];

给元素赋值
arr[下标] = value值;


【Array】【数组】[Array][数组]
3.【属性 length】 //数组的长度
	在jQuery中:
	【$.isArray(变量)】判断是否为Array类型,是的话返回true,不是的话false
	【$.isFunction(变量)】判断是否为Function类型,是的话返回true,不是的话false
	【$.isWindow(变量)】判断是否等于window,是的话返回true,不是的话false
	【$.type(变量)】判断类型,number,boolean,string,null,undefined,regexp,function,object
4常见方法
	【变量名.push(e1,e2,......,en]);】 //向数组末尾按照顺序追加元素
	【变量名.splice(n,len);】 //从下标开始删除.一次总共删除几个
	【变量名.pop();】 //删除数组中最后一个元素,并将该元素返回
	【变量名.shift();】 //删除数组中的第一个元素,并将该元素返回
	【变量名.unshift(e1,e2,...en);】 向数组的第一个元素之前.添加n个元素
	【变量名.reverse();】 //将数组元素倒置
	【变量名.jojn(str);】 讲数组元素用str拼接成字符串返回(不给参数按照','号进行拼接) 
		使用arr.join(' ')一定要在前面添加变量 var ret = 变量名.jojn(' ');否则无法更改原来数组.
	       arr.join(" ");
	【变量名.concat()】 连接两个数组，从而生成一个新的数,新的数在前面,原来在后面,不改变原来数组

	【变量名.sort(函数名);】
	//对数组元素进行排序,按照sortFunction给定的排序规则,对数组元素进行排序,如果不指定排序规则函数,默认将数据按照字符串的排序规则进行排序(按照字母顺序)
	//大小对比,用来  【变量名.sort(函数名);】调用 注:后面不加()括号,否则无法生效
	function $sortMax(a,b){
		return a < b; //这是从大往下排列,倒序
	}
	function $sortMin(a,b){
		return a > b; //这是从小往大排列 升序
	}
	也可以直接往里面写
	arr.sort(function(a,b){
		return a - b;
	})

	【-】 == 【升序】 == 【>】	升序就是 从小往大排序
		 【降序】 == 【<】	降序就是 从大往小排序

	var ary = [1,5,3,100,7,9,4];
	【Math.min.apply(null,ary)】得到数组的最小值
	【Math.max.apply(null,ary)】得到数组的最大值

	 【slice(start,end)】两个参数,截取指定长度数组,不改变原数组
	 	start:起始位置 下标（从该位置开始截取,包含该位置)
	 	end:结束位置 下标 (截取到此位置结束,不包含该位置)
	 返回值:截取元素构成的新数组
	 元素组不改变
		【一个参数,是指定索引到最后】不改变原数组
		【二个参数,第一个是索引值,第二个是指定length长度】不改变原数组
	PS:如果第一个索引参数是负值,那么就从右往左计算
		
	 【splice()】可以进行删除,也可进行添加
	 第一个参数:截取到指定长度数组,改变原数组
	 第二个参数: 数值
	 		如果比0大,该数值表示为删除的个数
	 			删除元素中包含起始位置上的元素
	 			返回值为删除元素构成的新数组
	 			原数组改变
	 		如果为0;表示添加，随后逗号分隔添加的元素
	
	var arr8 = [10,20,30,40,50];
	arr8.splice(1,2);
	console.log(arr8.splice(1,3)); //[20,30]
	console.log(arr8); //[10,40,50]
	//第二个参数为0
	console.log(arr8.splice(1,0)); //[]空数组，没有元素
	arr8.splice(1,0,'hello','bye');
	console.log(arr8); //[10,'hello','bye']
	第三个参数:
		指定要添加或删除,替换数组数字或字符	

	【数组.toString()】转换为字符串
		不会改变原数组,需变量存放

	 【数组.indexOf(值)】 从数组的最左面开始按index查找某一个指定值最开始位置
	 如果有返回它的索引值(下标)
	 如果没有，返回值是-1
	 数组 去重
		不改变原数组,用于判断,或用变量存装
	【数组.lastIndexOF(值)】从数组的最左面开始按index查找某一个指定值最后位置
	 如果有,返回的是查找参数的索引值
	 如果没有,返回的是-1
		【返回符合条件的最后第几个长度)】

	→【数组去重】
	var ary = [1,2,3,1,2,3,4];
	//一种,不推荐,封装函数无法使用
	/*var bry = [];
	for(var i = 0; i < ary.length; i++){
		(bry.indexOf(ary[i]) < 0) && (bry.push(ary[i]));
	}
	console.log(bry);*/
		
	其中(bry.indexOf(ary[i]) < 0) && (bry.push(ary[i]));也可以换成
	    (bry.indexOf(ary[i]) == -1) && (bry.push(ary[i]));
	也就是说判断如果空数组不存在,就添加索引的下标,若存在就不进入代码块,这样去重了.


	//第二种
	/*for(var i = 0; i < ary.length; i++){
		for(var j = i + 1; j < ary.length; j++){
			if(ary[i] == ary[j]){
				ary.splice(j,1);
				j--;
			}
		}
	}*
	用双层for循环来去重,外层for循环得到数组所有下标,内层for循环为了实现排他,得到index索引+1,如果第一个和第二个相同的话,那么删除第二个相同的,并且因为索引删除下标,会向前进1,所以才j-1;为了让索引正常循环对比.这样一来就循环把重复的删除了.

	//第三种 最推荐
	var obj = {};
		for (var i = 0; i < ary.length; i++) {
			if(obj[ary[i]] == ary[i]){
				ary.splice(i,1);
				i--;
				continue;
			}
			obj[ary[i]] = ary[i];
		}
	console.log(ary);
	不使用空数组,而是使用一个空对象来存放,先遍历数组,然后判断空对象是否有这个下标的数据,和上面for循环原理相同,如果有就进入代码块,删除第二个重复,递减1,退出本次循环,继续下次循环,如果空对象没有这个下标,那么就添加,这个下标
	这个优点在于,使用空对象,只循环一次,使用continue,可以不必执行以下无用操作,直接跳出继续循环,直到满足条件后,退出循环.

【Object对象】
调用对象时,在html里添加on后设置,然后【变量名或函数名()】
PS:不要加.点,点是在js调用或修改使用对象

创建自定义对象:
java 由对象模板class创建对象
js   没有class类的概念,也没有对象的模板

1.JSON形式创建对象(最常见)
var p = {
    属性名1:值1,
    属性名2:值2.
    ...
}
2.通过new Object
var p = new Object();

this【返回对象】	

PS:function(){};方法里不可添加write();写入文档和+''拼接字符串,否则会出错



1.ECMA-欧洲计算机制造者协会
	-European Computer Manufacturer's Association
1-1.ECMAscript
2.BOM - 浏览器对象模型
	-Browser Object Model 
3.DOM - 文档对象模型
	-Document Object Model
	

js引用方式: 三种
	-内联    js代码写在标签内部
	-内部引用   script标签包裹  任意位置均可
	-外部引用   script标签引入   src="js文件路径"

css引用方式:三种
	-内联样式  标签内部
	-内部样式  head标签里,用style标签包裹
	-外部样式  link href=""
=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
【javascript常见事件类型】 [js事件]【js事件】
鼠标相关
	【onclick】 单击事件
	【ondblclick】 双击事件
	【onmouseover】 鼠标移入
		【onmouseenter】鼠标移入事件
	【onmouseout】 鼠标移出
		【onmouseleave】onmouseleave 事件类似于 onmouseout 事件。 唯一的区别是 onmouseleave 事件不支持冒泡 。
	【onmousemove】 鼠标移动
	【onmousedown】 鼠标按下
	【onmouseup】 鼠标松开

键盘相关
	【onKeyDown】
	【onKeyUp】

常见事件类型
	body相关事件
	【onload = fun //页面加载时促发fun方法
	【onunload】 窗口离开时触发(刷新,返回,前进,主页)
	【onscroll】 页面滚动
	【onresize】 缩放页面

【注:使用body事件时,必须加onmousedown按下事件,然后再添加触发事件】
	【onload】当文档加载完毕触发事件
	【onscroll】当点击下拉框触发事件
	【onresize】当缩小放大页面触发事件

form表单控件相关事件
	【onblur】 当前元素失去焦点【在input文本类型使用 当鼠标移出文本框时触发事件】 
		防止用户对文本框中输入文本:onfocus="this.blur()"
	【onchange】 当前元素失去焦点,并且值改变时【在下拉列表使用 加在select里面 当鼠标选择了下拉列表某个选项,触发事件】 
	【onfocus】 当前元素获得焦点时
	【onsubmit】 表单提交时
	
	【onloadedData】当元素加载成功后触发的事件,一般用在视频上
	【onended】元素完成后促发事件,一般用在视频播放完成之后,回到初始位置

	【onselect】在元素中文本被选中后触发。
示范一:
<input type="text" name="username" onblur='js_obj()'/>

示范二:
	<select name="city" onchange='js_obj()'>>
		<option value="1">=====请选择====</option>
		<option value="2">这是下拉框一</option>
		<option value="3">这是下拉框二</option>
	</select>





	//阻止Event事件冒泡函数的封装
	function $stopBubble(Events){
		var e = event || window.event;
		if(e.stopPropagation){
			//谷歌等标准浏览器
			e.stopPropagation();
		} else{
			//IE
			e.cancelable = true;
		}
	}

stopPropagation 【停止 传播】
cancelable
can能

	//封装阻止浏览器标签元素,默认行为 函数
	function $stopPro(e) {
		var e = event || window.event;
		//考虑阻止行为
		if (e.preventDefault) {
			e.preventDefault()
		} else{
			e.returnValue = false;
		}
	}


preventDefault

prevent预防
Default未履行


【js调用html元素来操作】
	【第一种，用变量接收id】
	var 获取ID元素名 = document.getElementById('id名');
		获取ID元素名.onclick = function () {};
	【第二种，在内部样式表添加 onclick = "函数调用();"】
	()括号里是实参
	需要在外部创建
	function 函数调用(){};才能使用
怎样获取value值，只要用第二种方法
	【获取ID元素名.value】
怎样更改样式:
	【获取ID元素名.style.color = "red"】



【W3C查找】【W3C】【W3C查询】
【JavaScript】--点击左侧【JavaScript】--左下角--JS 参考手册 选择【JavaScript 对象】,再在左侧需要需要的类型对象

【Nunber对象】
变量.toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。

confirm错误框



百位求数
四种方法
parseInt(1234 / 100) % 10;
parseInt(1234 / 100 % 10);
我使用方法
parseInt(1234 % 1000 / 100);




Event Drive 事件驱动



函数的概念
【把完成特定功能的一段代码封装】
作用:
	使程序变得更简短而清晰
	有利于程序维护
	可以提高程序开发的效率
	提高了代码的重用性(复用性)


	new新的
	files文件夹
	do事件
	cal计算简称 calculate 【calc】计算器
	opt选择
	practise【练习】
	open【开始】
	close【终结】

	querySelectorAll
	query【对】
	selector【选择器】
	placeholder
	place【地方,放置】
		修改样式:
	::-webkit-input-placeholder { /* Chrome/Opera/Safari */
  		color: pink;
	}
	::-moz-placeholder { /* Firefox 19+ */
  		color: pink;
	}
	:-ms-input-placeholder { /* IE 10+ */
 		color: pink;
	}
	:-moz-placeholder { /* Firefox 18- */
 	 color: pink;
	}

	holderr【支持物；持有者】
	create【创造】
	parentNode
	parent【父亲,或母亲】根源




【HTMLDOM】[HTMLDOM][HTMLDOM][htmldom]	
在for循环中，你可以循环取得数组或是数组类似对象的值，譬如arguments和HTMLCollection对象。通常的循环形式如下： 
1 // 次佳的循环
2  for (var i = 0; i < myarray.length; i++) { 
3.     // 使用 myarray[i]做点什么  
4.
}  
这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当myarray不是数组，而是一个HTMLCollection对象的时候
	HTMLCollections指的是DOM方法返回的对象，例如： 
	【document.getElementsByName()】
	【document.getElementsByClassName()】 
	【document.getElementsByTagName()】

还有其他一些HTMLCollections，这些是在DOM标准之前引进并且现在还在使用的。有： 
	【document.images】: 页面上所有的图片元素
	【document.links】 : 所有a标签元素  
	【document.forms】 : 所有表单 
	【document.forms[0].elements】 : 页面上第一个表单中的所有域  集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。
	
这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的： 
	  for (var i = 0, max = myarray.length; i < max; i++) {  2    
	// 使用myarray[i]做点什么 
3 }  这样，在这个循环过程中，你只检索了一次长度值。
	在所有浏览器下，循环获取内容时缓存HTMLCollections的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//此数据貌似很老，仅供参考

	【window.元素id】可以直接访问元素













【DOM】[DOM]
一个浏览器窗口中的DOM顺序是:window->(navigator,screen,history,location,document) 
	window
	navigator浏览器品牌
	screen屏幕
	history历史
	location位置
	document文档

	DOM操作:
	[获取DOM节点]
	获取元素节点:
		【document.getElementById();】
		【document.getElementByTagName();】标签名称
		【document.getElementClassName()】;类名称
		【document.getElementByName();】name属性
		【document.querySelector();】 //和getElementById一样只能获取元素名,
		【document.querySelectorAll();】 //和获取元素名,属性名,class相同,得到的是个数组
			querySelector()只支持IE8以下
	

	获取属性节点:
		隐式访问  元素.属性
		【getAttribute()】获取元素的属性值 //如果标签内没属性，会返回null
		【setAttribute()】改变元素的属性值
		【getAttribute()】是单一属性,获取时必须在getElementsByTagName后面添加索引值，否则不能遍历循环】
		【removeAttribute()】删除属性，*部分低版本浏览器不支持,IE6以下不支持
		var inpus = document.getElementsByTagName('input')[5];
		console.log(inpus.getAttribute('checked'));


	获取文本节点
		innerHTML 元素内部所有内容(不包括标签本色)
		outerHTML 元素内部所有内容(包含标签本身)
		innerText 元素内部所有的文本信息


	【重点一】
	js获取id，Element后面不加s，如果是获取class和name的话必须Element后面添加s,且无论是获取ID,Class还是name,元素名，都必须在Element或Elements后面添加"By"否则无法正确获取
	【重点二】
	直接获取body元素名,不用添加变量存放,其他的标签需要用变量存放ID或class,name,标签名
	<body id="body"> 直接在标签内添加id就可以调用输出
	body.innerHTML = '这是文字,也可以添加名单' + '和document一样也能使用拼接字符串';
	body.outerHTML = '这是文字,也可以添加名单' + '和document一样也能使用拼接字符串';



	/*
	 1.通过类名获取li
	 
	 如果通过类名,获取到的只有一个元素.记住要加[0];
	 
	 */
	var lis = document.getElementsByClassName('li1');
		console.log(lis);
		lis[0].style.backgroundColor = 'red';
		
		//2.通过id名称获取 输入框
		var txt = document.getElementsByClassName('txt');
		console.log(txt);
		
		//3.通过标签名称获取input标签
		var inps = document.getElementsByTagName('input');
		
		//4.通过name获取标签
		document.getElementsByName('sex');
		
		//5.html5新增选择器
		var li1 = document.querySelector('.li1'); //只能innerHTML更改第一个
		 var li2 = document.querySelectorAll('.li1'); //和class一样,需要循环遍历,再进行操作
		input[type="checkbox"]'
		 
		window.onload = function(){
			for(i = 0; i < li2.length; i++)
			li2[i].innerHTML = '可以添加内容,更改内容';
		}
		
【DOM节点】
	【子节点就是包含年内容文本的整个标签+内容】
	【子节点元素就是获取标签名和属性】

二.DOM节点获取->通过其他元素获取
	【元素.nodeType】 获取节点类型
	【元素.nodeName】 获取节点名称
	【元素.nodeValue】 获取节点值
	【元素.tagName】获取标签,元素名,默认大写
		通过【e.tagNam.nodeName】可以当前元素名

2.根据节点层级访问节点
	2.1 访问根节点
		-【document.documentElement】
	2.2 获取到元素所有的属性节点
		-【元素.attributes】
	2.3 获取元素的子节点
		所有子节点 -> 【元素.childNodes】 【会保留空白,换行】注意后面要加s
			-所有子元素节点 -> 【元素.children】【可以在里面添加[1]索引值 不会保留空白,换行】非标准
			-第一个子节点 -> 【元素.firstChild】
			-第一个元素子节点 -> 【元素.firstElementChild】
			-最后一个子节点 -> 【元素.lastChild】
			-最后一个元素子节点 -> 【元素.lastElementChild】
	【createElement】
	【childNodes】 除了包含标签节点,换行,空白字符【必要遍历循环判断属性，再进行操作】
	【children】实际开发过程中,往往只需要元素节点  children儿子
	【parentNode】
	【firstChild】第一个子节点
	【firstElementChild】第一个子节点的子节点
	【lastChild】最后一个子节点
	【lastElementChild】最后一个子节点的
	【nextSibling】下一个兄弟节点(包括换行 空白) previousSibling
	【nextElementSibling】前一节节点,也就是返回父路径
	【previous】之前
		create【创建】
	【createTextNode】
		Node【节点】
	【appendChild】
		append【添加】第一个
	【insertBefore】
		insert【插入】之前
	【removeChild】
		remove【去除】
	【replaceChild】
		replace【替换】
	【replaceChild】替换节点必须在父级进行操作
	【replaceChild.parenNode.relaceChild(替换元素,被替换元素);】
	cloneNode
		clone【拷贝】复制
	js样式
	【currentStyle】 【现在样式】IE使用
	【getComputedStyle】 【给 计算器 样式】标准浏览器使用
	
	js设置样式
	【元素名.style.setProperty('属性名','属性值')】支持标准浏览器,不支持IE 权限比

	【box.ownerDocument】 //HTMLDocument 返回文档对象，根节点

	【box.childNodes[0].nodeValue；】 获取第一个子节点内容
	【box.childNodes[box.childNodes.length - 1].nodeValue】 获取最后一个子节点
	

	//变量存放元素节点
	【box.firstChild.nodeValue】
	【box.lastChild.nodeValue】

	【box.ownerDocuent === document】 //true
	【box.ownerDocuent.nodeName】 //#document

	【box.firstChild.nexSibling】 //HTMLSpanElement
	【box.firstChild.nexSibling.nodeName】 //下一个同级节点的标签名
	【box.lastChild.previousSibling.nodeName】 //上一个同级节点的标签名

	【box.attributes[0];】 //Attr 属性节点
	【box.attributes[0].nodeType】 //2.属性节点的类型值
	【box.attributes[0].nodeValue】 //第一个属性的属性值
	【box.attributes[0].nodeName】 //第一个属性的属性名
PS:遍历的时候,是从后往前的

	【box.attributes['title'].nodeValue】
	====================================
  <div id="box" title="标题" class="bbb">
  	<p>测试Div1</p>
  	<p>测试Div2</p>
  	<p>测试Div3</p>
  </div>
	【box.childNodes.length】 标准浏览器会将换行也解析个数
	fiterWhiteNode(box.childNodes).lentth
	
解决方法：
	一：忽略空白字符
function $removeWhiteNode(node){
  var ret =[];
  for(i = 0; i < node.length; i++){
    if(node[i].nodeType === 3 && /^\s+$/.test(node[i].nodeValue)){
      continue;
    } else{
      ret.push(node[i]);
    }
  }
  return node;
}
	二：移除空白字符
function $removeWhiteNode(node){
  for(i = 0; i < node.childNodes.length; i++){
    if(node.childNodes[i].nodeType === 3 && /^\s+$/.test(node.childNodes[i].nodeValue)){
  node.childNodes[i].parentNode.removeChild(node.childNodes[i]);
    }
  }
  return node;
}
}
	【alert(Node)objiect Node】 IE不支持
	【if(xx.nodeType === 1)】 //表示判断元素节点
	【if(xx.nodeType === 2)】 //表示判断属性节点
	【if(xx.nodeType === 3)】 //表示判断文本节点
	【if(xx.nodeType === 8)】 //表示判断注释
	【if(xx.nodeType === 9)】 //表示判断Document节点
	【Node.ELEMENT_NODE】 //表示元素节点的类型值
	【Node.TEXT_NODE】 //表示文本节点的

	【if(xxx.nodeType === Node.ELEMENT_NODE)】
	【if(xxx.nodeType === Node.TEXT_NODE)】

	【if(xxx.nodeType === 元素)】
	【if(xxx.nodeType ===文本)】
	//通过英文常量来代替阿拉伯数字，使的判断更加的清晰

if(typeof Node == 'undefined){
	//创建一个全局Node
	wondow.Node = {
	ELEMENT_NODE:1,
	TEXT_NODE:3;
	}
}
	【document.node】 //HTMLDocument
	【document.nodeType】 //9
	【alert(document.nodeName)】//#document
	【document.childNodes[0]】 //DocumentType,IE理解为注释
	【document.childNodes[0]】.nodeType //10，IE为8
	【document.childNodes[0]】.nodeName 
	//火狐为HTML,谷歌为html，IE为#comment
	//火狐新版本为html

	【document.childNodes[1]】 //HTMLhtmlElement
	【document.childNodes[1].nodeType】 //1
	【document.childNodes[1].nodeName】 //HTML

	【document.documentElement】 //HTMLhtmlElement
	【document.body.nodeName】 //获取Body

	【document.doctype】 //DocumentType,IE会显示null
	【docuemnt.childNodes[0].nodeName】 //IE会是#Conment

	【document.title;】
	【document.title = 'box';】
	【document.URL】
	必须在服务器端使用
html//localhost:8080/js/domo.html
	【docuemnt.domain】 //获取域名,服务器端
	【docuemnt.refarrer】 //获取上一个URL,服务器端

	【docuemnt.images.length】

	【box.normalize();】//合并同一级别,创建的多个文本节点为一个,方便索引
	【box.childNodes[0].splitText(3);】 //分割从左到右长度的第一个,后面的去除,不改变原来文本节点,需变量存放
	
	【box.childNodes[0].deleteData(0,2);】删除从0位置的2个字符,改变原字符串
	【box.childNodes[0].insertData(0,2);】添加从0位置的2个字符,改变原字符串
	【box.childNodes[0].replaceData(0,2,'】这是第0个第2个'); //从0位置替换掉2个字符
	【box.childNodes[0].substringData(0,2);】 //索引的意思,从0位置获取2个字符,直接输出 不改变原字符串

	 console.log(box.childNodes[1].nodeType); //#comment
 	 console.log(box.childNodes[1].nodeName); //8

	  console.log(document.documentElement.clientWidth);
  	console.log(document.body.clientWidth);

IE6开始区分标准模式和混杂模式(怪异模式).去掉<!Document html>就是怪异模式
//对IE浏览器获取长度的兼容
function $whiteWidth(){
  if(document.compatMode == 'CSS1Compat'){
    return document.documentElement.clientWidth;
  } else{
    return document.body.clientWidth;
    }
}
	[文档宽度][winodw宽度][浏览器宽度][窗口宽度]
	【clientWidth】可视宽度
	【document.documentElement.clientWidth】document可视宽度
	【document.body.clientWidth】body可视宽度

  console.log(box.contains(p)); //判断子节点是不是父节点的子级,简单说就是判断是否为父子关系
//PS:火狐旧版本不支持3.6以下,新版本支持14
//PS:safari2.x不支持,3.0以上才支持
//PS,很多更低的版本,提供的两个方案均不支持

console.log(box.innerText); //获取文本并过滤掉HTML,直接删掉的,火狐不支持

虽然innerHTML可以插入HTML,但本身还是有一定的限制,也就是所谓的作用域元素,离开这个作用域就无效了
box.innerHTML = '<script>aleet("Lee")</script>';//<script>元素不能被执行
box.innerHTML = '<style>background:red</style>';// <script>元素不能被执行

outerText在取值的时候和innerText一样,同时火狐不支持,而赋值方法相当危险,它不但替换了文本内容,还将元素直接抹去
var box = document.getElementByld('box');
box.outerText = '<b>123</b>'>;
console.log(box); //null

outerHTML支持标题,特征和innerText一样,它不但替换了文本内容,还将元素直接抹去

	
类型值
	CDATA_SECTION_NODE（cdata_section_node）	CDATA	类型4
	ENTITY_REFERENCE_NODE(entity_reference)	实体参考	类型5
	ENTTTY_NODE(enttty)	实体	属性6
	PROCESSING_INSTRUCETION_NODE(processing)	处理指令	类型7
	COMMENT_NODE	注释	类型8
	DOCMENT_NODE	文档根	类型9
	DOCUMENT_TYPE_NODE(document_type_node)	doctype	类型10
	DOCUMENT_FRAGMENT_NODE(document.fragment)	文档片段	类型11
	NOTATION_NODE(notation_node)	符号	类型12



【给父级节点后面添加节点】
   	/*box.parentNode.appendChild(p); //给父节点添加内容
【给当前节点后面添加节点】
   	box.firstNode.appendChild(p); //给当前元素最后添加内容
   	box.childrent[0].appendChild(p); //也能给当前元素最后添加内容*/
【给父级元素节点上一个兄弟节点后面添加内容,也就是给父级的上一个同级添加内容】
	//box.parentNode.insertBefore(p,box); //添加父节点的上一个兄弟节点的前面
【给父级元素节点下一个兄弟节点前面添加内容,也就是给当前元素节点后面同级添加下一个元素节点】
	box.parentNode.insertBefore(p,box.nextSibling); //添加父节点的下一个兄弟节点的前面

【给父级的第几个元素节点前面添加节点】
	当前ID元素节点.parentNode.insertBefore(添加节点,box.parentNode.firstChild);//在父节点的第一个节点的最前面添加元素标签
	box.parentNode.insertBefore(添加节点,当前ID元素节点.parentNode.children[0]); //也能实现在几个元素前面插入,并且能自定义位置,推荐使用


【自定义删除子级元素】
  box.removeChild($removeWhiteNode(box).childNodes[1]);//自定义删除子级元素
  box.removeChild(box.childNodes[1]); 正确删除

box.parentNode.removeChild(box.parentNode.childNodes[1]);//从父级删除元素本身
box.parentNode.removeChild(box.parentNode.children[0]);//从父级删除元素本身



var obj = document.getElementById("div");
    objh=document.defaultView.getComputedStyle(obj,null).height;
    //或者
    objh=window.getComputedStyle(obj,null)[height];
    //IE下 需要
    objh=obj.currentStyle[height];

	下面是一个解决兼容性方法
	function getStyle(element,property) {
　　var value = element.style[camelize(property)];

　　if(!value) {
　　　　if(document.defaultView && document.defaultView.getComputedStyle) {
　　　　　　value = document.defaultView.getComputedStyle(element).getPropertyValue(property);
　　　　} else if(element.currentStyle) {
　　　　　　value = element.currentStyle[camelize(property)];
　　 　　}
　　}
 
　　return value;
}

	defaultView
	default【未履行】
	View【看待】

	camelize【加熔（糖）使焦，（糖）熔化而变成焦糖】
	property【特征,属性】

3.js修改样式表[js样式修改]

 获取文档样式表的lists

document.styleSheets[0];//获取第一个样式表
W3C坚持使用cssRules[]，而微软坚持rules[]。

document.styleSheets[0].cssRules[0];//W3C 获取第一个样式表的第一个样式信息
document.styleSheets[0].rules[0];//IE  获取第一个样式表的第一个样式信息



document.title             //设置文档标题等价于HTML的<title>标签
document.bgColor           //设置页面背景色document.fgColor           //设置前景色(文本颜色
)document.linkColor         //未点击过的链接颜色
document.alinkColor        //激活链接(焦点在此链接上)的颜色
document.vlinkColor        //已点击过的链接颜色document.URL               //设置URL属性从而在同一窗口打开另一网页document.fileCreatedDate   //文件建立日期，只读属性
document.fileModifiedDate  //文件修改日期，只读属性
document.fileSize          //文件大小，只读属性
document.cookie            //设置和读出cookie
document.charset           //设置字符集 简体中文:gb2312






【矩形对象】
getBoundingClientRect().top //元素上边距离
getBoundingClientRect().right//元素右边距离
getBoundingClientRect().bottom//元素下边距离
getBoundingClientRect().left//元素左边距离
BoundingClientRect
Bound弹跳,限制
Client当事人
Rect [rectifier]纠正
ps:IE,Firefox + Opera9.5, chrome, safari支持,在IE中,默认坐标从(2.2)开始计算,导致最终距离比其他浏览器多出两个像素,我们需要做个兼容

IE8下多出2像素
	function $getRect(ele){
		var rect = ele.getBoundingClientRect();
		var clientTop = document.documentElement.clientTop;
		var clientLeft = document.documentElement.clientLeft;
		return {
		top : rect.top - clientTop,
		bottom : rect.bottom - clientTop,
		left : rect.left - clientLeft,
		right : rect.right - clientLeft,
		};
	}

PS:分别加上外边距,内边境,边框和滚动条,用于测试所有浏览器是否一致


	//动态添加js脚本
	//使用以下动态添加脚本,想调用添加脚本函数,必须在window.onload = function (){代码块}写代码
	function $loadScript(url){
		var script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = url;
			document.getElementsByTagName('head')[0].appendChild(script);
	}


动态添加js文件
script.appendChild(document.createTextNode("alert('Lee')")); //IE不支持这种写法
script.text = "alert('Lee')";


【BOM节点】
 window常用方法:
	 	alert() prompt() confirm()
	 	setTimeout() clearTimeout()
	 	setInterval() clearInterval()
	 	open() close()
	 window对象:
	 	location 对象【位置】
	 		属性:
	 			href 设置访问的url
	 		常用方法
	 			reload() 重载/刷新
	 			
	 	history 对象 【历史】
	 		back() 返回 上一页 后退
	 		forward() 向下 下一页
	 		go(num) 如果num是正数,跳转到当前文档之后的第num个记录
	 				如果num是负数,跳转到当前文档之前的第num个记录


		打开子窗口的父窗口为:opener 
		.window.focus()使当前的窗口在所有窗口之前. 

		window.location的属性: 
		protocol(http:),
		hostname(example.com),port(80),host(example.com:80),
		pathname("/a/a.html"),hash("#giantGizmo",指跳转到相应的锚记),
		href(全部的信息) 

	【window.location.reload();】在使用tap事件时,会重载刷新页面一次


→如何用js得到当前页面的url信息方法(JS获取当前网址信息)
1，设置或获取对象指定的文件名或路径。
	alert(window.location.pathname)

2，设置或获取整个 URL 为字符串。
	alert(window.location.href);

3，设置或获取与 URL 关联的端口号码。
	alert(window.location.port)

4，设置或获取 URL 的协议部分。
	alert(window.location.protocol)

5，设置或获取 href 属性中在井号“#”后面的分段。
	alert(window.location.hash)

6，设置或获取 location 或 URL 的 hostname 和 port 号码。
	alert(window.location.host)

7，设置或获取 href 属性中跟在问号后面的部分。
	alert(window.location.search)

8，获取变量的值(截取等号后面的部分)
 	var url = window.location.search;
	//    alert(url.length);
	//    alert(url.lastIndexOf('='));

	var loc = url.substring(url.lastIndexOf('=')+1, url.length);

9，用来得到当前网页的域名
	var domain = document.domain













事件流:【是从页面接受事件顺序】 


匀速动画:
	-运动公式:
元素位置 = 元素当前位置 + 位移速度(步进)
	元素.style.left/top = 元素.style.left/top + '10px'
	元素.style.left/top = 元素.offsetLeft + 10 + 'px'

	var x = e.page - div.offsetLeft; //偏移量差值
	var y = e.page - div.offsetTop; //偏移量差值

1.缓动运动方式
	元素位置 = 元素当前位置 + (target - 元素当前位置) / 10;

 	→※:共同点:改变函数体内this的指向 把一个对象替换当前对象
	 【apply()】 应用
		apply 额普来
		接收的是数组参数
	 【call()】  呼喊
		call  靠
		接受的是连续参数
	
	 函数调用的方法
	 参数:
	 	一个参数:两者无差别.调用函数的对象
	 	多个参数:有差别
	 			call- 第一个参数,对象.之后跟需要的参数,
	 				有几个放几个即可,逗号隔开
	 			apply-第一个参数,对象.第二个参数:数组


	【startX】开始X位置
	【startY】开始Y位置
	【endX】结束X位置
	【endY】结束Y位置
	【e.offsetX】当前位置
	【e.offsetY】当前位置
	若startX = e.offsetX 那就是从当前位置开始进行操作

	【instanceof】 检测实例与构造函数的关系
	【hasOwnProperty()】 检测某个属性是否为自身有的 原型
	【isPrototypeOf()】 检测实例与原型对象prototype的关系
	【in】 检测实例对象是否有某个属性
	【constructor】 原型对象指向其构造函数的


prototype原型


big大的
small小的

try努力
catch接住try


instanceof  属于 采用 立场
hasOwnProperty 有 这个 属性
isPrototypeOf 是 属于 属性
show展示
ball球
run进行,奔跑

play展示(比赛,演出)
stop停止

closure 闭包 永久关闭
unit单元 个体
current现在的
document.compatMode == "CSS1Compat")  // 声明的了 DTD
// 检测是不是怪异模式的浏览器 -- 就是没有 声明<!DOCTYPE html>
compatMode
Mode方式
CSS1Compat

fast快的
slow缓慢的

equal 相等的,均等的
cookie 家伙,人
result结果
step步进


resources 资源
application应用

total【总金额】图都
money【收款金额】马蒂
change【找零】橙汁

vertical-align:top;
vertical垂直

client顾客,客户端[当事人]


encodeURI()编码
decodeURI()解码
encodeURIComponent()编码
decodeURIComponent()解码

component成分,零件

===============================================================
【DOM事件】【事件】【DOM0级事件】【0级事件】[DOM0级事件][0级事件]
	
	→ 把事件处理程序写在标签行内,叫【HTML事件处理程序】
	 <input type="button" onclick="fn();"/>
	 事件三要素:
	 	事件源:按钮
	 	事件:点击(onclick),双击(ondblclick)
	 	事件处理程序:放在标签行内 -HTML事件处理程序

	→ 【DOM0级事件处理程序】:
	元素.onclick = function () {}
	 1.点击按钮,给当前页面创建一个宽高各位100px,背景颜色为红色的div
	 	事件三要素:
	 		事件源:按钮
	 		事件:点击
	 		事件处理程序:DOM0级事件
	→ 【window相关事件】
	 【onload事件】: load 加载
	 页面加载事件
	 页面中html,css加载完毕之后,再进行加载(js)
	 一个页面当中只能有一个onload事件

	window.onload = function () {
		//js所有代码
		console.log('onload页面加载事件');
	}
	
	//【onscroll事件】: onscroll滚动
	//页面滚动事件
	window.onscroll = function(){
		console.log('onscroll滚动事件');
	}
	
	 【onresize事件】 resize 缩放(改变大小)
	 页面缩放事件】
	window.onresize = function(){
		console.log('onresize缩放事件');
	}

	→ 鼠标事件
	 【onclick】单击事件
		【ondblclick】双击事件
		 
		【onmouseover】鼠标悬停事件
		【onmouseout】鼠标离开事件
		【onmousedown】鼠标按下事件
		【onmouseup】鼠标弹起事件

	→ 焦点事件:
	 【onfocus】:获取焦点事件,获取光标事件
	 【onblur】:失去焦点事件 失去光标
	【searchProductClassbyName】触发后调用的方法；
	$('#productName').bind('input propertychange', function() {searchProductClassbyName();}); 


	→ 键盘事件:
		【onkeydown】键盘键下事件 键盘按下事件
		【onkeyup】键盘键上事件  键盘松开事件 键盘离开事件
		【onkeypress】字符键键盘键入事件
	使用【e.keyCode】可获得当前按键的数字,可用于判断当满足条件时,触发某个事件
	比如
	if(this.value != ''){
		if(e.keyCode == 13){
			$('#my2').trigger('click');
		}
	}
	只有当input都有value值,按回车自动登录,触发button的跳转事件.

	→ 事件流:
	 页面接受事件的顺序
	 
	 →【冒泡事件流】:
	 	从内到外的过程
	 	div04=>div03=>div02=>div01=>body=>html=>document=>window

	用DOM2级来模拟捕获
		给当前按钮绑定单击事件,弹出内容,我是按钮
		给body绑定单击事件    		我是body
		给html绑定单击事件    		我是html
		给document绑定单击事件    		我是document
	→ 【捕获时间流】
		从外到内,捕获到最终目标
		document.html-body-div

	//给当前按钮绑定
	document.getElementById('btn').addEventListener('click',function () {
		alert('我是按钮');
	},true);
	
	//给body绑定
	document.body.addEventListener('click',function () {
		alert('我是body');
	},true);
	
	//给html绑定
	document.getElementsByTagName('html')[0].addEventListener('click',function () {
		alert('我是html');
	},true);
	
	//给document绑定
	document.addEventListener('click',function () {
		alert('我是document');
	},true);

	→ 【阻止冒泡】
	//每个事件都有一个事件对象 (事件的信息库)
		e.stopPropagation();//阻止冒泡 谷歌等浏览器

	//阻止函数的封装
	function stopBubble(Events){
		var e = event || window.event;
		if(e.stopPropagation){
			//谷歌等标准浏览器
			e.stopPropagation();
		} else{
			//IE
			e.cancelable = true;
		}
	}

	→ 【阻止默认行为】
	/封装阻止浏览器标签元素,默认行为 函数
	function $stopPro(Events) {
		var e = event || window.event;
		//考虑阻止行为
		if (e.preventDefault) {
			e.preventDefault()
		} else{
			e.returnValue = false;
		}
	}






【DOM2级事件】【DOM事件】【DOM二级事件】【js事件】【DOM2级事件】【2级事件】[DOM2级事件][2级事件][DOM2级事件][DOM二级事件][DOM事件][js事件]
	DOM2级事件处理程序
	 标准浏览器: 谷歌  火狐 参数事件 不带on
	 	绑定事件
	 		【事件源.addEventListener(事件,事件处理函数(署名函数/函数名),布尔值)】;
	 				布尔值:
	 					false 默认不填时,为false 冒泡执行程序
	 					true 捕获执行程序
	 	移除绑定事件
	 		【事件源.removenEventListener(事件,函数名,布尔值);】
	 	IE:参数:事件 带 on
	 	绑定事件
	 		【事件源.attachEvent(事件,事件处理函数(函数名));】
	 	移除事件:
	 		【事件源.detachEvent(事件,事件处理函数(函数名))】

示例:
	 点击div.输出其高度
	 DOM2级事件处理程序
	 事件源:addEventListener(事件,事件处理函数,布尔值);
	 事件:跟DOM0级事件区别为.去掉on
	 	true:捕获过程中处理
	 	false:冒泡过程中处理
	var myDiv = document.getElementById('my_div');
		myDiv.addEventListener('click',function () {
			console.log(getComputedStyle(this,null)['height']); //myDiv能替换成this
		},false)

====================================================================
[js样式][js获取样式]
	/*
    访问内部样式,外部样式[js样式]
            IE:元素.currentStyle.样式属性  == currentStyle['样式属性']
            其他浏览器:
            window.getComputedStyle(元素,null)['样式属性']

        行内样式:red,返回RGB()格式
                #00ffff 返回RGB()格式
        内部样式:返回RGB()格式
        外部样式:返回RGB()格式
     */
	function $getStyle(ele,attr) {
		//判断是哪种浏览器
			if(ele.currentStyle){
				return ele.currentStyle[attr];
			} else {
				return window.getComputedStyle(ele,null)[attr];
			}
	}

    /*
        封装获取字体颜色插件
        行内样式:red,直接返回red
                #00ffff 返回RGB()格式
        内部样式:返回RGB()格式
        外部样式:返回RGB()格式
        IE

     */
    function $getStyle2(element,property) {
    　　var value = element.style[property];
    　　if(!value) {
    　　　　if(document.defaultView && document.defaultView.getComputedStyle) {
    　　　　　　value = document.defaultView.getComputedStyle(element).getPropertyValue(property);
    　　　　} else if(element.currentStyle) {
    　　　　　　value = element.currentStyle[property];
    　　 　　}
    　　}
     
    　　return value;
    }
//====================================================================
	
	 【currentStyle】IE下获取样
	 【window.getComputedStyle(ele,null)[attr]】标准浏览器获取样式



	 js操作css样式
	 设置css样式:
	 元素.style样式属性 = 属性值
	 font-size:background-color,text-align == > 驼峰命名法
	 fontSize 
	 
	 访问css样式属性
	 	访问 行内样式属性
	 		元素.style.样式属性
	 		元素.style['样式属性']
	 	访问内部样式,外部样式
	 		IE:元素.currentStyle.样式属性  == currentStyle['样式属性']
	 		其他浏览器: 
	 		window.getComputedStyle(元素,null)['样式属性']
	 */
	
	//1.获取第一个li的背景颜色,以及第二个li的字体大小
	//先获取li
/*	var ul =  document.getElementsByTagName('ul')[0];
	var lis = ul.children;
	console.log(lis[0]);
	*/
	
	var lis =  document.getElementsByTagName('li');
	console.log(lis[0].style.backgroundColor); //red
	console.log(lis[1].style['fontSize']); //30px
	
	//2.获取第三个li的宽
	console.log(window.getComputedStyle(lis[2],null)['white']);
	 //150px
	//3.获取ul的border样式
	console.log(window.getComputedStyle(lis[0].parentNode,null)['border']);
	
	//设置行内样式 
	//统一:不管是哪种样式表,设置方式都是统一的
	//元素.style.样式属性 = 属性值;
	//元素.style['属性'] = 属性值;
	lis[0].style.color = 'wheat';
	console.log(lis[0].style.color);














	点击第一个按钮的时候，弹出该按钮的type类型
	 	事件源：第一个按钮
		事件：click
	 	事件处理程序：弹出该按钮的type类型  DOM2级处理程序

	btn1.addEventListener("click",fn);
	function fn () {
		console.log(btn1.type);
	}

	btn2.addEventListener("click",function(){
		//删除第一个按钮的绑定事件 并且弹出第二个按钮的type类型
		//删除第一个按钮的绑定事件
		btn1.removeEventListener("click",fn);
		//弹出第二个按钮的type类型
		alert(btn2.type);
	});

	HTML5对于触屏设备的单点触控提供了touchstart,touchend,touchmove和touchcancel四种事件
	1.1 一些技术细节
	PC就不说了,这里只说Android和IOS.
	HTML5对于触屏设备的单点触控提供了四种事件.而通过测试表明,一旦监听了者四种事件中的任意一种,很多设备将不会触发click事件.这样的话,要想实现拖拽和点击两种交互操作,就只能通过上面一组touch事件夹组成.我们使用的是以下的方案
		touch触摸
	【touchstart】【点击开始】
	【touchend】touchstart>touchend【点击结束】
		start开始
		end结束
	【touchmove】touchstart>touchmove(多个)>touchend【拖拽】
	【toucancel】touchstart>toucancel【拖拽】
		move移动
		cancel取消
	【touchend】touchmove(多个)>touchcancel【划过】
	【touchend】touchmove(多个)>touchend【划过】
	※:必须使用js二级时间才能使用

	
【触摸事件】【触屏事件】

===============================================================
【正则表达式】[正则表达式][正则]

/^[0-9]$/字面量创建
new RegExp(参数,参数2)

在开头^是开始
	【$】是结束
	【^&】表示一个空行 ^.*&匹配全文内容,找到单独一行^.*?$
	【.】是任意字符
	【^】非
	【|】或
	【{}】一个数字是限制长度,两个是＜=多少,＞=多少
	【\d】代表0-9 匹配任意一个数字
	\D代表非0-9 匹配任意一个非数字 [^0-9A-Za-z]
	【\w】匹配一个数字或字母字符[0-9A-Za-z_]包括下划线
	【\s】代表一个空字符(空格,制符表,回车或换行)
	【\b】表示一个单词分隔符 \b\w\w\w\b 匹配三字符单词


	【/i】ignorCase忽略大小写
	【/m】mutiple忽略大小写允许多行匹配
	【/g】globle进行全局匹配,指匹配到目标串的结尾
	
	【{1,}】至少一个或一个以上
	【.{0,}】表示匹配任意内容,包括空格
	【(red)|(blue)】分组可以匹配空字符串,表示匹配red或blue或是空字符串

转义字符
	【-】横杠代表范围,比如0-9 a-z A-Z
	【?】和(0,1)相同,比如colou?r,匹配colour或clolor
	【*】和{0,},比如.*表示匹配任意内容
	【+】与{1,}相同,比如\w+表示匹配一个词.有一个或一个以上字符组成,比如_var或AccountName1.

	【\】转义字符,可以转义元字符.*\&#@!^()[]【】
	【{[abc]}\1】表示只匹配aa或者bb或者cc.

	【exec()】返回一个数组,其中存放匹配的结果,如果未找到匹配,则返回值为null
	比如reg.exec(pathname)[1].toLowerCase()
	


	【str = str.replace(/-/g,'/');】 // 将-替换成/，因为下面这个构造函数只支持/分隔的日期字符串


【把\n替换成br】
	infoTag.innerHTML=item.info.replace(/\n/g,"<br/>");

总结
	字符: a b c d 1 2 3 4 etc.
	字符类: . [abc] [a-z] \d \w \s
	. 代表任何字符
	\d 表示“数字”
	\w 表示”字母”, [0-9A-Za-z_]
	\s 表示 “空格, 制表符,回车或换行符”
	否定字符类: [^abc] \D \W \S
	重复: {4} {3,16} {1,} ? * +
	? 表示 “零次或一次”
	* 表示 “大于零次”
	+ 表示 “一次或一次以上”
	如果不加上？，所有的重复都是最长匹配的（贪婪）
	分组: (Septem|Octo|Novem|Decem)ber
	词，行以及文本的分隔: \b ^ $ \A \z
	转义字符: \1 \2 \3 etc. (在匹配表达式和替换表达式中都可用)
	元字符: . \ [ ] { } ? * + | ( ) ^ $
	在字符类中使用元字符: [ ] \ - ^
	使用反斜杠可以忽略元字符: \
	
致谢

正则表达式非常常用而且非常有用。每个人在编辑文本或是编写程序时都必须了解怎样使用正则表达式。

// \ 转义字符,将下一个字符转换成为一个特殊字符或一个原义字符
		//例如'n'匹配原义字符"n"。'\n'匹配特殊字符换行符; "[]"匹配特殊字符[],而"\[\]"则匹配原义字符"[]"。
	


		// . 匹配除换行符外的任意字符
		// [a-z0-9] []是字符集合，表示匹配方括号中所包含的任意一个字符, -表示字符范围。匹配指定范围内的任意一个字符. 这里表示匹配a到z或0到9(即所有的小写字母或数字)中的任意一个字符   注意!!!!是一个字符!
		// [^a-z0-9] []中的^表示非,这里表示匹配除了a-z和0-9(即除了所有的小写字母或数字)以外的任意一个字符
		// \d 匹配数字,效果同[0-9]
		// \D 匹配非数字,效果同[^0-9]
		// \w 匹配数字,字母,下划线,效果同[0-9a-zA-Z_]
		// \W 匹配非数字,字母,下划线,效果同[^0-9a-zA-Z_]
		// \s 匹配任何空白字符，包括空格、换页符、换行符、回车符、制表符等等。等价于[ \f\n\r\t]。
		// \S 匹配非空字符,等价于[^ \f\n\r\t]

		// ^ 行首匹配 和 在[]字符集和中的 ^ 不是一个意思。
		// $ 行尾匹配

		下的x,y,z均为假设的普通字符,不是正则表达式元字符*/
		//(xyz) 匹配括号内的xyz(作为一组整体去匹配)
		//x?  匹配0个或1个x  0/1
		//x*  匹配0个或者任意多个x   延伸: .* 表示匹配0个或者任意多个任意字符  >=0
		//x+  匹配至少一个x  >=1
		//x{n}   匹配确定的n个x (n是一个非负整数) =n
		//x{n,}  匹配至少n个x (n是一个非负整数) >=n
		//x{n,m} 匹配至少n个,最多m个x (n,m是非负整数,n<=m) >=n <=m
		//x|y |表示或 ,这里指匹配x或y

验证邮箱
	this.value == '' || (this.value != '' && !/.+@.+\.[a-zA-Z]{2,4}$/.test(this.value))




js 去掉空格
Jquery:
$("#accuracy").val($("#accuracy").val().replace(/\ +/g,""));//去掉空格
$("#content").val($("#content").val().replace(/[ ]/g,""));    //去掉空格
$("#content").val($("#content").val().replace(/[\r\n]/g,""));//去掉回车换行
js:
var testStr="sssss

vvvvv";
var resultStr=testStr.replace(/\ +/g,"");//去掉空格
resultStr=testStr.replace(/[ ]/g,"");    //去掉空格
resultStr=testStr.replace(/[\r\n]/g,""));//去掉回车换行
===============================================================
【面向对象】
		在Javascript里，对象的属性和方法有4种不同的类型，
		第一种是前面的私有类型，要访问它们，要设置特定的“获取者（getter）”和“设置者(setter)”，如前面得geta()可以得到a，
		第二种是动态的公有属性。如前面的list对象有a这个实例，也有b这个实例，a.a与b.a是不同的，修改a.a自然不会改变b.a。
		第三种是原型属性，它是静态公有属性，所有的实例都共享这个属性，只要在类中改变原型属性，所有的实例的这个属性也跟着改变。
		第四种是类属性，在没有构造类的实例（对象）时也能访问。下面的例子说明了4种属性各自的特点和区别：	在Javascript里，对象的属性和方法有4种不同的类型，
		第一种是前面的私有类型，要访问它们，要设置特定的“获取者（getter）”和“设置者(setter)”，如前面得geta()可以得到a，
		第二种是动态的公有属性。如前面的list对象有a这个实例，也有b这个实例，a.a与b.a是不同的，修改a.a自然不会改变b.a。
		第三种是原型属性，它是静态公有属性，所有的实例都共享这个属性，只要在类中改变原型属性，所有的实例的这个属性也跟着改变。
		第四种是类属性，在没有构造类的实例（对象）时也能访问。下面的例子说明了4种属性各自的特点和区别：


	1.动态共有属性 比原型属性优先级高
	2.静态私有属性 需要回调函数来访问
	3.property原型属性,所有实例共享这个属性 但只能添加,无法修改,一旦修改就创建了同名共有属性
	4.静态属性 直接在构造函数名后加.点增加属性,这个属性只能在函数内才能使用.使用回调
		比如在声明一个函数
	function dwn(s){
   		 document.write(s +"<br/>")
  	}
	把构造函数变量名加点静态属性就可访问
		比如dwn(myclass.z)

	 delete(a.x) //删除对象属性

	PS:如果有同名的公有属性和原型属性,那么删除公有属性,再调用这个属性,那么就会返回未删除的原型属性

	既然自己创建的类有原型属性，那么Javascript内置的类——String、Date是否可以添加属性和方法呢，答案是——可以！
	
	String.prototype.属性 = function(){alert('这是个字符串')} //现在支持以中文为属性名
	var a = new String('123');
	console.log(a); //123
	a.属性(); //这是个字符串

【变量名,函数名,对象属性名】都可以使用中文,但必须是UTF-8编码才行,但变量千万不要加,和句号,混合其他符号只有IE支持,其他浏览器不支持



===============================================================
【对象】【object】[对象][object]
 	对象:一切皆为对象 工具包 object
	 oo - object oriented 面向对象
	 面向对象: 狗 吃 屎	对面向过程的 封装
	 面向过程:吃 狗 屎 	以前写的代码,一步一步来完成代码,从而实现功能

	封装/继承/多态/

	//对象:一系列属性的属性的集合.属性 对应的 会有值 -属性值
	//属性值 数据类型可以是多种.字符创,数值,布尔值等.函数,对象
	
	//字面量的方式 创建一个简单对象

	//字面量的方式 创建一个简单对象
	var obj = {
		name : '张博',
		age : 18,
		say : function (){1
			console.log('张博爱吃肉');
		}
	};
	/*
	 属性 属性值 - 键值对
	 键值对之间用逗号隔开,最后一个键值对不需要逗号
	 属性与属性值之间冒号 隔开
	 */
	
	//访问属性值
	
	/*
	 	全局作用域下,仅有一个变量obj,而其他变量都放在了对象的内部,不会污染全局
	 	也不会被全局污染
	 */
/*	try{
		console.log(age);
	} catch(e){
		alert(e)
	}*/


	/*
	 	构造函数方式创建
	 	构造函数 是 函数. 与普通函数区别: 函数名首字母大写 即为构造函数
	 	其他编程语言 都有类的概念.js用构造函数来模拟类
	 */
		function person(name,age) {
			this.name = name;
			this.age = age;
			this.say = function () {
				console.log('我叫' + this.name + ',我今年' + this.age)
			}
		}
		//创建对象: new + 构造函数
		//构造函数  跟具体对象之间是一对多 对象又可以叫做实例
		var person1 = new person('名称',16);
		console.log(person1.name); //名称
		console.log(person1.age); //16
		person1.say(); //我叫名称,我今年16
		
		var person2 = new person('名称2',14);
		console.log(person2.name); //名称2
		
		var person3 = new person('名称3',18);
		console.log(person3.name); //名称3
		person3.say(); //我叫名称3,我今年18
		
		/*
			 第三种方式
			 工厂模式
		 */
		function factory(name,age) {
			var obj = {};
			obj.name = name;
			obj.age = age;
			obj.say = function () {
				console.log('我叫' + obj.name + ',我今年' + obj.age)
			}
			return obj;
		}
		
		var MrTang = factory('姓名',30);
		console.log(MrTang.name); //唐瑞
		MrTang.say(); //我叫姓名,我今年30


	//用来检测 某个对象是不是构造函数的实例
	console.log(cat instanceof Animal);


======================================================	
  //自定义添加方法,能够自定义匿名函数,,自动生成对象命名空间的函数,提高之后的效率
    //新建对象
    var Global = {};
        (function(){
            Global.nameSpace = function(lowerObj){ 
            var arr = lowerObj.split(".");
            var  obj = Global; 
            for(i = arr[0] == "Global" ? 1 : 0; i < arr.length;  i++){ 
                obj[arr[i]] = obj[arr[i]] || {}; 
                obj = obj[arr[i]]; 
            }
            var newArr = arr.join('.');
            return newArr;
            }
            //以下设置自定义属性和方法
            var a = 123, 
                a1 = "hello world"; 
            Global.nameSpace("A.CAT"); 
            Global.nameSpace("A.DOG"); 
            Global.A.CAT.name = "mini"; 
            Global.A.CAT.move = function(){ 
            } 
            Global.A.DOG.name = "mini"; 
            Global.A.DOG.move = function(){ 
            } 
            Global.A.str = a; 
            Global.A.str1 = a1; 
        })();
    console.log(Global.A.CAT.name);



【原型】
	
	每个函数对象都有一个原型prototype,它的值是一个对象
	对已把这个值, 对象 叫原型对象
	//创建构造函数
	function Animal (name){
		this.name = name;
	}
	var dog = new Animal('泰迪');
	console.log(typeof Animal);
	console.log(typeof dog);
	
	/*
		 每个函数对象都有一个原型prototype,它的值是一个对象
		 对已把这个值, 对象 叫原型对象
		
	 */
	function Person(name,age) {
		this.name = name;
		this.age = age;
	}
	//给构造函数原型对象添加属性 扩展属性
	Person.prototype.height = '180cm';
	Person.prototype.say = function (food) {
		console.log('我叫:' + this.name + ',我喜欢吃' + food);
	};
	
	var person = new Person('姓名',18);
	//原型对象的属性,实例也可以访问
	console.log(person.height);
	person.say('萝卜');
	
	//关键字使用
	//hasOwnProperty()检测每个属性是否为自身就有,如果是,返回值是true,如果是原型对象的属性,返回值是false
	console.log(person.hasOwnProperty('name'));//true
	console.log(person.hasOwnProperty('age'));//true
	console.log(person.hasOwnProperty('height'));//false
	console.log(person.hasOwnProperty('say'));//false

	//isPrototypeOf() 实例 原型对象 关系
	console.log(Person.prototype.isPrototypeOf(person));//false
	
	//指针的概念
	//构造函数有原型 构造函数可以创造对象
	//实例对象通过指针(__proto__)指向的是其构造函数的原型对象
	console.log(person.__proto__);
	console.log(Person.prototype);
	console.log(person.__proto__ === Person.prototype); //true
	
	//constructor 原型对象指向构造函数
	console.log(Person.prototype.constructor);


//关键字使用
	//hasOwnProperty()检测每个属性是否为自身就有,如果是,返回值是true,如果是原型对象的属性,返回值是false
	console.log(person.hasOwnProperty('name'));//true
	console.log(person.hasOwnProperty('age'));//true
	console.log(person.hasOwnProperty('height'));//false
	console.log(person.hasOwnProperty('say'));//false



【cookie】
cookie记录 客户端与服务器端进行会话时使用的 记录
expires期满,失效


	什么是session?
	session是一种记录客户状态的机制,不同的是Cookie保存在客户端浏览器中,而session保存在服务器上
	客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了
		
	## cookie与session区别
    - 1: cookie数据存放在客户的浏览器上，session数据放在服务器上。
    - 2: cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session
    - 3: session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面,应当使用COOKIE
    - 4: 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
    > 将登陆信息等重要信息存放为session、其他信息如果需要保留，可以放在cookie中
    
    ## session实现
    - 1: 在服务器端生成全局唯一标识符session_id
    - 2: 在服务器内存里开辟此session_id对应的数据存储空间
    - 3: 将session_id作为全局唯一标示符通过cookie发送给客户端
    - 4: 以后客户端再次访问服务器时会把session_id通过请求头中的cookie发送给服务器
    - 5: 服务器再通过session_id把此标识符在服务器端的数据取出




//获取当前的cookie记录信息
	console.log(document.cookie);
	//当前获取发现没有cookie,因为还没有设置
	
//设置cookie
	/*document.cookie = 'name=lily';
	console.log(document.cookie);*/
	/*关闭浏览器之后,再次打开浏览器,发现之前设置的cookie不存在了,他仅仅存在于会话期间.session
	 如果想让他继续存在,需要设置有效时间
	  */
	 
	 //expires=失效时间

//创建了一个日期对象
	 var date1 = new Date();
	 //创建了一个30天后的日期对象
	 date1.setDate(date1.getDate() + 30);
	document.cookie = 'name=yonghu;expires=' + date1;
	console.log(document.cookie);


/*
	 设置日期
	 */
	var date1 = new Date();
	//
	date1.setDate(date1.getDate() + 30);
	console.log(date1.getFullYear() + '年' + (date1.getMonth() + 1) + '月' + date1.getDate() + '日')



	//直接可以访问这其中的某一个cookie
	function $getCookie(name) {
		//读取cookie
		var arr = document.cookie.split('; ');
		//数组进行遍历 访问元素
		for(i = 0; i < arr.length; i++){
			var newArr = arr[i].split('=');
			//当前newArr中有两个元素
			//判断是否为用户想要的那个名字 name
			if(newArr[0] == name){
				return newArr[1];
			}
		}
		return '没找到此用户名'; //提示用户没找到
	}

	//自己设置cookie 添加 函数
	function $setCookie(name,val,time) {
		var date1 = new Date();
		date1.setDate(date1.getDate() + time);
		//设置添加cookie
		document.cookie = name + '=' + val + ';expires=' + date1;
	}

	//删除cookie
	 function $removeCookie(name) {
	 	setCookie(name,'1',-1);
	 	//把时间变为之前的时间,从而实现失效的功能
	 }



【JSON】[json] (JavaScript Object Notation) 是一种轻量级的数据交换格式
	http://www.JSON.org/js.html
	//使用eval()】来执行字符串里的JS代码
		解析JSON字符串,让他变成javascript代码
	PS:【eval()】不安全
		eval("(" + jsonstr + ")");
			"()":告诉eval 将 jsonstr当做json数据来解析
	/*
	json:轻量级的数据格式 map
	 json 值 可以是多重的.简单值,数组,对象
	 JSON 对象提供的两种方法
		ps:IE8下不支持json对象,需要开源下载【json.js】
	【parse()】把json字符串转换成js的原生值(js可识别的数据类型)
			解析:将json字符串转换为json格式的数据
		也可以放第二个参数,使用数组限定查询内容
		【JSON.parse()】
	【stringify()把原生值转换成json字符串格式
			序列化:将json格式数据转换json字符串
		可以放三个参数
	第二个参数可以放数组,选取自己需要的内容,也可以写null,把原数组输出
	第三个参数可以放数字和字符串来增加缩进,建议使用4来更改
		toStrong: function(){
			return this.title;
		}
	如果数组内有对象toStrong,会忽略其他,只执行这句
	
比如:
	var box = [
		{
		title : 'a',
		num : 1,
		height : 177
		},
		{
		title : 'b',
		num : 1,
		height : 188
		}
	]

	var json = JSON.stringify(box,function(){
	if(key == 'title){
		return 'My' + value;
	} else{
		return value;
	}
	});
	【传两个参数】
	var json = JSON.stringify(box,['title,''num'])
	
	【传三个参数】
	var json = JSON.stringify(box,['title,''num'],4)
	var json = JSON.stringify(box,['title,''num'],'----')
	var json = JSON.stringify(box,null,4)

	 */
	var jsonstr = '{"name":"xingming","age":"80"}';
	console.log(jsonstr.name);

	//输入JSON对象
	console.log(JSON);

	//转换
	var jsonObj = JSON.parse(jsonstr);
	console.log(jsonObj);
	console.log(jsonObj.name);

	//转回到json串域名
	var jsonStr = JSON.stringify(jsonstr);
		console.log(jsonstr);

	provinces 省份
	cities 城市

两种解析json数据方法:
	第一种: 【JSON.parse(这里获取json文件变量);】
	第二种:【eval("(" + 这里获取json文件变量 + ")");】
	var jsonStr = '{"name" : "张三","age" : "23"}';
	var obj = eval("(" + jsonStr + ")"); //将字符串解析为json格式数据
	var a1 = JSON.parse(jsonStr);
	console.log(obj); //Object {name: "张三", age: "23"}

	JSON:帮助我们解析数据为json数据
	解析:将json字符串转换为json格式的数据
	序列号:将json格式数据转换json格式的数据
	※注:若浏览器不支持JSON对象,那么使用eval
		或者到网络下载json.js
		http://www.JSON.org/js.html



【Ajax】[ajax]
	AsynchronsusJavaScript and XML
		中文名:异步的JavaScript 和 XML
	概述(作用):【使用Ajax技术不必刷新整个页面,只需对页面的局部进行更新,所以又称为局部刷新技术】 

 	ajax 和 jsonp
        ajax 是获取数据,支持同源请求
        jsonp 也是获取数据,支持跨域请求

        同源:协议名 域名 端口必须统一

        jsonp的原理:
        1.使用script 不受同源策略的影响
        2.在当前项目(HTML页面中),创建一个自定义函数fn
        3.将请求的url地址 放在script标签中src属性中,并在该url末尾添加自定义函数的函数名(url&callback=fn)
        4.服务端接收到请求以后,将url路径当中自定义函数 解析出来(fn) 将客户端所需要的数据 和 自定义函数(fn) 进行拼接 fn(data)
        5.客户端接收服务端的数据以后,自动调用自定义方法函数获取数据

异步
	engine引擎
	server服务员,侍者
	activity活动
	request请求,需要
	Microsoft微软

get和post的区别:
	1.get安全性低,post安全性高
	2.get获取数据,post提交数据
	3.get传输数据量小,post传输数据量大

Ajax主要几步骤:
	创建
	var ajax = new XMLHttpRequest();
	请求参数
	ajax.open('get','baidu',true);
	发送请求
	ajax.send();
	监听
	ajax.onreadystatechange = function(){
	
	}

POST多一步骤,需要设置请求头,在创建XML之后添加
ajax.setRequestHeader('Content-type','application/x-www-form-urlencoded');

1.[jsonp]什么情况造成跨域
	1.协议
	2.主域名
	3.子域名
	4.端口号
	5.IP和域名不同

2.ajax请求有哪些状态码:
	状态码:
	500以上都是服务器问题
	
	200 ok 服务器成功返回了页面
	400 Bad Request 语法错误导致服务器不识别
	401 Unauthorized 请求需要用户认证
	404 Not found 未找到页面,指定的URL在服务器上找不到
	500 Intemal Server Error 服务器遇到意外错误,无法完成
	503 ServiceUnavailable 由于服务器过载或维护导致无法完成请求

	  1xx 1开头表示消息,这类开头的状态码,代表请求已经被接收,需要继续处理
          2XX 2开头表示成功,这一类型的状态码.代表请求已成功被服务器接收,理解,并接受
          3XX 3开头表示重定位,这类状态码代表需要客户端采取进一步的操作才能完成请求
          4XX 4开头表示请求(客户端)错误,这类的状态码代表了客户端看起来可能发生了错误,妨碍了服务器的处理.
          5xx 5开头表示服务器错误,这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生,也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理.



onreadystatechange
	on向
	ready预备
	state国家
	change改变

	Active积极的


ajax.send送出
status 地位,身份 状态码
如果用post请求方式,就需要设置 请求头
ajax.setRequestHeader('Content-type','application/x-www-form-urlencoded');
Header标头

responseText 反应
	/*
	 创建ajax对象
	 但是其有兼容性,所以需要首先进行兼容处理
	 */
	var ajax;
	if(window.XMLHttpRequest){
		//标准浏览器
		ajax = new XMLHttpRequest();
	} else{
		//IE5 IE6
		ajax = new ActiveXObject('Microsoft.XMLHTTP');
	}
	//三目运算符书写格式也可
	var ajax = (window.XMLHttpRequest) ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');




/*
		1.创建ajax对象
		2.初始化请求
		3.发送请求
	 */

	//创建ajax对象
	var ajax;
	if(window.XMLHttpRequest){
		ajax = new XMLHttpRequest;
	} else{
		ajax = new ActiveXObject('Microsoft.XMLHTTP')
	}
	//console.log(ajax);

	//初始化请求
	//ajax对象的open()

	/*
		三个参数
		请求方式:GET / POST
		url : 请求的文件在服务器上 的位置
		是否异步async: true(异步) / false(同步)

		GET:数据小,传输速度快
		POST:数据大,传输速度慢

		GET:如果有参数要传递给服务器,参数拼接在url上 不安全
		POST:如果有参数,单独打包传递给服务器.安全
	*/

	ajax.open('GET','1.json',true);

	//发送请求
	//ajax对象的send()
	//如果请求方式为GET,那么发送方法内无参数,或者参数为null
	ajax.send(null);

	//ajax对象 触发 监听服务器状态的一个事件 onreadystatechange
	//readyState 监听状态 5值
	//0: 请求未初始化
	//1:服务器已建立连接
	//2.请求接收
	//3.请求处理
	//4.请求处理完毕,响应就绪

	//ajax对象继续监听 status 状态码
	//200 ok
	//404 未找到页面

	ajax.onreadystatechange = function () {
		//监听 判断 当前redayState status
		if(ajax.readyState == 4 && ajax.status == 200){
			//对于服务器返回的数据进行接收并处理
			//接收的数据,常见的是xml json
			//通过网络传输回的一般都是json串
			//ajax对象中的responseText
			console.log(ajax.responseText)
		} else{
			document.write('对不起,出错了 <br>');
		}
	}


/*
	 	初始化请求时:
	 	open()
	 	GET
	 	如果有参数,各参数之间用&进行分隔
	 	?之后跟的是参数,各参数之间用&进行分隔
	 */
	var ajax = window.XMLHttpRequest ? new XMLHttpRequest():  new ActiveXObject('Microsoft.XMLHTTP');
		//带有参数
		var data = 'name=xingming&age=90';
		//var Url = '1.json?' + data;
		ajax.open('GET','1.json?' + data,true);

		//发送请求
		ajax.send();
		ajax.onreadytatechange = function () {
			if(ajax.readyState == 4 && ajax.status == 200){
				//
				console.log(ajax.responseText)
			}
		}



var ajax = window.XMLHttpRequest ? new XMLHttpRequest():  new ActiveXObject();

	//如果用post请求方式,就需要设置 请求头
	ajax.setRequestHeader('Content-type','application/x-www-form-urlencoded');
	//如果请求的同时
	var data = {
		name : 'xingming',
		address : 'zPark'
	};
	//初始化请求
	ajax.open('POST','1.json' + data,true);

	//发送请求 同时把参数进行传递
	ajax.send(data);

	//监听状态
	ajax.onreadytatechangge = function () {
		if(ajax.readyState == 4 && ajax.status == 200){
			console.log(ajax.responseText);
		}
	}

三个参数
	请求方式:GET / POST
	url : 请求的文件在服务器上 的位置
	是否异步async: true(异步) / false(同步)

	GET:数据小,传输速度快
	POST:数据大,传输速度慢

	GET:如果有参数要传递给服务器,参数拼接在url上 不安全
	POST:如果有参数,单独打包传递给服务器.安全

//发送请求
	//ajax对象的send()
	//如果请求方式为GE,那么发送方法内无参数,或者参数为null

//ajax对象 触发 监听服务器状态的一个事件 onreadystatechange
	//readyState 监听状态 5值
	//0: 请求未初始化
	//1:服务器已建立连接
	//2.请求接收
	//3.请求处理
	//4.请求处理完毕,响应就绪

	//ajax对象继续监听 status 状态码
	//200 ok 服务器成功返回了页面
	400 Bad Request 语法错误导致服务器不识别
	401 Unauthorized 请求需要用户认证
	404 Not found 未找到页面,指定的URL在服务器上找不到
	500 Intemal Server Error 服务器遇到意外错误,无法完成
	503 ServiceUnavailable 由于服务器过载或维护导致无法完成请求

	xhr.abort(); 取消异步,放在send前会报错,应该放在send后面
	xhr.getAllResposeHeaders() 获取全部响应头信息
	xhr.getResposeHeader('Content-Type') 获取单个响应头信息
	//设置请求头信息,一般没什么用,在post提交请求有用
	xhr.setRequestHeader('Myheader','Lee'); //在open下设置


	var url = 'demp.php?rand' = Math.random();
	

	xhr.open('post', url, true);	//第一步改为post
	xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');//第三步，模拟表单提交
	xhr.send('name=Lee&age=100');//第二步将名值对放入send方法里


	obj.success(xhr.responseText)回调传递参数
	{}
	success【成功】


	province省份
	city城市


	readystate 
	status 状况
	success成功
	error错误
	responseXML || ajax.responseText
	response反应回答



==================ajax简单封装====================================
	function ajax (url,method,success,error,data) {
		//创建一个ajax
		var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");

		//声明两个空串
		var str1 = "";
		var str2 = "";

		//初始化 method 转换为大写
		var me = method.toUpperCase();

		//data 参数 一个对象

		//对data遍历
		for (var i in data) {
			str1 += i + "=" + data[i] + "&";
		}
		//多一个&符号
		str1 = str1.substring(0,str1.length - 1);

		//判断请求方式 从而对应 请求参数的位置
		if (me == "GET") {
			if (data) {
				//设置url 参数要拼接在url后
				url = url + "?" + str1;
			}

		} else {
			//post请求方式
			str2 = str1;
		}


		//初始化请求
		ajax.open(me,url,true);
		//发送请求
		ajax.send(str2);

		//监听
		ajax.onreadystatechange = function () {
			//判断是否响应成功
			if (ajax.readyState == 4 && ajax.status == 200) {
				if (success instanceof Function) {
					success(ajax.responseText || ajax.responseXML);
				}
			} else if (ajax.readyState == 4 && ajax.status == 404) {
				error(ajax.status);
			}

		}
	}


	//调用ajax函数来进行验证
		ajax("1.json","GET",function(result){
			var obj = JSON.parse(result);
			console.log(obj);
		},function(val){
			alert(val);
		});





//====================================================================
	//封装放大镜效果
	/*
	 minDiv是小的div,里面放img和遮罩层的div 设置position:relative;最外层div同样需要相对定位
	 movaDiv是遮罩层  设置position:absolute;绝对定位 top/left都为0
	 maxDiv是存放大图片的div 宽高计算公式是【大图宽 / 小图宽 * 遮罩层宽度】得到大div的宽高,设置overflow:hidden和display:none
	 maxImg是大图片
	 */
	function $mirror(minDiv,moveDiv,maxDiv,maxImg) {
			//鼠标悬停事件
			minDiv.onmouseover = function () {
				//出现遮罩层 大盒子
				moveDiv.style.display = 'block';
				maxDiv.style.display = 'block';
			}
			//鼠标离开事件
			minDiv.onmouseout = function () {
				//消失
				moveDiv.style.display = 'none';
				maxDiv.style.display = 'none';
			}
			//鼠标移动
			minDiv.onmousemove = function (event) {
				//事件处理兼容处理
				var e = event || window.event;
				//监听鼠标位置 遮罩层跟随鼠标移动
				/*
				 要点一:e.pageX - small.parentNode.offsetLeft就是当前坐标减去,返回父级box左侧位置,就能够得到鼠标当前移动遮罩层位置
				 要点二:mask.offsetWidth / 2  之所以要除2,就是盒子当前坐标在遮罩层最左侧,为了让遮罩层光标停留中心,需要再减去遮罩层1/2
				Y轴和X轴相同计算
				 */
				var x = e.pageX - minDiv.parentNode.offsetLeft - moveDiv.offsetWidth / 2;
				var y = e.pageY - minDiv.parentNode.offsetTop - moveDiv.offsetWidth / 2;
				if(x < 0){
					x = 0;
				} else if(x > (minDiv.offsetWidth - moveDiv.offsetWidth)){
					x = minDiv.offsetWidth - moveDiv.offsetWidth;
				  }
				if(y < 0){
					y = 0;
				} else if(y > (minDiv.offsetHeight - moveDiv.offsetHeight)){
					y = minDiv.offsetHeight - moveDiv.offsetHeight;
				  }
				moveDiv.style.left = x + 'px';
				moveDiv.style.top = y + 'px';
				//大图片跟随显示
				//比例问题 800 / 350不是最精准
				//(大图片宽减去一半的图片盒子宽度) / (小图片相同宽高盒子减去一半的遮罩层宽度),为了得到他们 的尺寸对比
				var xx = (maxImg.offsetWidth - maxDiv.offsetWidth) / (minDiv.offsetWidth - moveDiv.offsetWidth);
				//给大图片做位置确定
				/*
				 	从从右下移动,所以要用负值,乘与宽高是为了得到精确遮罩层位置,从而确定大盒子的位置,最终实现放大镜的效果
				 */
				maxImg.style.marginLeft =  -xx * x + 'px';
				maxImg.style.marginTop = -xx * y + 'px';
			}
		}
//===================================放大镜效果=========================================
	//包围容器
  	var zoomContent  = document.querySelector('.zoom-content'),
  		//左侧显示图片div
  		moveZoom = document.getElementById("J_moveZoom"),
  		//显示放大图片div
  		bigBox = document.getElementById("J_moveImg"),
  		//右侧显示图片
  		bigImg = bigBox.getElementsByTagName("img")[0],
  		//移动遮罩层
  		moveLayer = document.getElementById('J_moveLayer');

  		//光标移入图片,显示遮罩层和大图
		moveZoom.addEventListener('mouseover',function () {
				jq.show(moveLayer);
				jq.show(bigBox);
		})

		//光标移出图片,隐藏遮罩层和大图
		moveZoom.addEventListener('mouseout',function(){
				jq.hide(moveLayer);
				jq.hide(bigBox);
		})

		//鼠标移动,遮罩层居中,并和显示图片位置对应
		moveZoom.addEventListener('mousemove',function (e) {
				var e = event || window.event;
				var left = e.pageX - zoomContent.offsetLeft - moveLayer.offsetWidth / 2;
				var top  = e.pageY - zoomContent.offsetTop - moveLayer.offsetHeight / 2;
					maxLeft =  moveZoom.offsetWidth - moveLayer.offsetWidth;
					maxTop = moveZoom.offsetHeight -  moveLayer.offsetHeight;
					//判断遮罩层移动到临界点
					left = left < 0 ? 0 : left;
					left = left > maxLeft ? maxLeft : left;
					top = top < 0 ? 0 : top;
					top = top > maxTop ? maxTop : top;
					moveLayer.style.left = left + 'px';
					moveLayer.style.top = top + 'px';
			 	//对应大图位置
			 	//left(位移距离) 乘以(图片实际宽度 )除  (图片框的宽度)
//			 	bigImg.style.left = -((left * bigImg.offsetWidth) / bigBox.offsetWidth) + 'px';
			 	//top(位移距离) 乘以 (图片实际高度) 除 (图片框的高度)
//			 	bigImg.style.top = -((top * bigImg.offsetHeight) / bigBox.offsetHeight) + 'px';
			 	//整改
			 	bigImg.style.left = -left * (bigImg.offsetWidth / bigBox.offsetWidth) + 'px';
			 	bigImg.style.top = -top * (bigImg.offsetHeight / bigBox.offsetHeight) + 'px';
		})




================================轮播图======================================================
	→DOM结构:
        <div id="box">
            <!-- 图片 -->
            <ul id="list-container">
                <li>
                    <a href="javascript:;">
                        <img src="images/1.jpg" alt=""/>
                    </a>
                </li>
                <li>
                    <a href="javascript:;">
                        <img src="images/2.jpg" alt=""/>
                    </a>
                </li>
                <li>
                    <a href="javascript:;">
                        <img src="images/3.jpg" alt=""/>
                    </a>
                </li>
                <li>
                    <a href="javascript:;">
                        <img src="images/4.jpg" alt=""/>
                    </a>
                </li>
                <li>
                    <a href="javascript:;">
                        <img src="images/5.jpg" alt=""/>
                    </a>
                </li>
            </ul>
            <!-- 小圆点 -->
            <div class="round">
                <!--
                    <span class="round-active">
                        1
                    </span>
                    <span>
                        2
                    </span>
                    <span>
                        3
                    </span>
                    <span>
                        4
                    </span>
                    <span>
                        5
                    </span>
                -->
            </div>
            <!-- 之前按钮 -->
            <div class="before">
                &lt;
            </div>
            <!-- 之后按钮 -->
            <div class="after">
                &gt;
            </div>
        </div>

	→CSS样式:
          *{
            margin:0;
            padding: 0;
            list-style:none;
          }
          #box{
            width:500px;
            height:200px;
            margin:100px auto;
            overflow: hidden;
            position:relative;
          }
          #list-container{
            width:2500px;
            position:absolute;
            left:0;
          }
          #list-container li{
            float: left;
          }
          .round{
            position:absolute;
            z-index:99;
            bottom:5px;
            left:50%;
            transform:translate(-50%,0);
          }
          .round span{
            display: inline-block;
            width: 20px;
            height:20px;
            border-radius:50%;
            background:#333;
            color:red;
            font-size:20px;
            line-height:20px;
            text-align: center;
            cursor:pointer;
            margin-left:10px;
          }
          .round-active{
            color:white !important;
            background:#FF7C07 !important;
          }
          .before,.after{
            width:30px;
            height:100%;
            background:rgba(0,0,0,0.5);
            position:absolute;
            top:0;
            color:white;
            font-size:20px;
            line-height:200px;
            text-align:center;
            cursor:pointer;
            display:none
          }
          .before{
            left:0;
          }
          .after{
            right:0;
          }
          #box:hover .before{
            display:block;
          }
          #box:hover .after{
            display:block;
          }

	→原生js代码
    	//获取父级框
        var box = document.getElementById('box'),
            //获取ul
            ul = box.querySelector('#list-container'),
            //获取li
            li = ul.getElementsByTagName('li'),
            //获取存放小圆点div
            roundBox = document.querySelector('.round'),
            //获取左箭头
            toLeft =  document.querySelector('.before'),
            //获取右箭头
            toRight = document.querySelector('.after');

        //动态生成小圆点
        var span = '';
            for(var i  = 0 ,index = li.length; i < index; i++){
                span += '<span>' + (i + 1) + '</span>';
                roundBox.innerHTML = span;
            }

        //点击小圆点切换
        var round = document.querySelectorAll('.round span');
            round[0].className = 'round-active';
        for(var i = 0, rounds = round.length; i < rounds; i++){
            round[i].index = i;
            round[i].onclick = function(){
                if(!this.classList.contains('round-active')){
                    for(var j = 0; j < round.length; j++){
                       this.parentNode.querySelectorAll('.round span')[j].className = '';
                    }
                    this.classList.add('round-active');
                }
               $animate(ul,-this.index * box.offsetWidth);
            }
        }

        //自动轮播
         var timer,
             i = 0,
             index = 0;
             timer = setInterval(fn,1000);
             function fn(){
                i -= box.offsetWidth;
                index++;
                 if (i <= -ul.offsetWidth) {
                    i = 0;
                    index = 0;
                }
                //移除所有小圆点class
                for(var j = 0; j < round.length; j++){
                      round[j].className = '';
                }
                //给当前图片索引,小圆点添加class,
                round[index].className = 'round-active';
                $animate(ul,i);
             }
             fn();
        //移入div,清除自动轮播
            box.onmouseover = function(){
                clearInterval(timer);
            }
        //移除div,恢复自动轮播
        box.onmouseout = function(){
             timer = setInterval(fn,1000);
        }

        //左箭头
        var target = 0;
             toLeft.onclick = function(){
                 target += box.offsetWidth;
                 index--;
                 if (target >= ul.offsetWidth) {
                        target = 0;
                         index = round.length - 1;
                 }
                 // console.log(index);
                if(index < 0){
                    index = round.length - 1;
                 }
                //移除所有小圆点class
                for(var i = 0; i < round.length; i++){
                      round[i].className = '';
                }
                //给当前图片索引,小圆点添加class,
                 round[index].className = 'round-active';


                 $animate(ul,-target)
             }
        //右箭头
          toRight.onclick = function(){
             target -= box.offsetWidth;
             index++;
             if (target <= -ul.offsetWidth) {
                    target = 0;
             }
            if(index > round.length - 1){
                index = 0;
            }

                  //移除所有小圆点class
                for(var i = 0; i < round.length; i++){
                      round[i].className = '';
                }
                //给当前图片索引,小圆点添加class,
                 round[index].className = 'round-active';

                 $animate(ul,target)
             }


        //运动框架
        function $animate(nd,target){
            clearInterval(nd.timer);
            var speed = (target > nd.offsetLeft) ? 10 : -10;
            nd.timer = setInterval(function(){
                var maxLeft = target - nd.offsetLeft;
                    nd.style.left =  speed + nd.offsetLeft + 'px';
                    if(Math.abs(maxLeft) <= 10){
                        nd.style.left = target + 'px';
                        clearInterval(nd.timer);
                    }

            },1)
        }
======================================================================================
垃圾回收 GC  garbage collection 
	垃圾回收清空释放内容中垃圾对象。
		-标记清除：标记内存中全部对象，将非当前环境占用的对象标记清除，销毁无标记对象

		-引用计数：每当有一个引用指向当前对象，对象引用数加一，GC机制执行时清除引用数0的对象

		引用计数方式无法清空对象循环引用场景下的对象。部分IE浏览器对象（BOM）仍使用c系列语言实现，仍使用引用计数的方式做垃圾回收。

		注意事项：js语言存在主动触发GC的方法，但一般不会手动触发，等待回收周期到来自动执行。
		
	GC特性：垃圾回收时所有js代码停止执行
	垃圾回收优化大体思路： 保证垃圾回收功能正常的前提下，尽量缩短单次回收消耗的时间









【js】[js]
=-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-==-=-=-=-=-=-==-=
 ___________________________
|                           |
|                           |_______________________________________
|     jquery【结酷瑞】      |                                      |
|                           |________________________________|     |
|___________________________|                                |     |
                                                              \    /
                                                               \ _/
jQuery=$
【正确写法】
	$(function(){
	$('#选择器,必须英文').css('font-size','16px');
	);
                                                                               =
                                                                               =
1.先加$();
2.换行再加});
3.中间在$('','').css('','');
                                                                               =
                                                                               =
ps:javescript和jQuery不能大小写混，严格要求大小写输入，尤其部分英文【首字母必须大写】否则无法运行，少了【空格】会无法生效
【''】=【""】"能代替'符号用
                                                                               =
                                                                               =
	window.onload=function(){
	$('#box').css('color','blue');
	}

【等待加载完毕,只能执行1次】                                                      =
	$(document)ready
	document【文档】刀客梅特                                                                           
	dom【住所】当木
	function【功能】凡客是
	alert【警报,提示框】额乐特
	function【功能】发客审
	click【点击】kei可
	var【定义变量】外热                                                                        
	onload【装载】欧漏的                                                            

	eq【等于】equal
	this【这个】
	ready【预先】瑞鼎
	addClass【增加-类】
	siblings【兄弟】
	removeClass【移动-类】
	move【移动】
	if【如果】
	click【点击】                                                                     =
	cur【光标,鼠标】

	link【未点击,默认状态】
	hover【点击移动】另可
	active【鼠标点击】安福特斯
	visited【鼠标点击后】费事列
	
	find()后代匹配所有元素
	【mouseenter】鼠标进入事件
	【mouseleave】鼠标移除事件
	
	【mouseover】鼠标悬停
	【mouseout】鼠标离开
	【mousedown】鼠标按下
	【mouseup】鼠标弹起

	unbind
	bind()的反向操作，从每一个匹配的元素中删除绑定的事件。
	如果没有参数，则删除所有绑定的事件。



	slideDown 滑落按下
	slideUp 滑落弹起

	slide滑落

	
	mouse鼠标
	enter进入
	leave离开

 	jQuery.noConflict();解决jquery和其它$库冲突方法                                                 
alert(document.getElementByld('box')); 【原生js代码】原生DOM对象                                                                                                             
eq($(this).index()).addClass("xi").siblings();
	var i=$(".dian li.hd").index();
	var k=i+1;
	if(k==5){
	   k=0;
		}
		$(".blist li").eq(k).addClass("xi").siblings().removeClss("xi");
	}
	var t = setInterval(qiehun,3000);
	$(".banner").hover(function(){
		clearInteval(t);
	}function(){
	t = setInteval()
}
                                                                               =


window onload=function:(){};
window【窗口】文斗
onload【加载】奥姆老特




【jq点击显示-display:none:下拉列表】
$(document).ready(function() {
    $(".bu").click(function(){
		$(".nav").toggleClass("dis");
		});
});
【bu是外部要点击的div类名】
【nav是点击后的div类名】


$(this).parent('.c').siblings('.b').find('.bb').addClass(.bba);
parent获取父级
siblings获取同级
find获取子级,也可以用child


【隐藏自身元素】
$(document).ready(function(){
  $("img").click(function(){
    $(this).hide();
  });
});


【隐藏自身和父级元素】
$(document).ready(function(){
  $(".ex .hide").click(function(){
    $(this).parents(".ex").hide("slow");
  });
});

【.ex是父级class类名】
【.hide是点击隐藏类名】
PS:如果是a标签隐藏，必须在href添加【javascript:void(0)】否则不生效
hide是速度，默认不填是立即关闭,可以设置延迟时间1000之类数字毫秒来
fast是快的
slow是慢的

$(document).ready(function(){
  $("#hide").click(function(){
  $("p").hide();
  });
  $("#show").click(function(){
  $("p").show();
  });
});
【自定义显示,隐藏元素】
$(document).ready(function(){
  $("#hide").click(function(){
  $("p").hide();
  });
  $("#show").click(function(){
  $("p").show();
  });
});
</script>
</head>
<body>
<p id="p1">如果点击“隐藏”按钮，我就会消失。</p>
<button id="hide" type="button">隐藏</button>
<button id="show" type="button">显示</button>

【切换单一元素或类名,ID隐藏或显示】
$(document).ready(function(){
  $("button").click(function(){
  $("p").toggle();
  });
});

<button type="button">切换</button>
<p>这是一个段落。</p>
<p>这是另一个段落。</p>

【显示/隐藏】
$(document).ready(function(){
  $("#hide").click(function(){
  $("p").hide();
  });
  $("#show").click(function(){
  $("p").show();
  });
});

<p id="p1">如果点击“隐藏”按钮，我就会消失。</p>
<button id="hide" type="button">隐藏</button>
<button id="show" type="button">显示</button>

【bottom切换显示隐藏】
$(document).ready(function(){
  $(".btn1").click(function(){
  $("p").toggle(1000);
  });
});
<p>This is a paragraph.</p>


【Tab切换设置】
  $(document).ready(function(){
    $('.a111').click(function(){
      $('.a222').toggle();
    });
  });

toggle默认是来回切换，若默认隐藏，toggle()内填true真,若默认是显示,输入false
PS:只能单向切换




$(document).ready(function) 将函数绑定到文档的就绪事件（当文档完成加载时） 
$(selector).click(function) 触发或将函数绑定到被选元素的点击事件 
$(selector).dblclick(function) 触发或将函数绑定到被选元素的双击事件 
$(selector).focus(function) 触发或将函数绑定到被选元素的获得焦点事件 
$(selector).mouseover(function) 触发或将函数绑定到被选元素的鼠标悬停事件 


mouseove就是hover,但可惜不能单个元素名,类名,id同时操作多个步骤,只要执行第一次操作_______________________________________________________________________
jq如何使用
	1.使用
	2.入口函数
		$(function(){代码块;})
		$(document).ready(function(){代码块})
2.jq是什么?js的一个框架 库
3.jq的选择器
	基本选择器 id('#ID')
	类名$('.类')
	标签('div')
	交集选择器$('div#id')
	并集选择$('.类,#id')

	层级选择器 
	【id $('li + li')】li后面紧邻的li元素
	【$('li~li')】li后面的所有li
	【$('li').siblings()】li所有的兄弟元素
	【$('元素').children()】 不能识别索引值,只能添加元素名
	【 $('li').next()】-li后面紧邻的元素  子代
	【 $('li').nextAll()】 li后面所有的同级元素
	【.prev();】前面紧邻的元素
	【.prevAll();】之前的所有的同级元素

	 后代选择器
	【li p')li里面的p元素 子子孙孙
	【li:eq(下标)')】
	【li:gt(下标)')】 参数:数字  索引值 过滤到的是索引值比当前指定元素大的其他的所有元素
	【li:lt(下标)')】 参数:数字  索引值 过滤到的是索引值比当前指定元素小的其他的所有元素
	【li:odd(下标)')】
	【li:even(下标)')】
	【父级$('li').parent()】查找父级元素
	【$(this).parents()】从下往上,查找所有父级元素

	【find('li')】元素的后代 子子孙孙,包括可以使用:select判断选中属性

1.基本过滤选择器	
	【元素:first】选取第一个元素,子级会继承父级
	【元素:last】选取最后一个元素,子级会继承父级
	【元素:not(.class或#ID)】设置不是指定class或ID的元素,不会继承父级影响
		not不
		也可以设置li:gt(5):not(:last)排除最后一个元素
	【元素:even】从0开始,选择能被2整除元素,子级会继承父级,过滤时会计算子级的个数,若下一个父级被选中,子级也会受到继承
	【元素:odd】从0开始,不能被2整除元素,同样子级会继承父级,过滤时会计算子级的个数,若下一个父级被选中,子级也会受到继承
	【元素:eq(index)】从0开始选择,和【元素:nth-of-type(index)】相同
	【元素:gt(index)】大于设置数值之后进行设置,不包含自身和之前
	【元素:lt(index)】小于设置数值之后进行设置,不包含自身和之后
	【元素:header】选择h1~h6全部标题
	【元素:animated】选择当前正在执行动画的所有元素
	【元素:focus】获取当前获取焦点的元素 jquery 1.6+版本以上

2.内容过滤选择器
	【元素:contains(text)】选取含有文本内容为'text'的元素,文本不加引号,子级会继承父级
	【元素:empty】选取不包含子元素或者文本的空元素
	【元素:has(元素)】也就是查找子集级元素,和子级和父级选择器差不多,ID和class也能用
	【元素:parent】选取含有子元素或者文本的元素,和empty正好相反
	【元素:filter(str|obj|ele|fn)】筛选出与指定表达式匹配的元素集合,这个方法用于缩小匹配的范围。用逗号分隔多个表达式
	比如$('ul li a').filter(":contains('佳能'),:contains('尼康'),:contains('奥林巴斯')")
	配合contains使用这样就可以获取到自定义元素,并进行操作

3.可见性过滤选择器
	【元素:hidden】选取所有不可见的元素,包括type:hidden,display:none,visibility:hidden;
	【元素:visible】选取所有可见的元素,具有继承性
		
		if($(this).next().is(':visible')){ //判断是否存在
		}
4.属性过滤选择器
	【[attribute]】选取拥有此属性的元素
	【[attribute = value]】选取属性的值为value的元素
	【[attribute != value]】需求属性的值不等于value的元素
	【[attribute ^= value]】选取属性的值以value开头的元素
	【[attribute $= value]】选取属性的值以value结束的元素
	【[attribute *= value]】选取属性的值含有value的元素
	【[attribute |= value]】选取属性等于给定字符串或以该字符串为前缀(该字符串后跟一个连字符"_")的元素 比如[class |= on],获取到的就是以on开头,onClick或后面加了下连字符on_click的元素
	【[attribute ~= value]】选取属性用空格分割的值中包含一个给定值的元素,比如[class ~= lt]得到的就是class="click lt"这个元素
	【[attribute1][attribute2][attribute3]】用属性选择器合并成一个符合属性选择器,满足多个条件/每选择一次,缩小一次范围 比如div[id][class='test']获取拥有属性id,并且有class的test的元素

5.子元素过滤选择器
	【:nth-child(index/even/odd/equation)】选取每个父元素下的第index个子元素或者奇偶元素,(index从1算起)
		equation就是eq,eq(index)从0算起
	【:first-child】 选区每个父元素的第1个子元素
	【:last-child】选取每个父元素的最后一个子元素
	【:only-child】选取父元素只有一个子元素的标签,不符合不匹配

6.表单对象属性过滤选择器
	【:enable】选取所有可用元素 $('#form1 :enaled)选取id为form1的表单下所有可用元素
	【:disabled】选取所有不可用元素 $('#form1 :disabled)选取id为form1的表单下所有不可用元素
	【:checkked】选取所有被选中的元素(单选框,复选框) $('input:checked'),选取所有被选中的<input>元素
	【:selected】选取所有被选中的选项元素(下拉列表) $("select option:selected")选取所有被选中的选项元素

7.子元素过滤选择器	
	【:input】选取所有的<input>,<textarea><select>和<button>元素
	【:text】选取所有的单行文本框
	【:password】选取所有的密码框
	【:radio】选取所有的单选框
	【:checkbox】选取所有的多选框
	【:submit】选取所有的提交按钮
	【:image】选取所有的图形按钮
	【:reset】选取所有的重置按钮
	【:button】选取所有的按钮
	【:file】选取所有的上传域
	【:hidden】选取所有不可见元素

	 //使用:selected选择器，来操作下拉列表.
		$("select").change(function () {
			  var str = "";
			  $("select :selected").each(function () {
					str += $(this).text() + ",";
			  });
			  $("div").eq(1).html("<strong>你选中的是："+str+"</strong>");
        }).trigger('change');
		【trigger('change')】 在这里的意思是：
		// select加载后，马上执行onchange.
		// 也可以用.change()代替.
		【change】改变
		【trigger】引发
		PS:这两个是页面加载后马上显示,适合用于一些默认选中了的按钮和无延迟轮播之类效果

		※注:【trigger】无法触发键盘事件,只能触发鼠标事件

	若id有特殊字符
	比如id="id#b"
	    id="id[1]"
	要在jq里获取,必须使用转义字符【\\】来转换才行
	$('#id\\#b) //转义字符#
	$('#id\\[1\\]'); //转义字符[]

	属性选择器的@符文问题
	jquery在1.3.1版本彻底放弃了1.1.0版本遗留下的@符号
	1.3.1之前版本写法$('div[@title="test"]')
	

【选择器中含有空格的注意事项】
	<div class="test">
		<div style="display:none">a</div>
		<div style="display:none">b</div>
		<div class="test" style="display:none">c</div>
	</div>
	<div class="test" style="display:none">d</div>
	<div class="test" style="display:none">e</div>
	后代选择器$('.test :hidden') 结果4  选取class为'test'的元素里面的隐藏元素,包括子级的父级
	过滤选择器$('.test:hidden') 结果3 选取隐藏的class为test的元素
	

	也能使用css中的高级选择器
	比如常用的【button:nth-of-type(0)】

	4.CSS样式设置
		$('div').css('color','red');
		$('div').css({
			'color' : 'red',
			 width : 100
		})

	5.事件方法
		【click()】 点击
		【hover()】 悬停
		【mouseenter()】鼠标移入
		【mouseleave()】鼠标移出
		enter 进入
		leave 离开
			
	//给div添加类样式 宽高背景颜色one
	//添加类名,不带. ****
	//添加多个类,空格隔开

	【.addClass()】 添加类
	【.removeClass()】 移除类
	【.toggleClass()】 移动类
	
	获取索引值,必须在事件后加.index(),这里代表this要点击之类的事件,
	var Li = $(this).index();
    	console.log(Li)

	辅助型方法
	【.hasClass()】判断当前元素是否有某个类样式 返回值为true,false


	把div添加到页面中
	【父节点.append(子节点) 】
	【子节点.appendTo(父节点)】

	把a添加到$div的后面
	【指定的元素.after(某个节点)】 在之后添加
	【指定的元素.before(某个节点)】 在之前添加

	
	【replaceAll()】 新节点来替换节点
	【$p.replaceAll($('#my_div')); 】新节点在前,要替换节点在后
	【$('#my_div').replaceWith($p);】要替换节点在前,新节点在后
	

	【.with()】和，跟
	【.empty()】empty()会清空当前调用元素内的所有内容,但是保留本身标签. 光杆司令
	empty空的
		[清空文本]
	【.remove()】所有内容都清空之外,还会把自身标签也干掉 自杀	


	注释:【text()】 【html()】 【val()】既可以设置,也可以获取/访问
		//设置的话,调用方法同时要传实参
		//访问的话,直接调用方法无参
		

	【.width()】获取,设置div的宽
	【.height()】获取,设置div的高
	访问div元素的innerWidth():content + padding
	【innerWidth();】
	【innerHeight();】

	【.outerWidth()】访问div元素的 content + padding + border
	【.outerHeight()】

	【.outerWidth(true)】 : content + padding + border+ margin 水平方向

	【.offset().left】jq获取left
	【.offset().top】jq获取top
		console.log($("div").offset().left);//100 数值型

	【.show()】和【.hide()】可添参数 时间 1000毫秒

				//参数 是两个 第一个时间  第二个callback
				$('div').show(2000,function(){
					$('div').hide(2000);
					console.log('完成!');
				});

	//【stop()】停止动画
				//参数true 停止所有动画,不再继续执行
				//参数false 停止当前动画,继续执行下一个动画

	
	【size()】获取jq长度[jq获取长度]
		不支持jQuery 3.0.0以上
	ajax



【jq2级事件】【jq二级事件】[jq二级事件][jq2级事件]
	//【bind()】 jq1.7以上,被on 代替
	//【unbind()】
	bind约束
	unbind解开
	data-original 数据-原型的


	【live()】方法为被选元素附加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。
	通过 live() 方法附加的事件处理程序适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。

	
	参数	描述
	event	必需。规定附加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。
	data	可选。规定传递到该函数的额外数据。
	function必需。规定当事件发生时运行的函数。

	→DOM结构:
	<p>这是一个段落。</p>
    	<p>点击任意 p 元素会令其消失。包括本段落。</p>
    	<button>在本按钮后面插入新的 p 元素</button>
    	<p><b>注释：</b>通过使用 live() 方法而不是 bind() 方法，新的 p 元素同样会在点击时消失。</p>

	→jQuery代码:
        $(function(){
          $("p").live("click",function(){
            $(this).slideToggle();
          });
          $("button").click(function(){
            $("<p>This is a new paragraph.</p>").insertAfter("button");
          });
        });

	jquery1.3.2
的动态绑定事件方法
live
不支持
blur,focus,mouseenter,mouseleave,change,submit
特别是不支持
blur,focus
事件使我很不爽,因为我的页面需要这个功能。
  
后来发现
livequery
这个插件,发现它支持
blur,focus
,并且还支持自定义方
法,很强,于是替代了
jquery
自带的
live
,完美,
	  
注意:新出来的
jQuery1.4
不用
livequery
这个插件也可以实现了
	livequery插件就是增强live()功能
===========================================================================
	1.类样式操作
	1.1 添加 类
		- 【元素.addClass("类名");】
	1.2 移除 类
		- 【元素.removeClass("类名")】;
		- 如果括号没无参数,代表删除所有类
	1.3 切换类样式
		- 【元素.toggleClass("类名");】
		- 一般与点击事件配合,如元素有此类名则清除,如无则添加
	1.4 判断当前元素是否有某个类样式
		- 【元素.hasClass("类名")】;
2.节点操作
	2.1 创建节点
		- var $div = $("<div>我是创建出来的节点</div>");
	2.2 添加节点
		- 方法一: 【父节点.append(子节点)】
		- 方法二: 【子节点.appendTo(父节点)】
	2.3 把新节点添加到指定节点的后面
		- 【指定元素.after(新节点)】
	2.4 把新节点添加到指定节点的前面
		- 【指定元素.before(新节点)】
	2.5 替换节点
		- 方法一: 【新节点.replaceAll(旧节点);】
		- 方法二: 【旧节点.replaceWith(新节点);】
	2.6 删除节点
		- 清空当前调用元素内的所有内容,但是保留本身标签
		    【元素.empty()】
		- 清空所有内容之外,还会把自身标签也清除  => 自杀
		   【元素.remove()】
3.属性节点操作
	3.1 设置属性
		- 【元素.attr("属性","属性值")】
	3.2 访问属【性
		- 元素.attr("属性")】
	3.3 移除属性
		- 【元素.removeAttr("属性")】
4.节点添加内容和value
	4.1 标签设置文本内容
		- 【元素.text("文本内容")】
	4.2 标签获取文本内容
		- 【元素.text()】
	4.3 设置标签内标签和文本内容
		- 【元素.html("标签+文本内容")】
	4.4 获取标签内标签和文本内容
		- 【元素.html()】
	4.5 给input设置值 
		- 【input元素.val("value内容");】
	4.6 访问input的value值
		- 【input元素.val();】
5.操作盒子模型(宽高,margin,padding,border,偏移量)
	5.1 设置宽度,高度
		- 【元素.width(宽度值)】
		- 【元素.height(高度值)】
	5.2 访问宽度,高度
		- 【元素.width()】
		- 【元素.height()】
	5.3 访问宽高加pading的值
		- 【元素.innerWidth()】
		- 【元素.innerHeight()】
	5.4 访问宽高+pading+border
		- 【元素.outerWidth()】
		- 【元素.outerHeight()】
	5.5 访问宽高+pading+border+margin
		- 【元素.outerWidth(true)】
		- 【元素.outerHeight(true)】
	5.6 访问margin+定位距离
		- 【元素.offset().left】
		- 【元素.offset().top】
6.动画
	6.1 【show()】
		- 可填参数 时间 单位为ms->动画完成时间
		- 参数为2: 第一个参数->时间 ; 第二个参数->callback
		- 在时间完成动画后,执行回调函数的代码
	6.2 【hide()】
		- 可填参数 时间 单位为ms->动画完成时间
		- 参数为2: 第一个参数->时间 ; 第二个参数->callback
		- 在时间完成动画后,执行回调函数的代码
		
	【.prepend()】



【jq选择器】[jq选择器]
==============================================
总结:
	-【hide()】 隐藏
	-【toggle()】 显示隐藏

	-【fadeIn(时间)】 淡入
	-【fadeOut(时间)】 淡出
	-【fadeToggle()】 淡入淡出

	-【slideDown()】 滑入
	-【slideUp()】 滑出
	-【slideToggle()】 滑入滑出

	slide滑动
	fade褪去
	【fadeTo(毫秒,透明度)】 会固定透明度,若想恢复原来透明度,只要
		.stop()
        	.fadeTo(3000,0.6)
        	.fadeTo('fast',1)
      		 .unbind('click')
	在动画前停止,添加两次fadeTo就能恢复原样
	之所以在最后使用unbing清空事件,是因为再次点击如果不清空点击事件就无法再次触发事件
	这里需要说明的是,stop()默认参数是false,只能清除一次事件,而一个事件以上,就必须使用.unbind把点击事件去除才能再次触发事件
	这是一种解决方法,但却不是最简单方法:
	最简单方法:
	.stop('fast')
        .fadeTo(3000,0.6)
        .fadeTo('fast',1)
	

==============================================
【五角星评论】【五角星案例】[五角星评论][五角星案例]


DOM结构:
    <ul class="comment">
        <li>☆</li>
        <li>☆</li>
        <li>☆</li>
        <li>☆</li>
        <li>☆</li>
    </ul>

jQuery三种方法实现:
	//声明两个星星
	var blackStar = '★',
		blankStar = '☆';

		//鼠标悬停
	$('li').mouseover(function(){
		//悬停的li变为黑星星
		//它之前的所有也都是黑星星
       
        //第一种 最常见,使用拼接
     $('li:lt(' + ($(this).index() + 1) + ')').text(blackStar);
            
            //第二种
			/*$('li').text(blackStar);
			$(this).nextAll('li').text(blankStar);*/

			//nextAll() A()
			//prevAll() prev()

            //第三种 ←最推荐
//				$(this).text(blackStar).prevAll('li').text(blackStar);
	});

	$('li').mouseout(function () {
			//所有li都恢复
			$('li').text(blankStar);
			//当前那个li点击了,如果某个li被点击,它之前所有星星应该保持黑星星

			$('li.clicked').text(blackStar).prevAll().text(blackStar);
	})
	//给点击的li添加一个类样式
		$('li').click(function () {
			$(this).addClass('clicked').siblings().removeClass();
		})
第一种改版,用flag判断:
	var flag = true;
	$("li").mouseover(function(){
		if(flag){
			$("li").text("☆");
			$(this).text("★");
			$("li:lt("+$(this).index()+")").text("★");
		}
	});
	$("li").mouseout(function(){
		if(flag){
			$("li").text("☆");
		}
	});
	$("li").click(function(){
		flag = false;
	});
第一种用变量赋值0:
		var $n = 0;	
		$("li").hover(function(){
			$m = $(this).index() + 1;
			$("li:lt(" + $m + ")").text("★");
			$("li:gt(" + $(this).index() + ")").text("☆");
		},function(){
			$("li:lt(" + $m + ")").text("☆");
			$("li:lt(" + $n + ")").text("★");
		});
		
		$("li").click(function(){
			$n = $(this).index() + 1;
		});
第一种jQuery改版:
		var str1="☆";
		var str2="★";
		$("li").mouseenter(function(){		
			$("li:lt("+($(this).index()+1)+")").text( str2);
		}),
		$("li").mouseleave(function(){
			$("li").text(str1);
		});
		$("li").click(function(){
			$("li:lt("+($(this).index()+1)+")").text( str2);
			$("li").unbind("mouseleave");
			var n =$(this).index();
			$("li").mouseleave(function(){
				$("li:gt("+n+")").text( str1);
			});
		});
第一张jQuery改版2:
		var $n = 0;
		$("li").hover(function(){
			$m = $(this).index() + 1;
			$("li:lt(" + $m + ")").html("★");
			$("li:gt(" + $(this).index() + ")").html("☆");
		},function(){
			$("li:lt(" + $m + ")").html("☆");
			$("li:lt(" + $n + ")").html("★");
		});
		
		$("li").click(function(){
			$n = $(this).index() + 1;
		});


第一种原生js和jQuery改版:
	$("li").mouseenter(function(){
		$(this).html("★");
		$("li:lt(" + $(this).index() + ")").html("★");
		$("li:gt(" + $(this).index() + ")").html("☆");
	});
	var count = 0;
	var index;
	$("ul").mouseleave(function(){
		if(count == 0){
			$("li").html("☆");
		}else{
			$("li:eq(" + index + ")").html("★");
			$("li:lt(" + index + ")").html("★");
			$("li:gt(" + index + ")").html("☆");
		}
	});
	$("li").click(function(){
		$(this).html("★");
		count++;
		index = $(this).index();
		$("li:lt(" + $(this).index() + ")").html("★");
		$("li:gt(" + $(this).index() + ")").html("☆");
	});




原生js五角星评分:
	→DOM结构:
    	<div id="box">
        	<img src="images/star-white32.png"/>
        	<img src="images/star-white32.png"/>
        	<img src="images/star-white32.png"/>
        	<img src="images/star-white32.png"/>
        	<img src="images/star-white32.png"/>
        	<span id="score" style="color: red">0</span>分
    	</div>

	→javascript代码:
        //首先要获取图片,相当于装到一个数组里面
        var star = document.getElementsByTagName("img");
        //读取数组的索引
        for(var i = 0; i < star.length; i++){
            star[i].setAttribute("index",i + 1);
            var flag = true;

            //按下事件
            star[i].onmouseover = function(){
                //读取元素的属性值
                if(flag == true){
                var result = event.srcElement.getAttribute("index");
                document.getElementById("score").innerHTML = result;
                var newindex = result - 1;
                    for(var j = 0;j <= newindex; j++){
                        star[j].setAttribute("src","images/star-gold32.png");
                    }
                    for(var j = newindex + 1; j < star.length; j++){
                        star[j].setAttribute("src","images/star-white32.png");
                    }
                }
            }
            //移入事件
             star[i].onmouseout = function(){
                //读取元素的属性值
                if(flag == true){
                var result = event.srcElement.getAttribute("index");
                document.getElementById("score").innerHTML = result;
                    for(var j = 0;j <= newindex; j++){
                        star[j].setAttribute("src","images/star-white32.png");
                    }
                }
             }
              star[i].onmousedown = function(){
                flag = false;
              }
        }

自己对象封装五角星评论:
	→DOM结构:
        <div id="box">
            <span>☆</span>
            <span>☆</span>
            <span>☆</span>
            <span>☆</span>
            <span>☆</span>
        </div>

	→javascript代码:
       var whiteStar = '☆',
            blackStar = '★';
       var span = box.getElementsByTagName('span');
        for(var i = 0; i < span.length; i++){
            span[i].id = i + 1;
            //用来判断是否增加五角星
             var flag = true;
            //添加对象,调用函数
            var Star = {
                starMouseover : function(){
                    if(flag == true){
                        var index = this.id;
                        for (var i = 0; i < index; i++) {
                            span[i].innerHTML = blackStar;
                        }
                        for(var j = index; j < span.length; j++){
                            span[j].innerHTML = whiteStar;
                        }
                    }
                },
                starMouseout : function(){
                    if(flag == true){
                        for (var i = 0; i < span.length; i++) {
                            span[i].innerHTML = whiteStar;
                        }
                    }
                },
                stopEvent :  function(){
                    flag = false;
                },
             }
             //实例化对象
             var starSelect = Object.create(Star);
             
            //点击事件
            span[i].onmouseover = starSelect.starMouseover;
            span[i].onmouseout = starSelect.starMouseover;
            span[i].onclick = starSelect.stopEvent;
        }

==============================================
事件 【on()和off()】


			//简单事件绑定方法
/*			$('input').click(function () {
               console.log($('input').val())
			})
			*/

			//on方法来绑定事件
			/*$('input').on('click',function () {
				 console.log($('input').val())
			})
*/
			//第二种形式
			/*$('input').on('click',fn);
			function fn () {
				 console.log($('input').val())
			}*/

			//如果给同一个元素绑定多个事件,会不会后者覆盖掉前者的?
			//不会
//			$('input').on('click',fn1);
			function fn1 () {
				 console.log($('input').val())
			}

			//解绑off()
//			$('input').off('click',fn1)

			//命名冲突
			$('input').on('click.abc',fn1);
			$('input').on('click.df',fn1);
			//如何解绑?
			$('input').off('click.abc',fn1)

			//第二种 给触发事件的父元素添加on方法
			//事件委托
			$('div').on('click','input',function () {
				 console.log('这是给div添加事件');
				 //target currentTraget
				console.log($(this).val()); //this指向的是input
			})

			//用第一种绑定方法,给按钮添加事件
			//按钮 绑定多个事件
			$('input').on({
				'click' : function () {
					mouseover : function () {

					}
					mouseout : function () {

					}
				}
			})

			//bind() jq1.7以上,被on 代替
			//unbind()
==============================================
【懒加载】
	1.原生js
	DOM结构:
	<img src="" srcImg="1.jpg" alt="" />
		<button>点击</button>
	js代码:
	document.getElementsByTagName("button")[0].onclick = function () {
		var srcImg = document.getElementsByTagName("img")[0].getAttribute("srcImg");
		document.getElementsByTagName("img")[0].src = srcImg;
	}

	※注:懒加载原理很简单,其实就是给元素添加自定义属性,后面添加图片路径或其他比如input自定义value值之类的,因为W3C没规范的属性默认会不生效,所以一开始会不显示.然后当点击按钮或触发什么事件,比如点击,下拉情况,再添加这个自定义属性,这样的话就会显示自定义属性的内容
	以上就是懒加载基于js的根源原理


【实现全屏滚动切换背景图案例,也可以用于大量图片类网站】
	2.DOM结构:
	<div class="out">
		<div class="div1">
			<img src="1.jpg"/>
		</div>
		<div class="div2">
			<img src="" srcImg="Lighthouse.jpg"/>
		</div>
	</div>

	js代码:
		var imgs = document.querySelectorAll("img")[1];
		var sTop = document.body.scrollTop || document.documentElement.scrollTop;
		var h = document.documentElement.clientHeight;
		window.onscroll = function(){
			sTop = document.body.scrollTop || document.documentElement.scrollTop;

			if(imgs.offsetTop - sTop - h <= 0){
				imgs.src = imgs.getAttribute("srcImg");
			}
		}
	※注:这里的sTop是获取滚动条高度,因为滚动,页面其实是往上移动,那么就是负值,所以用if判断,如果当前图片所在位置小于或等于当前位置,就显示图片.
	如果想要当到达以上外层div的高度就显示图片,只要减去滚动条上去的高度就好
		如果没到达外层div的高度就不显示图片,为了提高用户体验,再减去目前可视的高度,如果小于或等于0,那么显示图片.

	
	【jq版本】
	作者：offline
	时间：2017-03-03
	描述：图片路径信息必须放在懒加载的一个图片属性上【data-original】
	习惯性给个类名为lazy,使用懒加载插件，调用【lazyload()】

	DOM结构:
		<img class="lazy" data-original="1.jpg" width="640" height="480">

	引入jq插件:【jquery.lazyload.js】懒加载
   	 <script src="jquery.lazyload.min.js"></script>
	
	jq:
	 $("img.lazy").lazyload();


	jQuery和lazyload懒加载
	DOM结构:
 	<div id="myDiv">
        	<img src="" data-src="images/demo.png" alt="">
    	</div>
	
	jQuery代码:
        function isVisiable($obj){
            var winH = $(window).height(),
                scrollTop = $(document).scrollTop(),
                offsetTop = $obj.offset().top;
                if(scrollTop > offsetTop-winH){
                    return true;
                } else{
                    return false;
                }
        }
        var $myDiv = $('#myDiv'),
            hasShowed = false;
            $(document).on('scroll',function(){
                hasShowed = true;
                $lazyImg = $myDiv.find('img');
                $lazyImg.attr('src',$lazyImg.attr("data-src"));
            })
==============================================
【事件委托】
	原生js:
	 	点击页面中每个li,弹出'好好学习,天天向上'
	 	传统做法:获取所有li,循环访问每个,给每个添加onlick事件,事件处理程序中输出内容即可
	//时间委托:冒泡机制
	//父级元素
	//ul做点击事件
	→ DOM结构:
		<ul>
			<li>1</li>
			<li>2</li>
			<li>3</li>
		</ul>

	→ js代码:
	var ul = document.getElementsByTagName('ul')[0];
		ul.onclick = function (event) {
			//兼容
			var e = event || window.event;
				console.log(e.target); //监听的是当前点击触发的真正元素i

			if(e.target.nodeName.toLowerCase() == 'li'){
				alert('好好学习,天天向上')
			}
		}
	→ jq代码:
	//给ul 绑定 点击事件
	$('ul').on('click',function (e) {
		console.log(e.target);
		var tar = e.target;
			if($(tar).is($('li'))){
				alert('好好学习,天天向上');
			}
	})
	
	→原生js使用:
	【e.target】得到点击元素
	【e.target.nodeName.toLowerCase()】向底部事例 获取子级元素名
		
	→js使用
	【$(e.target).is($('li'))】用$()制造多个jQuery对象,jQuery对象是数组,再使用is()判断是否存在,是的话进入代码块进行事件.
	※注:事件委托其实就是给父级元素添加事件,然后得到子级元素名,同时添加事件,或使用if,switch来进行判断id,根本不同id名的相同元素添加事件.

	原生js事件委托练习:
	→ DOM结构:
	<div id="box">
		<input type="button" name="" id="add" value="添加" />
		<input type="button" name="" id="del" value="删除" />
		<input type="button" name="" id="move" value="移动" />
		<input type="button" name="" id="select" value="选择" />
	</div>
	
	→ js代码:
	//每个按钮弹出的内容不一样,但是同样可以使用事件委托
	//获取到div
	var box = document.getElementById('box');
		box.onclick = function (e) {
			var e = e || window.event;
			var tar = e.target;
			//判断当前的tar必须是按钮,按钮之后具体的区分
			if(tar.nodeName.toLowerCase() == 'input'){
				//具体按钮进行区分
				switch(tar.id){
					case "add" :
						alert('添加');
						break;
					case "del" :
						alert('删除');
						break;
					case "move" :
						alert('移动');
						break;
					case "select" :
						alert('选择');
						break;
				}
			}
		}


	【event || window.event】
	ff火狐支持event.target,而IE支持event.srcElement
	做下兼容处理
	【var currentElement = srcElement ? srcElement : e.target】
	e.target || e.srcElement 简单这样写
	
==============================================
添加2级事件和删除 【on()和delegate()】

	DOM结构:
	<ul>
		<li>1</li>
		<li>2</li>
		<li>3</li>
	</ul>
	
	js代码:
	//点击li,都能弹出123
	$(document).ready(function () {
		$('ul').on('click','li',function () {
			//执行函数
			alert('123');
		})

		//delegate() 代理 委托
		//第一个参数:附加子元素(事件真实触发源)
		//第二个参数:事件
		//跟on() 正好相反
		$('ul').delegate('li','click',function () {
			alert(123);
		})
	

//【delegate()】 代理 委托
		//第一个参数:附加子元素(事件真实触发源)
		//第二个参数:事件
		//跟on() 正好相反

	【e.stopPropagation()】阻止冒泡
	.eqch() 相当for(in)循环


	DOM结构:
	<div>
		<div id="">
			<button>按钮</button>
		</div>
	</div>
	<a href="01-原生js事件委托.html">点击</a>

	js代码:
       //点击按钮,弹出123
	$('button').on('click',function (e) {
		alert(123);
		e.stopPropagation();
	});
	//点击按钮,弹出456
	$('div').on('click',function () {
		alert(456);
	});

	//阻止默认行为
	$('a').on('click',function (e) {
		alert(789);
		e.preventDefault();
	})
=====================================================================
【链式编程】【jq链式编程】[链式编程][jq链式编程]
	DOM结构:
	<ul>
		<li>我是li1</li>
		<li>我是li2</li>
		<li>我是li3</li>
	</ul>
	<div></div>

	//给ul下的li 设置样式: 宽高各位100,背景颜色为绿色,字体大小为25px
	//给ul后面的div设置样式:宽高各为100,背景颜色为红色

	//链式编程 链条

第一种,普通添加,最常用:
	$('li').css({
		'width' : 100,
		'height' : 100,
		'background' : 'green',
		'font-size' : 25
	})

	$('div').addClass('one');
第二种:动画添加
	$('li').animate({
		'width' : 100,
		'height' : 100,
		backgroundColor : 'green',
		'font-size' : 25
	},100)

//第三种,直接链式操作元素:
	//end()结束方法 结束最近的一次节点过滤操作
	$('ul').children().css({
		'width' : 100,
		'height' : 100,
		'background' : 'green',
		'font-size' : 25
	}).end().next().addClass('one')
=====================================================================
【隐式送代】【jq隐式送代】【jq循环】[jq隐式送代][隐式送代][jq循环]

	三种方式循环:
	【each(callback)】
	【$(元素名).map(callback)
	【$.map(callback)】
	【$.each(callback)】ajax中使用,回调函数有两个参数,可自定义.第一个是索引值,第二个是表示内容.
	
	
	※注:匿名函数有两个参数,参数的位置,必须第一个是索引值,第二个是元素
	     如果使用第二个参数,记得把他转换为jq对象,使用$()

	→ DOM结构:
	<ul>
		<li>我是li</li>
		<li>我是li</li>
		<li>我是li</li>
	</ul>

	→ jq代码:
	//给页面中所有li添加样式
	//对于所有li都添加上样式
	$('li').css({
		'color' : 'red'
	})

	//访问下每个li的文本内容
	var $txt = $('li').text();
	console.log($txt);

	//map()
	//each()

	//两种使用方式
	//$.map(元素,function(){})
	//元素.map(function(){})

	//使用map()方法给所有li添加样式
	$('li').map(function (index,ele) {
		//此时可以直接用this
		$(this).css({
			'color' : 'blue'
		})
		console.log(ele);
		//匿名函数有两个参数,参数的位置,必须第一个是索引值,第二个是元素
		//如果使用ele,记得把他转换为jq对象
		$(ele).css({
			color :  'red'
		})

		//输出每个li的文本信息
		console.log($(ele).text());
		console.log($(this).eq(2));
	})

	//使用each()



事件命名方法:
	jQuery二级事件代码:
	$('#test').on('click.1数字,中文符号都支持',function(){
		alert(1)
	})

	$('#delegate').on('click',function(){
		$('#test').off('click.1数字,中文符号都支持');
	})
	
	※注:这里在事件后面【.】可自定义名称,根据名称来使用off关闭事件,因为这里事件实际上使用的是对象,所以可以在里面添加属性名,并进行操作
	
	jQuery的0级事件使用unbind来取消
	$('#test').click(function(){
		alert(1)
	})
	$('#delegate').click(function(){
		$('#test').unbind('click');
	})
	原生javaScript,必须使用匿名函数命名,然后再移除事件
	test.addEventListener('click',fn = function(){
		alert(1);
	})
	delegate.addEventListener('click',function(){
		test.removeEventListener('click',fn);
	})
	






【JQ】[JQ]
============================【锋利的jQuery记录】========================


检测元素属性是否存在
	【$cr.is.(:checked)】

	解决prototype.js库的$冲突
	【jQuery.noConflict();】
	PS:开头是小写,第二个字母是大写,不要习惯性写成全小写,或前两个字母都大写,这样会报错
==============================================================
	【prototype.js】库使用和DOM操作相同,但只能使用ID来获取,需要元素名和class时,直接使用DOM里的获取document.getElementById....来用变量存装,再调用变量就好
	
	【prototype.js】如果jQuery和其他库同时使用,直接将$给其他库就好
	【jQuery.noConflict();】← 一定要先写这个,否则会报错
	示例:
	var a2 = document.getElementsByClassName('a1')[0];
	$(a2).style.display = 'none'; 


【第一种方法:】
把$控制权让给其他库,使用jQuert变量来继续操作
 jQuery.noConflict();
        jQuery(function(){
            jQuery('button:nth-of-type(1)').click(function(){
                alert(1);
            })
        })
    var a2 = document.getElementsByClassName('a1')[0];
    $(a2).style.display = 'none'; 
【第二种方法:】比较推荐使用 相当于快捷方式
用变量来存放jQuery.noConflict();来使用这个变量来进行操作
	var $q = jQuery.noConflict();
            $q(function(){
                $q('#click').click(function(){
                    alert(1);
                })
            })
        $('hide').style.display = 'none'; 
【第三种方法:】
不改变$变量
在函数内部的形参添加$,直接在函数内部就能继续使用$,因为jQuery本身就是使用闭包的形式
 	jQuery.noConflict();
             jQuery(function($){
                $('#click').click(function(){
                    alert(1);
                })
            })
【第四种方法:】最推荐使用,改变最少代码来实现全面兼容性
不改变$变量,利用闭包形式进行在内部使用
jQuery.noConflict();
            (function($){
            $(function(){
                $('#click').click(function(){
                    alert(1);
                })
            })
            })(jQuery)
【第四种方法:】最先推荐使用
	jQuery库在其他库之前导入,就不用写
	jQuery.noConflict();


为了能有更快的选择器解析速度,从1.1.3.1版以后,jQuery废弃了不常使用的XPath选择器,但在引用相关插件后,依然可以支持XPath选择器



使用【元素.toggle(fun1,fun2)】只有jQuery V1.3的版本才能显示/隐藏,来回切换，更高版本不支持，会变成元素本身动画的显示隐藏

 $('li:gt(5):not(:last)').hide();
        //
            $('.menu>a').toggle(function(){
                    $('.menu a').text('精简显示品牌');
                    $('li:gt(5):not(:last)').show();
                    $('ul li a').filter(":contains('佳能'),:contains('尼康'),:contains('奥林巴斯')")
                            .css("color",'red')
            },function (){
                     $('.menu a').text('显示全部品牌');
                         $('li:gt(5):not(:last)').hide();
                     $('.ul li a').filter(":contains('佳能'),:contains('尼康'),:contains('奥林巴斯')")
                            .css("color",'')
           })

【案例】【示范】[案例][示范]




1.【DOM Core】
	一般来说:DOM操作分为3个方面，即DOM Core（核心）,HTML-DOM和CSS-DOM.
【Core核心】

DOM Core并不专属于javaScript，任何一种支持DOM的程序设置语言都可以使用它。它的用法并非仅限于处理网页，也可以用来处理任何一种标记语言编写出来的文档，例如XML.

DOM获取表单对象的方法:
	docuemnt.getElementsByTagName('form')
DOM来获取某元素的src属性的方法
	ele.getAttribute('src')

2.【HTML-DOM】[HTML-DOM]
	在使用 javaScript 和 DOM 为HTML 文件编写脚本时，有许多专属于HTML-DOM 的属性。HTML-DOM的出现甚至比DOM Core还要早，它提供了一些更简明的记号来描述各种HTML元素的属性。
	使用HTML-DOM来获取表单对象的方法
	document.forms //HTML-DOM来获取表单对象的方法
	使用HTML-DOM 来获取某元素的src属性的方法
	ele.src
	
	→【如果页面元素(标签)设置了ID,根本不用再get...获取,直接使用HTML-DOM来进行操作就好】
		ID权级大于标签,就算定义ID为id或img也能使用,但要是定义了全局变量和id相同,那么就等于变量赋值.ID权值 小于 直接变量定义,其实就是就近原则,从上往下执行,定义的变量进行二次赋值,把之前和id相同的值给覆盖了.
		ID.value
		ID.innerHTML
		ID.innerText
		ID.type
		ID.name
		ID.id
		ID.class
		ID.nodeType
		ID.ELEMENT_NODE
	☞※注:必须将<script>标签放到最后,因为必须等html结构全部加载完毕,才能执行.如果放入<head>标签内,还没加载完html结构就执行了,所有才无法实现效果
	→如果一定要将js代码放到head内,还想使用HTML-DOM,或者放在外部文件内,想同样使用HTML-DOM,那么就添加【window.onload = function(){代码块}】将js代码都写在代码块内就好,因为是等htnl所有内容都加载完毕才执行,所以就能使用HTM-DOM的id.要明白这里的id是object对象的属性

	id开头必须是英文,无论大小写,开头不支持$和_,更不支持-,
	从第2个字母开始支持大小写,数字,$和_,但不支持-


属于某些对象，属性即可用DOM实现，也可用HTML-DOM来实现。HTML=DOM通常比较简短，不过它只能用来处理Web文档

	1.动态创建的新元素节点不会被自动添加到稳定中，而是需要使用其他放啊将其插入文档中。
	2.当创建单个元素时，要注意闭合标签和使用标准的XHTML格式。
	例如创建一个<p>元素，可以用【$('<p/>')】或者【$('<p></p>')】,但不要使用$('p')或则大写的$('P')

3.2.3 【插入节点】
	【append()】向每个匹配的元素内部追加内容,【添加元素在后】
	【appendTo()】将所有匹配元素追加到指定元素中,颠倒了常规,【添加元素在前】
		appendTo方法也可以用来移动元素
		移动元素时首先从文档上删除此元素,然后将该元素插入得到文档中的指定节点

	→※注:appendTo()括号后面不能添加写$(),否则会报要添加元素不存在错误,直接写标签名,#ID名,.class类名就好

	【prepend()】向每个匹配的元素内部前置内容【也就是添加元素到first开头】
	【prependTo()】将所有匹配的元素指定到指定的元素中,颠倒了常规,【添加元素在前】

	【after()】在每个匹配的元素之后插入内容【添加元素在后】
	【insertAfter()】将所有匹配的元素插入到指定元素的"后面",颠倒了常规,【添加元素在前】
	
	【before()】在每个匹配的元素之前插入内容【添加元素在后】
	【insertBefore()】将所有匹配的元素插入到指定元素的"前面",颠倒了常规,【添加元素在前】
	
可以使用插入来实现替换功能
	$后面元素.insertBefore($前面元素);
	PS:必须这两个元素都是相邻的兄弟关系才能替换,否则不能生效,其实使用的就是冒泡排序
	
3.2.4【删除节点】
	【remove()】作用是从DOM中删除所有匹配的元素,传入的参数根据前者jQuery表达式来筛选元素
		比如$('ul li:eq(1)').remove();
		使用该remove()方法删除节点,该节点的所有后代节点将同时删除
		这个方法返回值是一个指定已被删除的节点的引用.因此可以再以后再声明变量使用这些元素.
	PS:使用remove()删除元素的话,那么它之前绑定的事件将失效.

	【detach()】分离 jQuery分离
		去掉DOM所有匹配的元素.但需注意,这个方法不会把匹配的元素从jQuery对象中山城,因而可以在将来再使用这些匹配的元素.与remove()不同的是,所有绑定的事件,附加的数据等都会保留下来.
	
	【empty()】空的,严格来讲,empty()方法并不是删除节点,而是清空节点,它能清空元素中的所有后代节点.
	$('ul li:eq(1)).empty();
		//获取第2个li元素节点后,清空此元素里的内容,注意是元素里

	【clone()】
		参数【true】是深度复制,包括当前元素捆绑事件
		不填默认是false

3.2.6【替换节点】
	【replaceWith】将所有匹配元素都替换指定的HTML元素或DOM元素
		With和
		例如$('p').relaceWith('<strong>后者这里是要替换标签</strong>');
	【replaceAll】和replaceWith使用方法相同,但颠倒了顺序
		;例如$('<strong>后者这里是要替换标签</strong>').relaceAll('p');原先绑定的事件将会
	注意:如果在替换之前,已经为元素绑定时间,替换后原先绑定的事件将会与被替换的元素一起消失,需要在新元素上重新绑定事件.
	
3.2.7 【包裹节点】
	如果要将某个节点用其它标记包裹起来,jQuery提供了相应的方法
	【wrap()】将所有元素进行单独的包裹
		wrap包,缠绕
		该方法对于需要在文档中插入额外的结构化标记非常有用
		$('strong').wrap('<b></b') //用p标签把<strong>元素包裹起来
	【wrapAll】将所有的匹配元素用一个元素来包裹
		※如果包裹的多个元素间有其它元素,其它元素会被放到包裹元素之后
	【wrapInner】该方法将每一个匹配的元素的子内容(包括文本节点)用其他结构化的标记包裹起来.例如可以使用它来包裹<strong>
		$('strong').wrapInner('<span/>') //包含子节点
3.2.8 属性操作
	
	【attr()】获取和设置元素,一个值获取属性,一个值设置元素,记得用引号
		如果需要给元素设置多个属性,使用{}对象,键值对来设置
	※jQuert中的很多方法都是同一个函数实现获取(getter)和设置(settter)的,例如上面的attr()方法,既能设置元素属性的值,也能获取元素属性的值,类似的还有html(),text(),height(),width(),val(),css()等方法
	【removeAttr()】删除设置,括号加引号写属性名
	※jQuery1.6中新增prop()和removeProp,分别用来获取在匹配的元素集中的第一个元素的属性值和为匹配的元素删除设置的属性

3.2.9 【样式操作】
	class也是属性,所以可以直接使用attr来获取或删除
	【addClass()】追加样式
	(1)如果给一个元素添加了多个class值那么久相当于合并了它们的样式.
	(2)如果有不同的class设定了样式属性,则后者覆盖前者
	【removeClass()】移除样式,如果要删除多个样式,只要用空格隔开就好,不带参数.就是删除全部参数
	【toggle(fun1,fun2)】交替两个动作,在js使用,且版本必须为 v1.3的版本
	【toggleClass("")】控制样式的重复切换,如果类名存在则删除它.如果不存在则添加它,不改变原类名
5.判断是否含有某个样式
	【hasClass("")】可以用来判断元素中是否含有某个class,如果有,则返回true.否则返回false
	※注意:这个方法是为了增强代码可读性而产生的.在jQuery内部实际上是调用了is()方法来完成这个功能的.该方法等价于如下代码
	【is】【is(".class")】[is]判断类名是否存在,存在true,不存在false
		括号内可以直接填#ID和.Class类,来判断是否存在

3.2.10 【设置和获取 HTML,文本和值】
	【html()】等同于js中的innerHTML属性,可以用来读取或者设置某个元素中的HTML内容.
	※注意:html()方法可以用于XHTML文档,但不能用于XML文档
	【text()】等同于js中innerText属性,可以用来读取或者设置某个元素中的文本内容.
	※注意:
		(1)js中的innerHTML属性并不能在Firefox浏览器下运行,而JQuery的text()方法支持所有的浏览器
		(2)tetx()方法对HTML文档和XML未绑定都有效

	【val()】类似于JavaScript中的value属性,可以用来设置和获取元素的值.无论元素是文本框,下拉列表还是单选框,它都可以返回元素的值.如果元素为多选,则返回一个包含所有选择的值的数组
	※注意:focus()方法相当于JavaScript中的onfocus()方法,处理获得焦点时的事件
	$('#password').focus(){
		var txt = $(this).val();
		if(txt.value == '请输入邮箱密码'){
		$(this).val('');
		}
	}
	
	$('#password').blur(){
		var txt = $(this).val();
		if(txt.value == ''){
		$(this).val('请输入邮箱密码');
		}
	}
	在该例子,也可以使用表单元素的defaultValue属性来实现同样的功能,defaultValue属性包含该表单元素的初始值.
	this指向当前文本框,【this.defaultValue】表示当前设置value默认值.
	
	网页中一些元素时默认选中,可以通过val()方法来改变它们的选择,
比如下拉列单opton
	$('#single').val('选择2号');
	多个被选中
	$('#single').val(['选择2号','选择3号']); //以数组的形式赋值

3.2.11 【遍历节点】

	【children()】获得匹配元素的子元素集合
		※children()方法只考虑子元素而不考虑后代
	【next()】取得匹配元素后面的紧邻的同辈元素

	【prev()】取得匹配元素前面的紧邻的同辈元素
	【siblings()】取得匹配元素前后所有的同辈元素
	【closest()】取得最近的匹配元素.首先检查当前元素是否匹配,如果匹配则直接返回元素本身.如果不匹配则向上查找父元素,逐级向上直到找到配选择器的元素.如果什么都没找到则返回一个空的jQuery对象
	
	6.parent(),parents()与closest()的区别
		→【parent()】获得集合中每个匹配元素的父级元素
			$('.item1').parents().css()
			从指定类型的直接父节点开始查找,返回一个元素节点

		→【parents()】获得集合中每个匹配元素的祖先元素
			$('.item1').parents('ul').css()
			当它找到一个父节点时并没有停止查找,而是继续查找,最终返回多个父节点

		→【closest()】从元素本身开始,逐级向上级元素匹配,并返回最新匹配的祖先元素
			$('.item1').closest('ul').css()
			查找从包含自身的节点找起,它同parents()方法类似,不同点就在于它只返回匹配的第一个元素节点
		除此之外,在jQuery中还有很多遍历节点的方法,例如find(),fiter(),nextAll()和prevAll()等
	这些遍历DOM方法有一个共同点,都可以使用jQuery表达式作为它们的参数俩筛选元素		


3.2.12 CSS-DOM操作
	CSS-DOM操作
	style属性很有用,但最大不足是无法通过它来提取到通过外部CSS设置的样式信息,然而在jQuery中,这些都是非常简单

	1.【$().css({})】
		(1)如果值是数字,将会自动转化为像素值
		(2)在css()方法中,带有"-"连接符,使用""引号包裹或直接使用驼峰命名法

	对透明度的设置,可以直接使用opacity属性,jQuery已经处理好兼容性问题
		$('p).css('opacity','0.5');
	2.【$('p').height()】获取元素的高
		默认是px,若想改成度量单位,,例如em,则$('p').height('10em')
	【css('height')】也可以直接这样使用

	2.【$('p').width()】获取元素的宽
		【$('p').width('400px')】

	3.【offset()】获取元素在当前视窗的相对偏移,返回的对象包含两个属性,即top和left
	【position()】获取相对于最近的position样式属性为relative或者absolute的祖父节点的相对偏移,也包含两个属性,top和left

	4.【scrollTop()】和【scrollLeft()】分别是获取元素的滚动条距顶端的距离和据左侧的距离.
		可以添加参数
		scrollTop(200)不加px
	
	【封装滚动函数】[封装滚动函数]
        function scroll() {
            if(window.pageYOffset != null)  //  ie9+ 和其他浏览器
            {
                return {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                }
            }
            else if(document.compatMode == "CSS1Compat")  // 声明的了 DTD
            // 检测是不是怪异模式的浏览器 -- 就是没有 声明<!DOCTYPE html>
            {
                return {
                    left: document.documentElement.scrollLeft,
                    top: document.documentElement.scrollTop
                }
            }
            return { //  剩下的肯定是怪异模式的
                left: document.body.scrollLeft,
                top: document.body.scrollTop
            }
        }


	【返回顶部】
		DOM结构:
			<button>返回顶部</button>
		jacascript代码:
		/*
		 页面向下滚动100px,出现按钮
		 点击按钮,实现返回顶部
		 */
		window.onload = function () {
			//获取按钮
			var btn = document.getElementsByTagName('button')[0];
			//页面滚动事件
			window.onscroll = function () {
				//是否出现按钮
				if(scroll().top >= 100){
					//出现按钮
					btn.style.display = 'block';
				} else {
					btn.style.display = 'none';
				}
			}
			
			//点击按钮事件
			btn.onclick = function () {
				//scrollTo() 滚动到指定位置
				//第一个参数:水平方向位置
				//第二个参数:垂直方向位置
				window.scrollTo(0,0);
			}
		}

	
	【滚动事件】
	/*
	  	滚动事件:
	 	onscroll
	 	onscrollTop:兼容性问题DTD 标准浏览器 IE浏览器
	 	onscrllLeft
	 */
	window.onscroll = function () {
		console.log($scroll()['top']);
	}
	
	//封装监视下拉框的top高的值,还有left的值
	//在调用函数()后使用.点top,点left来使用,也可以使用['top'],['left']来使用
	function $scroll() {
		//IE9+ 和其他浏览器
		if(window.pageYOffset != null){
			return{
				left : window.pageXOffset,
				top: window.pageYOffset
			}
		} else if(document.compatMode == 'CSS1Compat'){ //声明的了DTD ,检测是不是怪异模式的浏览器 --就是没有 声明 <!DOCTYPE html>
			return {
				left : document.documentElement.scrollLeft,
				top : document.documentElement.scrollTop
			}
		}
		
		return { //剩下的肯定是怪异模式的
			left : document.body.scrpllLeft,
			top : document.body.scrollTop
		}
	}
		








案例研究-超链接提示和图片提示效果
【title提示】【案例文件】【title】[title][案例文件][title提示]
	文字提示
DOM结构:
	<p><a href="#" class="tooltip" title="这是我的超链接提示1.">提示1.</a></p>
	<p><a href="#" class="tooltip" title="这是我的超链接提示2.">提示2.</a></p>
	<p><a href="#" title="这是自带提示1.">自带提示1.</a></p>
	<p><a href="#" title="这是自带提示2.">自带提示2.</a> </p>
js代码:
	var x = 10;
	var y = 20;
	$("a.tooltip").mouseover(function(e){
       	this.测试 = this.title;
		this.title = "";
	    var tooltip = "<div id='tooltip'>"+ this.测试 +"</div>"; //创建 div 元素
		$("body").append(tooltip);	//把它追加到文档中
		$("#tooltip")
			.css({
				"top": (e.pageY+y) + "px",
				"left": (e.pageX+x)  + "px"
			}).show("fast");	  //设置x坐标和y坐标，并且显示
    }).mouseout(function(){
		this.title = this.测试;
		$("#tooltip").remove();   //移除
    }).mousemove(function(e){
		$("#tooltip")
			.css({
				"top": (e.pageY+y) + "px",
				"left": (e.pageX+x)  + "px"
			});
	});


	图片提示
DOM结构:
	<h3>有效果：</h3>
		<ul>
			<li><a href="images/apple_1_bigger.jpg" class="tooltip" title="苹果 iPod"><img src="images/apple_1.jpg" alt="苹果 iPod" /></a></li>
			<li><a href="images/apple_2_bigger.jpg" class="tooltip" title="苹果 iPod nano"><img src="images/apple_2.jpg" alt="苹果 iPod nano"/></a></li>
			<li><a href="images/apple_3_bigger.jpg" class="tooltip" title="苹果 iPhone"><img src="images/apple_3.jpg" alt="苹果 iPhone"/></a></li>
			<li><a href="images/apple_4_bigger.jpg" class="tooltip" title="苹果 Mac"><img src="images/apple_4.jpg" alt="苹果 Mac"/></a></li>
</ul>


js代码:
$(function(){
	var x = 10;
	var y = 20;
	$("a.tooltip").mouseover(function(e){
		this.myTitle = this.title;
		this.title = "";
		var imgTitle = this.myTitle? "<br/>" + this.myTitle : "";
		var tooltip = "<div id='tooltip'><img src='"+ this.href +"' alt='产品预览图'/>"+imgTitle+"<\/div>"; //创建 div 元素
		$("body").append(tooltip);	//把它追加到文档中
		$("#tooltip")
			.css({
				"top": (e.pageY+y) + "px",
				"left":  (e.pageX+x)  + "px"
			}).show("fast");	  //设置x坐标和y坐标，并且显示
    }).mouseout(function(){
		this.title = this.myTitle;
		$("#tooltip").remove();	 //移除
    }).mousemove(function(e){
		$("#tooltip")
			.css({
				"top": (e.pageY+y) + "px",
				"left":  (e.pageX+x)  + "px"
			});
	});
})






→ 4.1 jQuery中的事件 ←
4.1.1 加载DOM
	→【$(document).ready((function(){})】和【$(function(){})】功能相等
		在DOM加载完毕就可以调用,并不意味关联文本都已下载
	当$()不带参数时,默认参数就是document,所以也可以【$().ready((function(){})】
		
	→【load()】等同于【window.onload()】网页中所有的元素(包含元素的所有关联文件)完全加载到浏览器才执行
	url,[data,[callback]]	String,Map/String,Callback	V1.0
	url:待装入 HTML 网页网址。
	data:发送至服务器的 key/value 数据。在jQuery 1.3中也可以接受一个字符串了。
	callback:载入成功时回调函数。

	→【bind(type,[,data],fn)】绑定事件,1.7版本被on顶替
		bind()方法有3个参数,说明如下.
	第一个参数是事件类型,类型包括:blur,focus,load,resize,scroll,unload,click,dblclick,mousedown,submit,keydown,keypress,keyup和error等,当然也可以是自定义名称
	第二个参数为可选参数,作为event.data属性值传递给事件对象的额外数据对象
	※注意:可以发现jquerty的事件少了on前缀
	
	$(this).next()被多次使用,因此可以为它定义一个局部变量
	var $content = $(this).next();
	※注意:当发现相同的选择器在你的代码里出现多次时,请用变量把它缓冲起来
	→【unbind(event,fn)】取消绑定事件
	在当用户离开页面时，会发生 unload 事件。

	具体来说，当发生以下情况时，会发出 unload 事件：

	点击某个离开页面的链接 
	在地址栏中键入了新的 URL 
	使用前进或后退按钮 
	关闭浏览器 
	重新加载页面 

4.1.3 合成事件
	jQuery有两个合成事件-hover()方法和toggle(),类似ready()方法,hover()方法和toggle()方法都属于jQuery自定义的方法
	1.→【hover(enter,leave)】如果只是点击显示/隐藏 切换,推荐使用这种方法
		enter开始
		leave离开
	※注意:使用hover()如果离开事件fadeOut(),不支持直接写时间,不生效,只能写'fast'或'slow'
	V1.4.3及以上版本才支持毫秒数
	※注意:
		(1)CSS中有伟类选择符,例如":hover",当用户光标悬停在元素上时,会改变元素的外观.在大多数符合规范的浏览器中,伪类选择符可以用于任何元素.然而在IE 6浏览器中,伪类选择符仅可用于超链接.对于其他元素,可以使用jQuery的hover().
		(2)hover方法准确来说是替代jQuert中的bind('mouseenter')和bind('mouseleave'),而不是替代bind('mouseover')和bind('mouseout').因此当需要触发hover()方法的第2个函数时,需要用trigger('mouseleave')来触发,而不是trigger(''mouseout)

	→【mouseover([[data],fn])】鼠标穿过事件
	与 mouseover 事件不同，只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。如果鼠标指针穿过任何子元素，同样会触发 mouseover 事件。
		fn(){}	Function V1.0 
			在每一个匹配元素的mouseenter事件中绑定的处理函数。

		[data],fn	String,Function V1.4.3 
			data:mouseenter([Data],fn) 可传入data供函数fn处理。
			fn:在每一个匹配元素的mouseenter事件中绑定的处理函数。

	→【mouseleave([[data],fn])】鼠标离开事件
		当鼠标指针离开元素时，会发生 mouseleave 事件。该事件大多数时候会与mouseenter 事件一起使用。
	与 mouseout 事件不同，只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。如果鼠标指针离开任何子元素，同样会触发 mouseout 事件。

	fn	FunctionV1.0
	在每一个匹配元素的mouseleave事件中绑定的trigger()处理函数。

	[data],fn	String,Function V1.4.3
	data:mouseleave([Data], fn) 可传入data供函数fn处理。
	fn:在每一个匹配元素的mouseleave事件中绑定的处理函数。
================================================
	→【toggle()】点击切换事件
		用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。
如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。

	→fn,fn2,[fn3,fn4,...]	Function,....	V1.0
		fn:第一数次点击时要执行的函数。
		fn2:第二数次点击时要执行的函数。

	→fn3,fn4,...:更多次点击时要执行的函数。
	[speed] [,fn]	String,FunctionV1.0
		speed: 隐藏/显示 效果的速度。默认是 "0"毫秒。可能的值：slow，normal，fast。"
		fn:在动画完成时执行的函数，每个元素执行一次。

	→[speed], [easing ], [fn] 	String,String,Function	V1.4.3
		speed: 隐藏/显示 效果的速度。默认是 "0"毫秒。可能的值：slow，normal，fast。"
		easing:(Optional) 用来指定切换效果，默认是"swing"，可用参数"linear"
	fn:在动画完成时执行的函数，每个元素执行一次。

	→switch Boolean	V1.3
	用于确定显示/隐藏的开关。如：true - 显示元素，false - 隐藏元素


4.1.4 事件冒泡
	→什么是冒泡
	在页面上可以有多个事件,也可以多个元素响应同一个事件.假设网页上有两个元素,其中一个元素嵌套在另一个元素里,并且都被绑定了click事件,同时<body>元素上也绑定了click事件.

	→事件对象
	由于IE-DOM和标准DOM实现事件对象的方法各不相同,导致在不同浏览器中获取事件对象变得比较困难.针对这个问题,jQuert进行了必要的扩展和封装,从而使得在任何浏览器中都能很轻松地获取事件对象以及事件对象的一些属性.
		在程序中使用事件对象非常简单,只需要为函数添加一个参数
	这样,当点击'element'元素时,事件对象就被创建了.这个事件对象只有事件处理函数才能访问到.事件处理函数执行完毕后,事件对象就被销毁.

	→停止事件冒泡
	【event.stopPropagation()】
	停止时间冒泡可以阻止事件中其他对象的事件处理函数被执行.在jQuert中提供了stopPropagation()方法来停止事件冒泡
	比如
	#().on('click',function(event){
		event.stopPropagation();
	})
这样就只会触发当前事件,而不会触发其他DOM父级点击事件
	

	→阻止默认行为
	【peventDefault();】

	→【return false;】在事件内添加,阻止冒泡和默认行为,强烈推荐
		如果想同时对事件对象停止冒泡和默认行为,可以在事件处理函数中返回false.这是对在事件对象上同时调用event.stopPropagation()和peventDefault()方法的一种简写方式.

	→阻止默认行为

	事件捕获和事件冒泡是刚好相反的两个过程,事件捕获是从最顶端往下开始触发.
	遗憾的是:并非所有主流浏览器都支持事件捕获,并且这个缺陷无法通过JavaScript来修复.jQuery不支持事件捕获,如果需要使用,直接使用原生javaScript

	事件的三大过程
		【冒泡/目标/捕获】

	捕获:
		根节点/目标节点
	
4.1.5 事件对象的属性
	jQuery在遵循W3C规范的情况下,对事件对象的常用属性进行了封装,使得事件处理在各大浏览器都可以正常运行而不需要进行浏览器类型判断

	(1)【event.type】获取到时间的类型
		0级事件(jq版):
		$('a').click(function(event){
			console.log('event.type'); //获取事件类型
			return false;
		})
		2级事件(jq版):
		$('a').on('click',function(e){
			console.log(e.type)
			return false;
		})

		2级事件(原生js):
		var a = document.getElementsByTagName('a')[0];
		var fn = function(e){
			console.log(e.type)
			e.preventDefault();
		}
		a.addEventListener('click',fn);

	(2)【peventDefault()】以上已介绍
		该方法是阻止默认的事件行为.JavaScript中符合W3C规范的preventDefault()方法在IE浏览器中却无效,jQuery对齐进行了封装,使之能兼容各种浏览器
	(3)【event.stopPropagation()】以上已介绍
		该方法是阻止事件的冒泡.JavaScript中符合W3C规范的preventDefault()方法在IE浏览器中却无效,jQuery对齐进行了封装,使之能兼容各种浏览器
	(4)【event.targe】作用是获取到触发事件的元素.jQuery对其封装后,避免了各个浏览器不同标准的差异.
	$("a").click(function(event) {
	  alert(event.target.href);//获取触发事件的<a>元素的href属性值
	  return false;//阻止链接跳转
	});
	(5) 【event.relatedTarget()】
		在标准DOM中,mouseover和mouseout所发生的元素可以通过event.target来访问,相关元素是通过 event.relatedTarget来访问的.event.relatedTarget 在mouseover中相当于IE浏览器的event.fromElement,在mouseout中相当于IE浏览器的event.toElement,jQuery对其进行了封装,使之能兼容各种浏览器
	(6) 【evet.pageX】和【event.pageY】
	该方法的作用是获取到光标相对于页面的x坐标和y坐标.如果没有使用jQuery时,那么IE浏览器是用event.x/event/y,而在Firefox浏览器是用event.pageX/event.pageY.如果页面上有滚动条,则还要加上滚动条的宽度或高度
	(7)【evet.which】作用是鼠标点击时获取到鼠标的左右键;在键盘事件中获取键盘的按键.比如获取鼠标的左,右,中键:
	 1 = 鼠标左键 left;
	 2 = 鼠标中键;
	 3 = 鼠标右键
	【$().keyup(function(){})】键盘离开事件
	//获取键盘的按键
	$('input').keyup(function(e){
		console.log(e.which);	
	})
	(8)【event.metaKey】按Ctrl键加其他键,返回true和false
	   【event.ctrlKey】按Ctrl键加其他键,返回true和false
	针对不同浏览器对键盘中的<ctrl>按键解释不同,jQuery也进行了封装,并规定event.metaKey为键盘事件中获取<ctrl>按键

	注意:更多的event的属性和方法可以访问:http://docs.jquery.com/Events/jQuery.Event
	
4.1.6	移除事件
	在绑定事件的过程中,不仅可以为同一个元素绑定多个事件,也可以为多个元素绑定同一个事件.假设网页上有一个<button>元素

	→【unbind([type],[data])】
		第1个参数是事件类型,第2个参数是将要移除的函数
		(1) 如果没有参数,则删除所有的绑定的事件.
		(2) 如果提供了事件类型作为参数,则只删除该类型的绑定事件
		(3) 如果把在绑定时传递的处理函数作为第2个参数,则只有这个特定的事件处理函数会被删除
	
	2.移除<button>元素的其中一个事件
	首先需要为这些匿名代理函数指定一个变量
	$('#btn').bind("click", myFun1 = function(){
					 $('#test').append("<p>我的绑定函数1</p>");
			  }).bind("click", myFun2 = function(){
					 $('#test').append("<p>我的绑定函数2</p>");
			  }).bind("click", myFun3 = function(){
				  	 $('#test').append("<p>我的绑定函数3</p>");
		      });
	然后就可以单独删除某一个事件了
	   $('#delTwo').click(function(){
			  $('#btn').unbind("click",myFun2);
	   });

	→【one([type],[data])】结构与bind()方法类似,使用方法相同
		$().one(function(){})
		另外,对于只需要触发一次,随后就要立即解除绑定的情况,jQuery提供了一种简写方式-one()方法.one()方法可以为元素绑定处理函数.当处理函数触发一次后,立即被删除.即在每个对象上,事件处理函只会被执行一次
	使用one()方法为<button>元素绑定单击事件后,只在用户第1次单击按钮时,处理函数才执行,之后的单机毫无作用
	※注意:jQuery 1.7版本中新增了 【on()】,【off()】,【delegate()】和【undelegate()】事件绑定
	

	【$.event】移除事件,包含事件各种方法,在插件时使用
	可以使用$.event.remove(this,'click')
	
	移动自身事件,直接
		$.event.remove(this,'click')
	如果要移除其他事件:
	 $('#box').on('click',function(){
            _this = this; ←声明个全局变量保存这个this,指向同一个内存堆
            alert(1)
        })

        $('button').on("click",function(){
            $.event.remove(_this,'click'); ←再通过这个全局变量,移除内存堆事件
        })

Object{global: Object, props: Array[13], fixHooks: Object, keyHooks: Object, mouseHooks: Object…}
add:function(elem, types, handler, data, selector)
dispatch:function(event)
fix:function(event)
fixHooks:Object
global:Object
handlers:function( event, handlers )
keyHooks:Object
mouseHooks:Object
props:Array[13]
remove:function(elem, types, handler, selector, mappedTypes )
simulate:function( type, elem, event, bubble )
special:Object
trigger:function(event, data, elem, onlyHandlers )
__proto__:Object
	

4.1.7 模拟操作

	→1.常用模拟

	以上的例子都是用户必须通过单击按钮,才能触发click事件,但是有时,需要通过模拟用户操作,来达到单击的效果.例如在用户进入页面后,就触发click事件,而不需要用户去主动单击
	在jQuery中,可以使用trigger()方法完成模拟操作.例如可以使用下面的代码来触发id为btn的按钮的click事件.
	 $('#btn').bind("click", function(){
					 $('#test').append("<p>我的绑定函数1</p>");
			  }).bind("click", function(){
					 $('#test').append("<p>我的绑定函数2</p>");
			  }).bind("click", function(){
				  	 $('#test').append("<p>我的绑定函数3</p>");
		      });
	想要触发这个事件,可以使用以下代码来实现:可以重复使用,使用一次代表调用一次
	   $('#btn').trigger("click");
	
	→3.传递数据
	【trigger(type,[data])】方法有两个参数,第1个参数是要触发的事件类型,第2个参数是要传递给事件处理函数的附加数据,以数据形式传递.通常可以通过传递一个参数给回调函数来区别这次事件时代码触发的还是用户触发的.
	trigger触发
	 $('#btn').bind("myClick", function(){
					 $('#test').append("<p>我的自定义事件.</p>");
	  });
	   $('#btn').click(function(){
			$(this).trigger("myClick");
	   })
	.trigger("myClick");

	→4.执行默认操作
	【trigger()】方法触发时间后,会执行浏览器默认操作【触发事件】
		例如:
		$('input').trigger('focus');
	以上代码不仅会触发<input>元素绑定的focus事件,也会使<input>元素本身得到焦点(这是浏览器的默认操作)
	$('input').focus(function(){
            console.log(this.value)
         })
	
	如果只想触发绑定的focus事件,而不想执行浏览器默认操作,可以使用jQuery中另一个类似的方法-triggerHandler()方法

	→【triggerHandler()】触发 处理
		handler处理
	该方法会触发<input>元素上绑定的特定事件,同时取消浏览器对此事件的默认操作,即文本框只触发绑定的focus事件,不会得到焦点


4.1.8 其他用法
	前面已经对bind()方法进行了介绍,bind()方法不仅能为元素绑定浏览器支持的具有相同名称的事件,也可以绑定自定义事件.不仅如此,bind()方法还能做很多的事情.

	→【绑定多个事件类型】
	$("div").on("mouseover mouseout", function(){
        	$(this).toggleClass("over");
    	 });
	用于在一个事件,不适合tab切换和下拉列表中
	1.适合用于轮播的移上去停止自动轮播,移出继续自动轮播
	2.适合用于移动元素上去显示提示文本
	3.鼠标移入改变背景色或字体颜色,移出恢复
	
2.添加事件命名空间,便于管理
		例如可以把元素绑定的多个事件用命名空间规范起来
		$("div").bind("click.自定义名称",function(){
	      	 	$("body").append("<p>click事件</p>");
		});
		$("div").bind("mouseover.自定义名称", function(){
	       		$("body").append("<p>mouseover事件</p>");
		});
		$("div").bind("dblclick", function(){
		  	 $("body").append("<p>dblclick事件</p>");
		});
		$("button").click(function() {
			$("div").unbind(".自定义名称");
		})

	→根据【event.自定义名称】可以同时删除同一个元素绑定多个事件,比较方便,较推荐
		在所绑定事件类型后面添加命名空间,这样再删除事件时只需要指定命名空间即可.单击<button>元素后,'自定义名称'的命名空间被删除,而不在'自定义名称'的命名空间的dblclick依然存在
	
	删除多个时间代码也可以写成以下链式代码,但显然上面写的更少.
	【$('div').unbind('click').unbing('mouseover');】
	※注意:这是只有jQuery才能使用方法.js的DOM二级事件不能使用命名空间.
	

3.相同事件名称,不用命名空间执行方法
	【trigger(click!)】触发 点击事件
		→这里指的是不执行非click命名的事件,也就是只点击click事件
	$("div").bind("click",function(){
	       $("body").append("<p>click事件</p>");
	});
	$("div").bind("click.plugin", function(){
	       $("body").append("<p>click.plugin事件</p>");
	});
	$("button").click(function() {
		  $("div").trigger("click!");    // 注意click后面的感叹号
	});
 	当当即<div>元素后,会同时触发click事件和click.自定义命名空间事件,如果只是单击<button>元素,则只触发click事件,而不触发click.plugin事件
	※注意:trigger(click!)后面的感叹号的作用是匹配所有不包含在命名空间中的click方法.
	如果需要两者都被触发,去掉感叹号就好

4.2.1 【show()】显示
	当把
      【hide()】隐藏
	与css()方法设置display属性效果相同
	元素隐藏后,可以使用show()方法将元素的display样式设置为先前的显示状态('block')或'inline'或其他除了'none'之外的值
	注意:hide()方法再在将'内容'的display属性的值是'block',当单击'标题'链接执行hide()方法的时候,hide()方法会做两步动作,首先记住内容的display属性的值block,然后把dis要求要在标准模式下效果play属性的值设置为'none';
	当执行show()方法的时候,'内容'的属性的值就会被还原为调用hiden()方法之间的状态
	
	注意:用jQuery做动画要求要在标准模式下,否则肯呢过会引起动画抖动,标准模式即要求文件头部包含以下DTD定义:
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
已解决,只要在开始动画,先使用【stop()】清除动画就会
	可指定参数设置速度,'fast'快,'slow'慢,'normal'正常,单位是毫秒
	从代码执行过程中,可以发现,hide(600)方法会同时减少'内容'的高度,宽度和透明度,直至这3个属性的值都为0,最后设置该元素的CSS规则为'display:none'.
	同理,show(600)方法会从上到下增大'内容'的高度,从左到右增大'内容'的宽度,同时增加'内容'的不透明度,直至新闻内容完全显示

4.2.2 【fadeIn()】方法和【fadeOut()】方法 淡入和淡出方法
	与show()方法不相同的是,fadeIn()方法和fadeOut()方法只改变元素的不透明度.fadeOut()方法会在指定的一段时间内降低元素的不透明度,直接元素完全消失('display:none').fadeIn()方法则相反.
      【slideUp()】方法和【slideDown()】方法 滑动隐藏和滑动显示

	slideUp()方法和slideDown()方法只会改变元素的高度,如果一个元素的display属性值为'none',当调用slideDown()方法时,这个元素将由下到上缩短隐藏

	→注意:jQuery中的任何动画效果,都可以指定3种速度参数,即'slow','normal'和'false'(时间长度分别是0.6秒,0.4秒,0.2秒),当使用速度关键字时要加引号,例如show('slow'),如果用数字作为时间参数时就不需要加引号,例如show(1000)

4.2.4 自定义动画方法【animate()】
	前面已经讲了3种类似的动画.其中show()方法和hide()方法会同时修改元素的多个样式属性,即高度,宽度和不透明度;fadeOut()方法和fadeIn方法只会修改元素的不透明度度,slideDown()方法和silideUo()方法只会改变元素的高度.

	【animate(params,speed,callback)】
	参数说明如下.
	(1) params:一个包含样式属性及值的映射,比如{property:"value",property2,'value'......}
	(2) speed:速度参数,可选
	(3) callback : 在动画完成后执行的函数,可选
	→注意为了使元素动起来,在使用animate()方法前,为了能影响元素的'top','left','bottom','right'样式属性,必须先把元素的position样式设置为relative或则absolute.本例中,设置的是position:relative,有了这个值,就可以调整元素的left属性,使元素动起来.
	
 	$("#panel").click(function(){
	   $(this).animate({left: "500px"}, 3000); //点击只能移动固定到500px
	})

2.累加,累减动画
	在之前的代码中,设置了{left:'500px'}作为动画参数.如果在500px之前加上【+=】或者【-=】符号即表示在当前位置累加或则累减
	$(this).animate({left: "+=500px"}, 3000); //每次在点击后会在原位置移动500px

3.多重动画 【说白了就是添加多个属性键值对】
	 $(this).animate({left: "500px",height:300}, 3000);
	运行代码后,<div>元素在向右滑动的同时,也会放大高度
	
	(2)按顺序执行多个动画,只要分开属性键写就好了
	 $(this).animate({left: "500px"}, 3000)
		.animate({height: "200px"}, 3000);
	这样一来,就满足上文提出的需求了.在'left'这个定位属性改变之前,'height'属性将不会被改变.像这样,动画效果的执行具有先后顺序,称为【动画队列】

4.综合动画
	 $("#panel").css("opacity", "0.5");//设置不透明度
        $("#panel").click(function(){
              $(this).animate({left: "400px", height:"200px" ,opacity: "1"}, 3000)
					 .animate({top: "200px" , width :"200px"}, 3000 )
					 .fadeOut("slow");
        });
	运动代码后,动画效果一步步执行完毕.通过这个例子可以看出,为同一元素应用多重效果时,可以通过链式方法对这些效果进行排队

5.动画回调函数
	若想在最后一步切换元素的css样式,
		不能直接在后面写css('border','5px solid blue')
	这样并不能得到预期效果,预期的效果是在动画的最后一步改变元素的样式,而实际的效果是刚开始执行动画的时候,css()方法就被执行了

	出现这个问题的原因是 css()方法并不会加入到动画队列中,而是立即执行,可以使用回调函数(callback)对非动画方法实现排队.只要把css()方法写在最后一个动画的回调函数里即可
代码如下:
	$("#panel").css("opacity", "0.5");//设置不透明度
       		$("#panel").click(function(){
              		$(this).animate({left: "400px", height:"200px" ,opacity: "1"}, 3000)
			       .animate({top: "200px" , width :"200px"}, 3000 ,function(){
					 $(this).css("border","5px solid blue");
				})


	→☞注意:callback 回调函数适用于jQuery所有的动画效果方法.例如slideDown()方法的回调函数;
		$('#element').slideDown('normal',function(){
			在效果完成后做其他的事情
		})
	这段代码表示id = 'element' 的元素将在0.4秒内(正常速度)向下完全展开,当动画完成后,执行回调函数体内的代码

4.2.6 停止动画和判断是否处于动画状态
	1.停止元素的动画
	需要在某处停止动画,需要用【stop()】方法.stop()方法的语法结构为:
	【stop([clearQuery],[gotoEnd])】参数写true和false,默认false,停止当前当前动画,true是停止全部动画 其实是停止之前的动画,不是之后的,之前没有的从末尾倒着算起
	参数clearQueue 和 gotoEnd都是可选的参数,为Boolean值(true 或 false).clearQueue 代表是否要清空未执行完的动画队列,gotoEnd代表是否直接将正在执行的动画跳转到未状态

	如果直接使用stop(),则会立即停止当前正在进行的动画,如果接下来还有动画等待继续进行,则以当前状态开始接下来的动画.经常会遇到这种情况,在为一个元素绑定hover事件之后,用户把光标移入元素时会触发动画效果,而当这个动画还没结束时,用户就将光标移出这个元素了,那么光标移出的动画效果将会被放进队列之中,等待光标移入的动画结束后再执行.因此如果光标移入移出得过快就会导致动画效果与碧昂表的动作不一致.此时只要在光标的移入,移出动画之前加入stop()方法,就能解决这个问题.stop()方法会结束当前正在进行的动画,并立即执行队列中的下一个动画.,以下代码就可以解决刚才的问题
	$('#panel').hover(function(){
		$(this).stop()
			.animate({height : 150,width : 300},200);
	},function(){
		$(this).stop()
			.animate({height : 22,width : 60},200);
			
	);

	如果遇到组合动画,例如:
	$('#panel').hover(function(){
		$(this).stop()
			.animate({height : 150},200)   //如果在此时触发了光标移出的事件
						       //将执行下面的动画
						       //而非光标移出事件中的动画
			.animate({width : 300},300)
	},function(){
		$(this).stop()
			.animate({height : 22},200)
			.animate({width : 60},300);
			
	});
	此时只用一个不带参数的stop()方法就显得力不从心了.因为stop方法只会停止正在进行的动画,如果动画正执行在第1阶段(改变height的阶段),则触发光标移出时间后,只会停止当前的动画,并继续进行下面的animate({width:300},300)动画,而光标移出事件中的动画要等这个动画结束后才会继续执行,这显然不是预期的结果.这种情况下,stop()方法的第1个参数就发挥作用了,可以把第1个参数(clearQueue)设置为true,此时程序会把当前元素接下来尚未执行完的动画队列都清空.
	$('#panel').hover(function(){
        $(this).stop(true)
            .animate({height : 150},200)   //如果在此时触发了光标移出的事件
                               //将执行下面的动画
                               //而非光标移出事件中的动画
            .animate({width : 300},300)
    },function(){
        $(this).stop(true)
            .animate({height : 22},200)
            .animate({width : 60},300);

    });
	
	用于让第2个参数(gotoEnd)可以用于让正在执行的动画直接到达结束时刻的状态,通常用于后一个动画需要基于前一个动画的未状态的情况,可以通过strp(false,true)这种方法来让当前动画直接到达末状态
	
	当然可以以两者结合起来使用stop(true,true),及停止当前动画并直接到达动画的末尾的末状态
		注意:jQuery只能设置只在执行的动画的最终状态,而没有提供直接到达未执行动画队列最终状态的方法.
	例如:
	$('div content')
		.animate({width : 300},200)
		.animate({width : 150},200)	
		.animate({opacity : 0.2},200)		
	
	无论怎么设置stop()方法,均无法在改变'width'或者'height'时,将此<div>元素的末状态变成300x150,的大小,并且设置透明度为0.2
	【end()】直接结束操作

【jq动画】[jq动画]
	→第一种情况:
	【stop()和stop()】无参数情况,如果光标快速移动,会执行完fn1和回调函数fn2所有动画一次
	【stop(false)和stop(false,true)】
	【stop(false,false)和stop(false,true)】
	【stop(true,true)和stop(false,true)】
	【stop(true)和stop(false,true)】
	如果光标快速移动,会执行完fn1和回调函数fn2所有动画一次

	→第二种情况:
	【stop(true)和stop(false,false)】
	【stop(true,false)和stop(false,true)】
	【stop(true)和stop(false,true)】
	快速移动光标,会执行第一个fn所有动画
	
	→第三种情况:
	【stop(false,true)和stop(true,false)】
	【stop(true,false)和stop(true,false)】
	【stop(false,false)和stop(true,false)】
	若hovar使用回调函数,前一个fun里的stop()false代表回调函数后面的stop(),第二个代表当前动画
			    回调函数里的stoo(),第一个是指之前的动画,后面第二个是指当前动画

	$('#panel').hover(function(){
        	$(this).stop(false,true)//

   	},function(){
        	$(this).stop(true,false)
    	  });
	同等于【stop(true)和stop(true)】 光标快速移动不会改变

	→第四种情况:
	【stop(false)和stop(true,true)】
	【stop(true)和stop(true,true)】
	【stop(true,true)和stop(true,true)】
	【stop(false,true)和stop(true,true)】
	【stop(true,false)和stop(true,true)】
	【stop(false)和stop(false,true)】
	【stop()和stop(true,true)】
	快速移动光标,只会执行第一个fn里的头一个自定义动画,不会执行fn内第二个动画和fn2动画

	→第五种情况:
	【stop(false,false)和stop(false,false)】
	快速移动光标,会执行第一个fn里的第二个开始自定义动画,不会执行fn内第一个动画

	→第六种情况:
	【stop(false)和stop(false)】
	【stop(true)和stop(false)】
	【stop(false)和stop(false)】
	【stop(false)和stop(false,false)】
	【stop(false,false)和stop(false)】
	【stop(false,true)和stop(false)】
	【stop(true,false)和stop(false)】
	【stop(false,false)和stop()】
	【stop(true,true)和stop()】
	【stop(false,true)和stop()】
	【stop(true,false)和stop()】
	【stop(true)和stop()】
	【stop(false)和stop()】
	【stop()和stop(false,false)】
	【stop()和stop(false)】
	【stop(true,true)和stop(false,false)】
	【stop(true,false)和stop(false,false)】
	【stop(false,true)和stop(false,false)】
	快速移动光标,不会执行fn1内第一个动画,其他包括回调函数的fn2的动画也会执行
	
	→第七种情况:
	【stop()和stop(true)】
	【stop(true)和stop(true)】
	【stop(false)和stop(true,false)】
	【stop(false)和stop(true)】
	【stop(true)和stop(true,false)】
	【stop(true,false)和stop(true)】
	【stop(false,true)和stop(true)】
	【stop(false,false)和stop(true)】
	【stop(true,true)和stop(true)】
	快速移动光标,不会执行fn内所有动画,只会执行回调函数的动画


	结论:回调函数的stop()第一个参数是指向当前回调函数内的动画,第二个参数是指向最初执行函数
	     第一个fn内第一个参数是指向回调函数,第二个参数是指向当前动画,如果前面是false,而回调函数是true,那么优先执行回调函数参数,执行完后,将不会执行第一个fn内第二个参数
	回调函数没参数或false,会执行第一个函数的第二个参数
	
	※false指停止之前一次动画,true是停止全部动画,无参数默认是false,停止一次动画
		如果有回调函数,那么优先执行回调函数内的参数
	无法是函数执行还是回调函数,只要有一个有空参数,那么它的优先级最高,都是false,停止一次动画

	根据以上可判断,第二个默认的参数是:
	stop() == stop(false,true)
	没有回调函数之所以会全部实现效果,也是因为默认有第二个参数

2.判断元素是否处于动画状态
	在使用animate()方法的时候,要避免动画积累而导致的动画与用户的行为不一致.当用户快速在某个元素上执行animate(动画时),就会出现动画积累.解决方法是判断元素是否正处于动画状态,如果元素不处于动画状态,采薇元素添加新的动画,否则不添加
	if(!$(ele).is(:animated)){
		如果当前没有没有进行动画,则添加新动画
	}

	 if(!$("#panel").is(":animated")){
        	 $("#panel").click(function(){
                  	$(this).animate({left: "500px",height:300}, 3000);
        	})
    	}

	→※注意:if判断写在事件内外都没影响
	这个判断方法在annimate()动画中经常被用到,需要特别注意

3.延迟动画
	在动画执行的过程中,如果想对动画进行延迟操作,那么可以使用delay()方法,使用方式如下
	【delay()】延迟 
	$(this).animate({left:"400px",height:"200px",opacity:1},3000)
	.dealy(1000)
	.animate({top:"200px",width:"200px"},3000)
	.dealy(2000)
	.fadeIn('slow');
	delay()方法允许我们将队列中的函数延迟时执行.它既可以推迟动画队列中函数的执行,也可以用于自定义队列


4.2.7	其他动画方法

	除了上面提到的动画方法,jQuery还有四个用于交互的方法
	
	1.【toggle(speed,[callback])方法】
		可以切换元素的可见状态,如果元素是可见的,则切换为隐藏的;否则则切换可见
		$().click(function(){
			$(this).next.toogle();
		})
	相当于
		$().toggle(function(){
			$(this).next.hide();
		},function(){
			$(this).next.slow();
		})
	2.【slideToggle(speed,[easing].[callback])方法】
		通过高度变化来切换匹配元素的可见性,这个动画效果只调整元素的高度.
		$().click(function(){
			$(this).next.slideToogle();
		})
		当点击后,指定元素会在可见和隐藏两种状态切换,不过是改变元素高度来实现的
	相当于
		$().toggle(function(){
			$(this).next.slideUp();
		},function(){
			$(this).next.slideDown();
		})
	3.【fadeTo(speed,opacity.[callback]方法)】
		可以把元素的不透明度以渐变方式调整到指定的值.这个动画只调整元素的不透明度,即匹配的元素的高度和宽不会发生变化
		$().click(function(){
			$(this).next().fadeTo(600,0.2)
		})
		当点击后,内容会渐渐调整到指定的不透明度20%
	4.【fadeToggle(speed,[easing],[callback])方法】
		通过不透明度变化来切换匹配元素的可见性.这个动画效果只调整元素的不透明度
		$().click(function(){
			$(this).next.fadeToggle();
		})
	相当于
		$().toggle(function(){
			$(this).next.fadeOut();
		},function(){
			$(this).next.fadeIn();
		})


4.2.8	动画方法概况
	从基本动画方法hiden()到show()到fadeIn和fadeOut(),然后到slideUp()和slideDown(),再到自定义动画方法animate(),最后到交互动画方法toggle(),slideToggle(),fadeTo()和fadeToggle().

	1.改变样式属性
	
	【hiden()和show()】	同时修改多个样式属性即高度,宽度和不透明度
	【fadeIn()和fadeOut()】	只改变不透明度
	【slideUp()和slideDown()】	只改变高度
	【fadeTo()】	只改变不透明度
	【toggle()】	用来替代hide()方法和show()方法,所以会同时修改多个样式属性即高度,宽度和不透明度
	【slideToggle()】	用来代替slideUp方法和show()方法,所以会同时修改样式属性即高度,宽度和不透明度
	【fadeToggle()】用来替代slideIn()方法和fadeOut()方法,所以只能改变透明度
	【animate()】属于自定义动画的方法,以上各种动画方法实质内部都调用了animate()方法,此外,直接使用animate()方法还能自定义其他的样式属性,例如"left","marginLeft",'sorollTop'等

	需要特别注意animate()方法,可以使用它来替代其他所有的动画方法
	
	用animate()方法代替show()方法,毫秒必须填写0,否则会有动画效果
	$(this).animate({width: "show",height:'show',opacity : 'show'},0);
	用animate()方法代替hide()方法,毫秒必须填写0,否则会有动画效果
	$(this).animate({width: "hide",height:'hide',opacity : 'hide'},0);

	
	用animate()方法代替fadeIn()方法
	$(this).animate({opacity : 'show'},400);
	用animate()方法代替fadeOut()方法
	$(this).animate({opacity : 'hide'},400);

	用animate()方法代替slideDown()方法
	$(this).animate({height : 'show'},400);
	用animate()方法代替slideUp()方法
	$(this).animate({height : 'hide'},400);

	用animate()方法代替fadeTo()方法
	$(this).animate({opacity : '0.6'},400);
	等价于$(this).fadeTo(400,0.6);

	事实上,这些动画就是animate()方法的一种内置了特定样式的简写形式.在animate()方法中,这些特定样式的属性值可以为'show','hide','和toggle',也可以是自定义数字(值).

2.动画队列
	(1)一组元素上的动画效果
		当在一个animate()方法中应用多个属性时,动画是同时发生的.
		当以链式的写法应用动画方法时,动画是按照顺序发生的.
	(2)多组元素上的动画效果
		默认情况下,动画都是同时发生的
		当以回调的形式应用动画方式时,动画是按照回调顺序发生的.
	另外,在动画方法中,要注意其他非动画方法会插队,例如CSS()方法要使非动画方法也按照顺序执行,需要把这些方法写在动画方法的回调函数中.

	IE6并不支持超链接之外的:hover伪类选择符,此时可以用jQuery来弥补IE6对CSS支持的不足

	【jq设置全选】
	$('input:checkbox').attr('checked', true);
	第二种
		 $('input:checkbox').attr('checked',checked=!this);

	【jq设置全不选】
	$('[type=checkbox]:checkbox').attr('checked', false);
	第二种:
		 $('input:checkbox').attr('checked',checked=!this);
	【jq设置反选】
	$().click(function(){
		$('[name=items]:checkbox').each(function(){
			$(this).attr('checked',!$(this).attr('checked'));
		})
	})
	此处用jQuery的attr()方法来设置属性checked的有些复杂,如果改用javascript原生DOM方法,将比创建jQuery对象更有效,简洁.

	$().click(function(){
		$('[name=items]:checkbox').each(function(){
			this.checked = !this.checked;
	})
	})

	→注:jq使用each或map循环,里面可以直接用js,this来替代$(this)使用
		所以可以直接使用原生js来简化代码
	变成$对象的话使用事件
	$(this).click(function(){代码块})
	还可以直接使用DOM事件
	this.onclick = function(){代码块}

	→用复选框全选/全不选
	$('#checkdAll').click(function(){
		if(this.checked){
			$('[name=items]:checkbox').attr('checked',true);
		} else{
			$('[name=items]:checkbox').attr('checked',false);
		}
	})
	进一步观察思考后发现,所有复选框的checked属性的值和控制全选的复选框的checked属性的值是相同的,因此可以省略if判断,直接赋值.
	$('#checkAll').click(function(){
		$('[name=items]:checkbox').attr('checked',this.checked);
	})
	当点击id为'CheckedAll'的复选框后,复选框组将被选中.当在复选框组里取消某一个选项的选中状态时,id为'CheckedAll'的复选框并没有被取消选中状态,而此时需要它和复选框组能够联系起来,及复选框组里如果有一个或则更多没选中时,则取消id为'CheckdAll'的复选框的选中状态;如果复选框组都被选中时,则id为'Ch选框也自动被选中.
	因此需要对复选框组进行操作,已通过它们来控制id为'checkedAll'的复选框.具体实现思路如下
	(1)对复选框组绑定单击事件.
	(2)定义一个flag变量,默认为true
	(3)循环复选框组,当有没被选中的项时,则把变量falg的值设置为false
	(4)根据变量falg的值来设置id为'CheckedAll'的复选框是否选中.
		1.如果falgweitrue,说明复选框组都被选中.
		2.如果falg为false,说明复选框组至少有一个未被选中.	
	
		var flag = true;
			$('[name=items]:checkbox').each(function(){
				if(!this.checked){
					flag = false;
				}
		});

			if(flag){
				$('#CheckedAll').attr('checked',true);
			} else{
				$('#CheckedAll').attr('checked',false);
			}

	
实现点击多个按钮,全部选中时【全选】复选框选中
	(1) 对复选框组绑定单击事件.
	(2) 判断复选框的总数是否与选中的复选框数量相等
	(3) 如果相等,则说明全选中了,id为'CheckedAll'的复选框应当处于选中状态,否则不选中

	↓推荐用以下写法,用变量来保存
	var $temp = $('[name=items]:checkbox');
			$('#CheckedAll').attr('checked',!$temp.filter(':not(:checked)').length);

	
	简单说就是获取全部符合条件元素,用filter获取不是not没有选中的:checkbox,在前面加!就是选中搜索到的元素,再后面添加.length,符合所有选中的才会选中【全选】复选框
	一行做过多的事情需要写更多注释。复杂选择器还可能影响效率。因此不推荐如下写法。
	$('[name=selected]').attr('checked',!$('[name=items]:checkbox').filter(':not(:checked)').length);

	※注意:在之前的jQuery版本中,都是使用attr()来访问对象的属性,比如取一个图片的alt属性,就可以这样做$('#img').attr('alt'),但是在某些时候,比如访问input的disabled属性的时候,会有些问题.在有些浏览器里,只要写了disabled属性就可以,有些则要写:disabled属性的时候会有些问题,在有些浏览器里,只要写了disabled属性就可以,有些则要写:disable="disabled"或者"",只会返回true/false.当然赋值的时候也是如此.这样,便统一了所有的操作,无论是从语法上还是语义上.
那么,那些属性应该用attr()访问,哪些应该用prop()访问呢?
第一个原则:只添加属性名称该属性就会生效应该使用prop();
第二个原则:只存在true/false的属性应该使用prop().
按照官方说明,如果是设置disabled和checked这些属性,应使用prop()方法,而不是使用attr()方法,所以,在上例中,建议把所有attr()改成prop();
	→1.6以下不生效

5.1.4	下拉框应用
	
	需要实现的功能如下
	(1) 将选中的选项添加给对方
	(2) 将全部选项添加给对方
	(3) 双击某个选项将其添加给对方
	首先要获取下拉列表中被选中的选项,然后将当前下拉列表中选中的选项删除,最后将删除的选项添加给对方.
	$(#add).click(function(){
		var $opt = $('#select1 option:selected'),
		    $remove = $obj.remove();
		    $remove.appendTo('#select2');
	})

	
在上面提取过,删除和追加这两个步骤可以用appendTo()方法直接完成,因此可以将上面代码简化:
	设置移动到右侧:
	$('#add').click(function(){
			$('#select1 :selected').appendTo('#select2');
	})
	设置全部移动右面
	$('#add_all').click(function(){
		// $('#select1 option').appendTo($('#select2'));
		$('#select1 option').appendTo('#select2');
	})
	设置双击移动右面
	$('#select1').dblclick(function(){
		$('option:selected',this).appendTo('#select2');
	})


	→※:$('tr:odd')和$('tr:even')选择器中索引是从0开始的	

点击表格所在行高亮并且radio单选框选中
	$('tbody tr').bind('click',function(){
				$(this).addClass("selected")
				.siblings().removeClass('selected')
				.end()
				.find(':radio').attr('checked',true);
	})

	上面代码中使用了end()方法,当前对象是$(this),当进行addClass('selected')操作时,对象并未发生变化,当执行了siblings().removeClass('selected')操作时,对象已经变为$(this).siblings(),因此后面的操作都是针对这个对象的,如果需要重新返回到$(this)对象,就可以使用end()方法,这样后面的
	.find(':radio').attr('checked',true);
	操作就是:
	$(this).find('radio').attr('checked',true);
	而不是:
	$(this).siblings().find(':radio').attr('checked',true);

	另外,初始化表格的时候,如果默认已经有单选框被选中,那么也需要处理
		如果单选框默认情况下是选择的，则高色.
第一种方法:
	通过parent()方法逐步向父节点获取相应的元素的
		$('table :radio:checked').parent().parent().addClass('selected';)
第二种方法:使用parents()方法直接获取;
	简化一:
		$('table :radio:checked').parent().parent().addClass('selected');
第三种方法:如果通过has选择器也可以进一步简化,表示含有选中的单选框的<tr>行将被高亮显示;
	最终简化:
		→推荐,代码少 $('tbody>tr:has(:checked)').addClass('selected');
	

3.复选框控制表格行高亮:
	$('tbody tr').bind('click',function(){
			if($(this).hasClass('selected')){
				$(this)
					.removeClass('selected')
					.find(':select').attr('checked',false);
			} else{
					$(this)
					.addClass('selected')
					.find(':select').attr('checked',true);
			}
	})

	// 如果复选框默认情况下是选择的，则高色.
	// $('table :checkbox:checked').parent().parent().addClass('selected');
	//简化:
	$('table :checkbox:checked').parents("tr").addClass('selected');
	//$('tbody>tr:has(:checked)').addClass('selected');


	【最重要,一定要记住:find()是查找this之内的所有元素,包括:select,has()也可以获取属性,select】
	此外,在不改变设计思路的前提下,上面的代码还可以在简化如下代码:
	简化
	$('tbody>tr').click(function() {
			//判断当前是否选中
			var hasSelected=$(this).hasClass('selected');
			//如果选中，则移出selected类，否则就加上selected类
			$(this)[hasSelected?"removeClass":"addClass"]('selected')
				//查找内部的checkbox,设置对应的属性。
				.find(':checkbox').attr('checked',!hasSelected);
		});
		// 如果复选框默认情况下是选择的，则高色.
		$('tbody>tr:has(:checked)').addClass('selected');
	注意:在$(this)[hasSelected?"removeClass":"addClass"]('selected')中:
	[hasSelected?"removeClass":"addClass"]这是一个三元运算,结果为:"removeClass"或者'addClass',因此$(this)[hasSelected?"removeClass":"addClass"]('selected')
		其实代表这2种情况:
	$(this)['removeClass']('selected');
	或则$(this)['assClass']('selected');
	它们等价于:
	$(this).removeClass('selected')
	或者$(this).addClass('selected');

	当用户刚入页面时,也要处理已经被选中的表格行.
	$('tbody>tr:has(:checked)').addClass('selected');	

	【还有重要一点,jQuery不但可以$(this).addClass('selected')这一种方法,还可以使用$(this)['addClass']('selected')这第二种方法,当后面添加或移除相同名称class,可使用三目来判断】


5.2.2 表格展开关闭
	如果当用户刚进入页面时,默认需要收缩起来,也是很简单的.只要触发click()事件即可.

	$('tr.parent').click(function(){   // 获取所谓的父行
			$(this)
				.toggleClass("selected")   // 添加/删除高亮
				.siblings('.child_'+this.id).toggle();  // 隐藏/显示所谓的子行
	}).click(); ←


	※:这里最后使用1次.click()是默认先将$('tr.parent')所有的先执行一遍

5.2.3 表格内容筛选
	如果要高亮'王五'那一行,可以使用contains选择器来完成,代码如下
	$('tr:contains('王五')').addClass('selected');
		//选择器contains,能匹配包含指定文本的元素
	利用该选择器再集合jQuery的finter筛选方法,可以实现表格内容的过滤.
	例如使用下面的jQuery代码就可以筛选出含有文本'李'的表格行
	$('table tbody tr').hide()
			.filter('contains("李")').show();

使用input文本框,根据文本框内容,筛选表格行
	 $("#filterName").keyup(function(){
	      $("table tbody tr")
					.hide()
					.filter(":contains('"+( $(this).val() )+"')")
					.show();
	   }).keyup(); //DOM加载完毕时,绑定事件完成之后立即触发
	表单元素有个特点,就是刷新网页后,其值会保持不变.例如在刚才筛选操作后,刷新网页,则会出现表单元素的值还存在

	※注:要解决这个问题,只需要在DOM刚加载完时,为表单元素绑定事件并且立即触发该事件即可.
	※:在字符串拼接变量或元素值情况下,需要用到引号嵌套等情况下,使用()来把内部引号包起来,这样可以提高代码的统一,简明易了

	
5.3.1	网页字体大小
	在某些网站经常有"放大"和"缩写"字号的控制按钮,通过单击它们,可以使网页的文字呈现不同的大小.
	当文档加载完毕后,为所有的<span>元素绑定单击事件
	$("span").click(function(){
		var thisEle = $("#para").css("font-size"); 
		var textFontSize = parseFloat(thisEle , 10); //parseInt(thisEle)这里可以直接使用paseInt
		获取id为'para'的元素的字体大小.获取的值是将返回的数字和单位.即16px.然后使用parseInt
		var unit = thisEle.slice(-2); //获取单位
		var cName = $(this).attr("class");
		if(cName == "bigger"){
				textFontSize += 2;
		}else if(cName == "smaller"){
				textFontSize -= 2;
		}
		$("#para").css("font-size",  textFontSize + unit ); //这里unit也可以不用定义,直接写px
	});


	【slice(value)】正数是从左往右截取,负数是从右往左截取字串

	→进一步加判断,可限制max,min大小字体
		if(cName == "bigger"){
		   if( textFontSize <= 22 ){
				textFontSize += 2;
			}
		}else if(cName == "smaller"){
		   if( textFontSize >= 12  ){
				textFontSize -= 2;
			}
		}

5.3.2	网页选项卡[jq选项卡]
	制作选项卡的原理比较简单,通过隐藏和显示来切换不同的内容
	var $div_li =$("div.tab_menu ul li");
	    $div_li.click(function(){
			$(this).addClass("selected")            //当前<li>元素高亮
				   .siblings().removeClass("selected");  //去掉其它同辈<li>元素的高亮
            var index =  $div_li.index(this);  // 获取当前点击的<li>元素 在 全部li元素中的索引。
			$("div.tab_box > div")   	//选取子节点。不选取子节点的话，会引起错误。如果里面还有div 
					.eq(index).show()   //显示 <li>元素对应的<div>元素
					.siblings().hide(); //隐藏其它几个同辈的<div>元素
	})
	在上面的代码中,要注意$('div.tab_box > div')这个子选择器,如果用$('div.tab_box div')选择器,当子节点里再包含<div>元素的时候,就会引起程序错乱,因此获取当前选项卡下的子节点,才是这个例子所需要的.

	比如:
	<div class="tab_box"> 
		<div>时事</div>
		 	<div class="hide">体育
				<div>这是测试</div>
		 	</div>
		<div class="hide">娱乐</div>
	</div>

	这里如果div包括子div,那么再包含子div的标签就会停止切换,点击之后的选项卡都会默认切换到第二个div,因为后代选择器,直接就选择了第二个div下的子div,因为选择的是第二个div下的div,所以无法掉转到它的父级的同邻div.

	推荐使用链式编程直接一句解决
	$('.tab_box > div').eq(index).show().siblings().hide();


2.3.3	网页换肤

	自从Web2.0开始流行后,很多网站更加注重用户自定义,例如在网页上用户可以自定义新闻内容,可以任意拖动网页内容,也可以给网页选择一套自己喜欢的颜色

	网页换肤的原理就是通过调用不同的样式表文件来实现不同皮肤的切换,并且需要将换好的皮肤记入Cookie中,这样用户下次访问时,就可以显示用户自定义的皮肤了
	DOM结构:
	<ul id="skin">
		<li id="skin_0" title="灰色" class="selected">灰色</li>
		<li id="skin_1" title="紫色">紫色</li>
		<li id="skin_2" title="红色">红色</li>
		<li id="skin_3" title="天蓝色">天蓝色</li>
		<li id="skin_4" title="橙色">橙色</li>
		<li id="skin_5" title="淡绿色">淡绿色</li>
	</ul>

    <div id="div_side_0">
		<div id="news">
		    <h1 class="title">时事新闻</h1>
		</div>
    </div>

    <div id="div_side_1">
		<div id="game">
			<h1 class="title">娱乐新闻</h1>
		</div>
    </div>
	然后根据HTML代码预定义几套换服用的样式,分别有灰色,紫色,红色等6套.默认是灰色

	※→注意:在设计HTML代码时,用了一些小技巧,就是将皮肤选择按钮<li>元素的id与网页皮肤的样式文件名称设置的相同.这样就可以使完成换肤操作简化很多.

	然后为HTML代码添加样式,注意HTML结构要有一个带id的样式表链接,通过操作该链接的href属性的值,从而实现换肤,代码如下
	 <link href="css/skin_0.css" rel="stylesheet" type="text/css" id="cssfile" />
	
最后为皮肤选择按钮添加单击事件
	(1)当皮肤选择按钮被点击后,当前皮肤就被勾选
	(2)将网页内容换肤

	完成后,当点击皮肤选择按钮时,就可以切换网页皮肤了,但是当用户刷新网页或者关闭浏览器后,皮肤又会被初始化,因此需要将当前选择的皮肤进行保存.
	在jQuery中有一款Cookie插件,它能简化Cookie的操作,此处就将其引入.

<!--   引入jQuery的cookie插件 -->
	<script src="js/jquery.cookie.js" type="text/javascript"></script>
将当前皮肤保存进Cookie,代码如下
	$.cookie( "自定义名称" ,  skinName , { path: '/', expires: 10 });
	保存后,就可以通过Cookie来获取当前的皮肤了.如果Cookie确实存在,则将当前皮肤设置为Cookie记录的值
	//省略代码
	var cookie_skin = $_cookie('自定义名称')
		if(cookie_skin == true){}else{}

	→js代码
	var $li =$("#skin li");
	$li.click(function(){
		$("#"+this.id).addClass("selected")                //当前<li>元素选中
					.siblings().removeClass("selected");  //去掉其它同辈<li>元素的选中
		$("#cssfile").attr("href","css/"+ (this.id) +".css"); //设置不同皮肤
		$.cookie( "MyCssSkin" ,  this.id , { path: '/', expires: 10 });
	});
	var cookie_skin = $.cookie( "MyCssSkin");
	if (cookie_skin) {
			$("#"+cookie_skin).addClass("selected")                //当前<li>元素选中
					          .siblings().removeClass("selected");  //去掉其它同辈<li>元素的选中
			$("#cssfile").attr("href","css/"+ cookie_skin +".css"); //设置不同皮肤
			$.cookie( "MyCssSkin" ,  cookie_skin  , { path: '/', expires: 10 });
	}

	此时,网页换肤功能不仅能正常切换,而且也能保存到Cookie中,当用户刷新网页时,仍然是都当前选择的皮肤

	如果click事件中的函数内容与if(cookie_skin){}内的判断内容类似,知识有一个变量不同,因此可以通过给函数传递不同的参数,这样就可以多次调用(抽象化)
	→※注:jquery.color插件不支持Chrome浏览器,firefix火狐支持



[jqajax][jq ajax]
第6章 jQuery与Ajax的应用
	Ajax全称为'Asynchronous JavaScript and XML'(异步javascript和XML),它并不是指一种单一的技术,而是有机的利用了一系列交互式网页应用相关的技术所形成的的集合体.它的出现,揭开了无刷新更新页面的新时代,并有代替传统的Web方式和通过隐藏的框架来进行异步提交的趋势,是Web开发应用的一个里程碑

6.1 Ajax的优势和不足
	1.不需要插件支持
		Ajax不需要任何浏览器插件,就可以被大多数主流浏览器所支持,用户只需要允许JavaScript在浏览器上执行即可
	2.优秀的用户体验
		这是Ajax技术的最大优点,能在不刷新整个页面的前提下更新数据,这使得Web应用程序能更为迅速地回应用户的操作.
	3.提高Web程序的性能
		与传统模式相比,Ajax模式在性能上的最大区别就在于传输的方式,在传统模式中,数据提交是通过表单(Form)来实现的,而数据获取时靠全页面刷新来重新获取整页的内容.Ahax模式只是通过XMLHttpRquest对象向服务器提交希望提交的数据,即按需发送.	
	4.减轻服务器和
带宽的负担
		Ajax的工作原理相当于在用户和服务器之间加入一个中间层,使用户操作与服务器响应异步化,它在客户端创建Ajax引擎,把传统方式下的一些服务器负担的工作转移到客户端,便于客户端资源来处理,减轻服务器和带宽的负担


6.1.2	Ajax的不足
	
世界上并没有完美的事物,同时Ajax也并不是一项非常完美的技术.Ajax主要有以下几点不足之处.
	1.浏览器对XMLHttpRequest对象的支持度不足
	Ajax的不足之一首先来自于浏览器.Internet Explorer 在5.0及之后的版本才支持XMLHttpRequest对象(现阶段大部分客户端上的IE浏览器是IE6及以上),Mozilla,Netscape等浏览器支持XMLHttpRequest则更在其后.为了使得Ajax能在各个浏览器中正常运行,程序员必须花费大量的精力编码以兼顾各个浏览器之间的差别,来让Ajax应用能够很好地兼容个各个浏览器.这使得Ajax开发的难度比普通的Web开发高出很多,许多程序员因此对Ajax望而生畏

	2.破坏浏览器前进,后退按钮的正常功能
	在传统的网页中,用户经常会习惯性的使用浏览器自带的前进和后退按钮,然后Ajax改变了此Web浏览习惯.在Ajax中'前进'和'后退'按钮,但相对于传统的方式却麻烦了很多,对于用户来说,他们经常会碰到这种情况,当点击一一个按钮触发一个Ajax交互后又觉得不想这样做,接着就去习惯性地单击'后退'按钮,结果发生了最不愿意看到的结果,浏览器后退到了先前的一个页面,通过Ajax交互得到的内容完全消失了.
	3.对搜索引擎的支持的不足
	对于搜索引擎的支持也是Ajax的一项缺憾.通常搜索引擎都是通过爬虫程序来对互联网上的数以亿计的海量数据来进行搜索整理的,然而爬虫程序现在还不能理解那些奇怪JavaScript代码和因此引起的页面内容的变化,这使得应用Ajax的站点在网站推广上相对于传统站点明显处于劣势.
	4.开发和调试工具和缺乏
	JavaScript是Ajax的重要组成部分,在目前,由于缺少很多的JavaScript开发和调试工具,使很多Web开发者对JavaScript望而生畏,这对于编写Ajax代码就更加困难了,同时.目前许多Web开发者已经习惯使用可视化的工具,对亲自动手编写代码有畏惧感,这也在一定程序上影响可大家对Ajax的应用


	
6.2 Ajax的核心是XMLHttpRequest对象,它是Ajax实现的关键---发送异步请求接收响应及回调都是通过它来完成的.XMLHttpRequest对象最早是在Microsoft Internet Explorer 5.0 ActiveX 组件中被引入的,之后各大浏览器厂商都以JavaScript内置对象的方式来实现XMLHttpRequest对象.虽然大家对它的实现方式有所区别,但是绝大多数浏览器都提供了类似的属性和方法,而且在实际脚本编写方法上的区别也不大,实现得到的效果也基本相同.目前W3C组织正致力于制定一个各浏览器厂商可以统一遵照执行的XMLHttpRequest对象标准,用来推进Ajax技术的推广与发展.
	示范一:
	function Ajax(){ 
	var xmlHttpReq = null;	//声明一个空对象用来装入XMLHttpRequest
	if (window.ActiveXObject){//IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的
		xmlHttpReq = new ActiveXObject("Microsoft.XMLHTTP");
	} 
	else if (window.XMLHttpRequest){//除IE5 IE6 以外的浏览器XMLHttpRequest是window的子对象
		xmlHttpReq = new XMLHttpRequest();//实例化一个XMLHttpRequest
	}
	if(xmlHttpReq != null){	//如果对象实例化成功 
		xmlHttpReq.open("GET","test.php",true);	//调用open()方法并采用异步方式
		xmlHttpReq.onreadystatechange=RequestCallBack; //设置回调函数
		xmlHttpReq.send(null);	//因为使用get方式提交，所以可以使用null参调用
	}
	function RequestCallBack(){//一旦readyState值改变，将会调用这个函数
		if(xmlHttpReq.readyState == 4){
				if(xmlHttpReq.status == 200){
					//将xmlHttpReq.responseText的值赋给ID为 resText 的元素
					document.getElementById("resText").innerHTML = xmlHttpReq.responseText;
				}
		}
	}
}

	IE5,IE6是从ActiveXObject的方式引入XMLHttpRequest对象的,而其他浏览器的XMLHttpRequest对象是Window的子对象

	以上就是实现XMLHttpRequest对象使用的所有细节,它不必将Web页面的所有内容都发送到服务器,而是按需发送.使用JavaScript启动一个请求并处理相应的返回值,然后使用浏览器的DOM方法更新页面中的数据.显然,这种无刷新的模式能给网站带来更好的用户体验.但是XMLHttpRequest对象的很多属性和方法,对于想快速入门Ajax的人来说,似乎并不是个容易的过程.

	幸运的是,jQuery提供了一些日常开发中需要的快捷操作,例如load,ajax,get和post等,使用jQuery开发Ajax将变得极其简单.这样开发人员就可以将程序开发集中在业务和用户体验上,而不需要理会那些繁琐的XMLHttpRquest对象


6.5 jQuery中的Ajax
	jQuery对Ajax操作进行了封装,在jQuery$.ajax()属于最底层的方法,第2层是load(),$get和$.post()方法,第3层是$.getScript和$.getJSON()方法.首先介绍第2层的方法,因为其使用频率很高.


6.5.1	【load()】方法
	1.载入HTML文档
	load()方法是jQuery中最为简单和常用的Ajax方法,能载入远程HTML代码并插入DOM中.他的结构为
	load(url[,data][.callback]);
	load()方法参数解释如表6-1所示
==========================================================================================
参数名称	类型		说明
url		String		请求HTML页面的URL地址
data(可选)	Object		发送至服务器的key/value数据
callback(可选)	Function	请求完成时的回调函数,无论请求成功或失败
==========================================================================================
等DOM元素加载完毕后,通过单击id为"send"的按钮来调用liad()方法,然后将text.html的内容加载到id为"rasText"的元素里.
	  $("#send").click(function(){
			  $("#resText").load("test.html");
	  })
显然,load()方法完成了加载的文件的URL作为参数传递给load方法即可,当点击按钮后test.html页面的HTML内容就会被加载并插入主页面<div id="resText"></div>的元素中

注意:test.html页面里并没有添加样式,但现在加载的内容有样式了.这些样式是在主页面中添加的,即主页面相应的样式会立即应用到新加载的内容上.

	2.筛选载入的HTML文档
		上个例子是将test.html页面中的内容都加载到id为"resText"的元素里.如果只需要加载test.html页面内的某些元素,那么可以使用load()方法的URL参数来达到母的.通过为URL参数执行选择符,就可以很方便地从加载过来的HTML文档里筛选出所需要的内容.

	load()方法的URL参数语法结构为:"url selector".注意,URL和选择器直接有一个空格
	例如只需要加载test.html页面中class为"para"的内容,可以使用如下代码来完成;
	$('#resText').load('test.html .para');
	
无参数传递则是GET方式
	$('#resText').load('test.php',function(){})
有参数传递,则是POST方式
	$('#resText').load('test.php',{name:"rain",age:"22"},function(){})


4.回调参数
	对于必须在加载完成后才能继续的操作,load()方法提供了回调函数(cakkback),该函数有3个参数,分别代表请求返回的内容,请求状态和XMLHttpRequest对象

	$('#resText').load('test.html',function(responseText,testStatus,XMLHttpRequest){
		//responseText :请求返回的内容
		//textStatus : 请求状态success,error,notmodified,timeout 4种
		//XMLHttpRequest : XMLHttpRequest对象
	})
	【success】成功
	【error】失败
	【notmodified】没修改
	【timeout】超时
	
	→※注意:在load()方法中,无论Ajax请求是否成功,只要当请求完成(complete)后,回调函数(callback)就被触发,对于下面将介绍的$.ajax中的complete回调函数
	complete完成

6.5.2	$.get()方法通常用来从Web服务器上获取静态的数据文件,然后这并不能体现Ajax的全部价值. 在项目中,如果需要传递一些参数给服务器中的页面,那么可以使用$.get()或者$.pos()方法(或者是后面要讲解的$.ajax()方法)

	→※:注意:$.get()和$.post()方法是jQuery中的全局函数,而在此之前讲的jQuery方法都是对jQuery对象进行操作的.



1. 【$.get()】方法使用GET方式来进行异步请求.
   它的结构为:
   $.get(url[,data] [,callback] [,type])
	$.get()方法参数解释
	
参数名称	类型	说明
url		String	请求的HTML页的URL地址
data(可选)	Object	发送至服务器的key/value数据会作为QueryString附加到请求URL中
callback(可选)	Function	载入成功时回调函数(只有当Response的返回状态是succes才调用该方法) 自动将请求结果和状态传递给给方法
type(可选)	String	服务器端返回内容的格式,包括xml,html,script,json,text和_default


	(1)使用参数
	首先,需要确定请求页面的URL地址.
	$('#send').click(function(){
		$.get('get1.php',data参数,回调函数);
	})
	然后,在提交之前,需要获取'姓名'和'内容'的值作为data参数传递给后台
	$('#send').click(function(){
		$.get('get1.php',{
			uesename : $('#username'),
			content : $('#content').val()
	},回调函数);
	})

	如果服务器端接收到传递的data数据并成功返回,那么就可以通过回调函数将返回的数据显示在页面上.
	$.get()方法的回调函数只有两个参数
	function(data,textStatus){
		//data : 返回的内容,可以是XML文档,JSON文件,HTML片段等等
		//textStatus : 请求状态: success,error,notmodified,timeout 4种
	}
	
	data参数代表请求返回的内容,textStatus参数代表请求状态,而且回调函数只有当数据成功返回(success)后才能调用,这点与load()不一样.
	(2) 数据格式
	服务器返回的数据格式可以有多种,它们都可以完成同样的任务.以下是几种返回格式的对比
	
	→【HTML片段】
	由于服务器端返回的数据格式是HTML片段,因此并不需要经过处理就可以将新的HTML数据插入到主页面中.

	DOM结构:
	<form id="form1" action="#">
		<p>评论:</p>
	 	<p>姓名: <input type="text" name="username" id="username" /></p>
		 <p>内容: <textarea name="content" id="content"  rows="2" cols="20"></textarea></p>
	 	<p><input type="button" id="send" value="提交"/></p>
	</form>
	<div  class='comment'>已有评论：</div>
	<div id="resText" >
	</div>

	jQuey代码:
	   $("#send").click(function(){
		$.get("get1.php", { 
			username :  $("#username").val() , 
			content :  $("#content").val()  
		      }, function (data, textStatus){
                        	$("#resText").html(data); // 把返回的数据添加到页面上
			 }
		      );
	   })	

	PHP后台代码:
        <?php
            header("Content-Type:text/html; charset=utf-8");
            echo "<div class='comment'>".
                    "<h6>{$_REQUEST['username']}:</h6>".
                    "<p class='pare'>{$_REQUEST['content']}</p>".
                  "</div>";
        ?>

	※注:php中代码引号必须是【外双内单】,否则,不支持写报错.
	echo相当于与js中的function的回调函数,可以添加html标签,在要获取元素value值时,使用【{}】大括号包裹,因为ajax获取数据时就是使用{}对象来的,为了呼应获取数据,然后在里面添加【$_REQUEST】request请求必须大写才能,否则不生效
	
	HTML片段实现起来只需要很少的工作量,但这种固定到数据结构并不一定能够在其他的Web应用程序中得到重用.

	→【XML文档】
		由于服务器端返回的数据格式是XML文档,因此需要对返回的数据进行处理,前面的章节已经介绍过jQuey强大的DOM处理能力,处理XML文档与处理HTML文档一样,也可以使用常规的attr(),find(),filter()以及其他方法:


	jQuery代码:
	$("#send").click(function(){
		$.get("get2.php", { 
			username :  $("#username").val() , 
			content :  $("#content").val()  
		}, function (data, textStatus){
		    var username = $(data).find("comment").attr("username"),
				content = $(data).find("comment content").text(),
		  		txtHtml = "<div class='comment'><h6>" + username + ":</h6><p class='para'>" + content + "</p></div>";
		    $("#resText").html(txtHtml); // 把返回的数据添加到页面上
		});
	})


	PHP代码:
        <?php
            header("Content-Type=text/xml; charset=UTF-8");
            echo "<?xml version='1.0' encoding='UTF-8'?>".
                 "<comments>".
                    "<comment username='{$_REQUEST['username']}'>".
                    "<content>{$_REQUEST['content']}</content>".
                    "</comment>".
                 "</comments>";
        ?>

	version版本
	encoding编码
	※注:php里的都是自定义标签,不是固定格式,可以根据自己需求来定义
		如果想自定义PHP里代码格式,使用【"."】把想要换行整理格式的代码分割开就好
		添加属性名时在【'{}'】大括号添加单引号,如果是内容就不用添加'单引号
	
	返回数据格式为XML文档的过程实现起来比HTML片段要稍微复杂些,但XML文档的可移植性是其他数据格式无法比拟的,因此以这种格式提供的数据的重用性将极大提高.例如del.icio.us(htttp://del.icio.us),Flickr(htttp://flickr.com)和某些开放平台都是以XML格式输出数据,读者可以利用它们提供的API,将获得得内容整合到自己的网站中(Mashup应用).不过,XML文档体积相对较大,与其他文件格式相比,解析和操作它们的速度要慢一些.

	※注:由于期待服务器返回的数据格式是XML文档,因此需要在服务端设置Content-Type类型,
		header("Content-Type=text/xml; charset=UTF-8");


	→【JSON文件】
	之所以会出现这种格式的文件,很大程度上是因为XML文档体积大和难以解析.JSON文件和XML文档一样,也可以方便的被重用.而且JSON文件非常简洁,也容易阅读.想了解更多的JSON文档知识,也可以访问http://json.org网址
	
	由于服务器端返回的数据格式是JSON文件,因此需要对返回的数据进行处理之后,才可以将新的HTML数据添加到主页面中
	jQuery代码:
	$("#send").click(function(){
		$.get("get3.php", { 
				username :  $("#username").val() , 
				content :  $("#content").val()  
			}, function (data, textStatus){
			    var username = data.username;
				var content = data.content;
			    var txtHtml = "<div class='comment'><h6>" + username + ":</h6><p class='para'>"+content+"</p></div>";
		        $("#resText").html(txtHtml); // 把返回的数据添加到页面上
		},"json");
	})
	
	在上面的代码中,将$.get()方法的第4个参数(type)设置为"json"来代表期待服务器端返回的数据格式.
	
	※注:(1)在不远的将来,新版的JavaScript中XML将会和JSON一样容易解析,相信到时候通用且容易解析的XML将会成为主流的数据交换格式.不过在它到来之前,JSON依然有很强的生命力.
	(2)JSON的格式非常严格,构建的JSON文件必须完整无误,任何一个括号的不匹配或者缺少逗号,都会导致页面上的脚本终止运行,甚至还会带来其他更加严重的负面影响.比如,我们返回的数据都必须要有双引号,必须是:{"username" : "张三"},而不能是:{username : '张三'}.

	通过堆3种数据格式的优缺点进行分析，可以得知在不需要与其他应用程序共享数据的时候，使用HTML片段来提供返回数据一般来说是最简单的；如果数据需要重用，那么JSON文件是不错的选择，它在性能和文件大小方面具有优势，而当远程应用程序未知时，XML文档是明智的选择，它是Web服务领域的“世界语“。具体选择哪种数据格式，并没有严格的规定。可以根据需求来选择最适合的返回格式。

→2.【$.post()】方法
	与$.get()方法结构和使用方式都相同，按仍然有以下区别
	（1）GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器。当然，在Ajax请求中，这种区别对用户是不可见的
	 (2) GET方式对传输的数据有大小限制（通常不能大于2kb）,而使用POST方式传递的数据量要比GET方式大得多(理论上不受限制)
	(3)GET方式请求的数据会被浏览器缓存起来,因此其他人就可以从浏览器的历史记录中读取到这些数据,例如账号和密码等.在某种情况下,GET方式会带来严重的安全性问题,而POST方式相对来说就可以避免这些问题
	(4)GET方式和POST方式传递的数据在服务器端的获取也不相同.在PHP中,GET方式的数据可以用$_GET[]获取,而POST方式可以用$_POST[]获取.两种方式都可以用$_REQUEST[]来获取.

	jQuey代码(GET方式):
	   $("#send").click(function(){
		$.get("get1.php", { 
			username :  $("#username").val() , 
			content :  $("#content").val()  
		      }, function (data, textStatus){
                        	$("#resText").html(data); // 把返回的数据添加到页面上
			 }
		      );
	   })
	另外,当load()方法带有参数传递时,会使用POST方式发送请求.因此也可以使用load()方法来完成同样的功能.
	jQuey代码(POST方式):
	   $("#send").click(function(){
		$('#send').click(function(){
			$('#resText').load('post1.php',{
				username : $('#username').val(),
				content : $('#content').val()
			})
		})
	   })
	上面使用load(),$.get()和$.post()方法完成了一些常规的AJax程序,如果还需要编写一些复杂的Ajax程序,那么就要用到jQuery中的$.ajax()方法.$.ajax()方法不仅能实现与load(),$.get(),和$.post()方法同样的功能,而且还可以设定beforeSend(提交前回调函数),error(请求失败后处理),success(请求成功后处理),以及complete(请求完成后处理)回调函数,通过这些回调函数,可以给用户更多的Ajax提示信息.另外,还有一些参数,可以设置Ajax请求的超时时间或者页面的"最后更改"状态等.关于$.ajax()方法将在后面的章节进行讲解

6.5.3	$.getScript()方法和$.getJson()方法

	1.【$.getScript()】
	有时候,在页面初次加载时就取得所需的全部JavaScript文件是完全没有必要的.虽然可以在哪个JavaScript文件时,动态地创建<script>标签
	$(document.createElement('script')).attr('src','test.js').appendTo('head');
	或者
	$('<script type="text/javascript" sec="test.js">').appendTo('head');

	但这种方式并不理想,为此,jQuery提供了$.getScript()方法来直接加载js文件,与加载一个HTML片段一样简单方便,并且不需要对javascript文件进行处理,javascript文件会自动执行
	$('$send').click(function(){
		$.getScript('text.js');
	})

	→text.js外部js代码:
      var comments = [
        {
          "username": "张三",
          "content": "沙发."
        },
        {
          "username": "李四",
          "content": "板凳."
        },
        {
          "username": "王五",
          "content": "地板."
        }
      ];

        var html = '';
        $.each( comments , function(commentIndex, comment) {
            html += '<div class="comment"><h6>' + comment['username'] + ':</h6><p class="para">' + comment['content'] + '</p></div>';
        })

        $('#resText').html(html);

	与其他Ajax方法一样,$.getScript()方法也有回调函数,它会在JavaScript文件成功载入后运行.例如想载入jQuery官方颜色插件(jQuey.color.js),成功后给元素绑定颜色变化动画,就可以用到$.getScript()方法的回调函数.
         $.getScript('http://dev.jquery.com/view/trunk/plugins/color/jquery.color.js',function(){
              $("<p>加载JavaScript完毕</p>").appendTo("body");
              $("#go").click(function(){
                   $(".block").animate( { backgroundColor: 'pink' }, 1000)
                              .animate( { backgroundColor: 'blue' }, 1000);
              });
         });
	当jquery-color.js动画插件完毕后,单击id为"go"按钮时,class为block的元素就有了颜色动画变化
	
====================================================
	利用js动态输出循环的标签内容.
	js代码:
	var str = '';
	for(var i = 0;  i < 13; i++){
		var a1 = '<p>我是' + i + '</p>';
		str += a1;
	}
	resText.innerHTML = str;
=====================================================		
	2.【$.getJSON()】
		$.getJSON()方法用于加载JSO文件,与$.getScript()方法的用法相同.
	$.getJSON()方法用于加载JSON文件,与$.getScript用法相同.
	
	$('#send').click(function(){
		$.getJSON('test.json');	
	})
	当点击"加载"按钮后,网页上看不到任何效果,苏日安函数加载了JSON文件,但是并没有告诉JavaScript对返回的数据如何处理,为此,jQuery提供了回调函数,在回调函数里处理返回的数据

	$('#send').click(function(){
		$.getJSON('test.json',function(data){
			data:返回的数据
		});	
	})
	
	可以在函数中通过data变量来遍历相应数据,也可以使用迭代方式为每个项构建相应的HTML代码.虽然在这里使用可以使用传统的for循环来实现,但既然是讲解jQuery,那么还是使用jQuery里的方法.jQuery提供了一个通用的遍历方法$.each(),可以用于遍历对象和数组

	$.each()函数不同于jQuery对象的each()方法,它是一个全局函数,不操作jQuery对象,而是以数组或则对象作为第1个参数,以一个回调函数作为第2个参数.回调函数拥有两个参数,第1个为对象的成员或数组的索引,第2个为对应变量或内容.

        $('#send').click(function() {
             $.getJSON('test.json', function(data) {
                 $('#resText').empty();
    			  var html = '';
    			  $.each( data  , function(commentIndex, comment) {
    				  html += '<div class="comment"><h6>' + comment['username'] + ':</h6><p class="para">' + comment['content'] + '</p></div>';
    			  })
    			 $('#resText').html(html);
            })
       })
	在上面的代码中,当返回数据成功后,首先清空id为resText的元素的内容,以便重新构造新的HTML,然后通过$.each()循环函数依次遍历每个项,并将遍历出来的内容构建成HTML代码拼接起来,最后将构建好的HTML添加到id为resText

	能通过JSON形式的回调函数来加载其他网站的JSON数据,例如从图片网站(http://Flickr.com)搜索汽车类别的4张最新图片
        $('#send').click(function() {
            $.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?tags=car&tagmode=any&format=json&jsoncallback=?",
    			  function(data){
    				  $.each(data.items, function( i,item ){
    						$("<img class='para'/> ").attr("src", item.media.m ).appendTo("#resText");
    						if ( i == 3 ) { 
    							return false;
    						}
    			      });
                 }
    	    ); 
       })
	上面代码再次用全局函数$.each()来遍历数据,因为只需要4张,所以当i=3时就需要退出循环.在$.each()函数中,如果需要退出each循环,只要返回false即可.



	→※注:(1)jQuery将自动把URL里的回调函数,例如"url?callback"中的后一个"?"替换为正确的函数名,已执行回调函数
	     (2)JSPNP(JSON with Padding)是一个非官方的协议,它允许在服务器端集成Script tags返回至客户端,通过JavaScript Callback的形式实现跨域访问.由于JSON只是一种含有简单括号结构的纯文本,因此很多通道都可以交换JSON消息而由于同源策略的限制,开发人员不能在与外部服务器进行通行的时候使用XMLHttpRequest,而JSONP是一种可以绕过同源策略的方法,即通过使用JSON与<script>标记相结合的方法,从服务器端直接返回可执行的JavaScript函数调用或者JavaScript对象,目前JSONP已经成为各大公司的Web应用程序跨域首选,例如Youtube,GDate,Google Social Graph,Digg,豆瓣,Del.icio.us等


6.5.4 【$.ajax()】

	$.ajax()方法是jQuery最底层的Ajax实现.
	他的结构为:
	$.ajax(options)
	该方法只有一个参数,但在这个对象里包含了$.ajax()方法所需要的请求设置以及回调函数等信息,参数以key/value的形式存在,所有参数都是可选的
	参数名称	类型		说明
	【url】		String		(默认为当前地址)发送请求的地址
	【type】	String		请求方式(POST或GET)默认为GET.注意其他HTTP请求方法,例如PUT和DELETE也可以使用,但仅部分浏览器支持
	【timeout】	Number		设置请求超时时间(毫秒).此设置将覆盖$.ajaxSetup()方法的全局设置
	【data】	Object或String	发送到服务器的数据,如果已经不是字符串,将自动转换为字符串格式.GET请求中将附加在URL后,防止这种自动转换,可以查看processData选项.对象必须为key/value格式,例如{fool:"bar1","foo2":"bar2"}转换为&foo1=bar1&foot2=bar2.如果是数组,jQuery将自动为不同值对应同一个名称.例如{foo:["bar1","bar2"]}转换为$foo=bar1&foo=bar2

	【dataType】	String		预期服务器返回的数据类型.如果不指定,jQuery将自动根据HTTP包MIME信息返回responseXML或responseText,并作为回调函数参数传递.
					可用类型:
					xml:返回XML文档的,可用jQ信息,uery处理
					html:返回纯文本HTML信息,包含的script标签会在插入DOM时执行
					script:返回纯文本JavaScript代码.不会自动缓存结果.除非设置了cache参数.注意在远程请求时(不在同一个域下),所有POST请求都将转为GET请求
					json:返回JSON数据
					jsonp:JSONP格式.使用JSONP形式调用函数时,例如myurl?call back=?,jQuery将自动替换后一个"?"为正确的函数名,以执行回调函数
					text:返回纯文本字符串
	【beforeSend】	Function	发送请求前可以修改XMLHttpRequest对象的函数,例如添加自定义HTTP头.在beforeSend中如果返回false可以取消本次AJax请求.XMLHttpRequest对象是唯一的参数
					function(XMLHttpRequest){this;调用本次Ajax请求时传递的options参数}
	【complete】	Function	请求完成后调用的回调函数(请求成功或失败时均调用)
					参数:XMLHttpRequest对象和一个描述成功请求类型的字符串
					function(XMLHttpRequest,textStatus){this;//调用本次Ajax请求时传递的options参数}
	【success】	Funtion		请求成后调用的回调函数,有两个参数.
					(1)由服务器返回,并根据dataType参数进行处理后的数据.
					(2)描述状态的字符串
					function(data,textStatus){
						//data可能是xmlDoc,jsonObj,html,text等等
						this;//调用本次Ajax请求时传递的options参数
					}
	【error】	Funtion		请求失败时被调用的函数.该函数有3个参数,即XMLHttpRequest对象,错误信息,捕获的错误对象(可选) Ajax时间函数如下:
					function(){
					//通常情况下textStatus和errorThown只有其中一个包含信息
					this;//调用本次AJax请求时传递的options参数
					}
	【global全球】	Funtion		默认为true,表示是否触发全局Ajax事件.设置为fasle将不会触发全局AJax事件,AjaxStart或AjaxStop可用于控制各种Ajax事件
	
	如果需要使用$.ajax()方法来进行AJax开发,那么上面这些常用的参数都必须了解.此法,$.ajax()方法还有其他参数,读者可以参考附录D的具体介绍
	
	前面用到$.load(),$.get(),$.post(),$.getScript()和$.getJSON(),都是基于$.ajax()方法构建的,$.ajax()方法是jQuery最底层的Ajax实现,因此可以用它来代替前面的所有方法.

	例如,可以使用下面的jQuery代码代替$.getScript方法:
	$('#send').click(function(){
		$.ajax({
			type : 'GET',
			url : 'test.js',
			dataType : 'script'
		})
	})
	再例如,可以使用以下jQuery代码来代替$.getJSOON()方法:
	$('send').click(function(){
		$.ajax({
			type : 'GET',
			url : 'test.js',
			dataType : 'json',
			succes	: function(data){
				$('#resText').empty();
				var html = '';
				$.each(data,function(索引值,data数据){
					html += '<div class="comment"><h6>',
						+ data['username'] + '</h6><p class="para">'
						+ data['content'] + '</p></div>';
				})
				$('#resText').html(html);
				
			}
		})
	})

6.6【序列化元素】
	1.【serialize()】方法,获取表单内所有value值并进行字符串拼接username=用户名&password=密码等
		serialize连播
	做项目的过程中,表单是必不可少的,经常用来提供数据,例如注册,登录等.常规的方法是使表单提交到另一个页面,整个浏览器都会被刷新,而使用Ajax技术则能够异步地提交表单,并将服务器返回的数据显示显示在当前页面中
	前面在讲解$.get()和$.post()方法的时候,表单的HTML代码如下:
	<form id="form1" action="#">
		<p>评价:</p>
		<p>姓名:<input type="text" name="username" id="username"></p>
		<p>内容:<textarea name="content" id="content" rows="2" clos="20"></textarea></p>
		<p><input type="button" id="send" value="提交"></p>
	</form>
	为了获取姓名和内容,必须将字段的值逐个添加到data参数中.
	$('#send').click(functio(){
		$.get('get1.php',{
		username : $('#username').val(),
		content : $('#content').val()
	},function(){
		$('#resTest').html(data); //将返回的数据添加到页面上
	})
	})
	这种方式在只有少量字段的表单中，勉强还可以使用，但如果表单元素越来越复杂，使用这种方式在增大工作量的同时也使表单缺乏弹性，jQuey为这一常用的操作提供了一个简化的方法--serialize（）。与jQuery其他方法一样，serialize()方法也是作用于一个jQuery对象，它能够将DOM元素内容序列化为字符串，用于Ajax请求。通过使用serialize()方法,可以把刚才的jQuery代码改为如下：
	$('$send').click(function(){
		$.get('get1.php',$('#form1').serialize(),function(data,textStatus){
			$('#resText').html(data);
		})
	})
	即使在表单中再增加字段,脚本仍然能够使用,并且不需要做其他多余工作
	需要注意的是,$.get()方法中data参数不仅可以使用映射方式
	{
		username : $('#username').val(),
		content : $('#content').val()
	}
	也可以使用字符串方式,如以下jQuery:
	"username=" + encodeURLComponent($('#username').val())
	+ "&content=" + encodeURLComponent($('#content').val())
	→【用字符串方式时,需要注意对字符编码(中文问题),如果不希望编码带来麻烦,可以使用serialize()方法,它会自动编码】
	因为serialize()方法作用于jQuery对象,所以不光表单能使用它,其他选择器选取的元素也能使用它,如以下jQuqey代码:
	$(':checkbox,radio').serialize();
	DOM结构:
	<input type="checkbox" name="check" value="1" checked="checked"/>篮球<br/>
   	<input type="checkbox" name="check" value="2" />足球<br/>
    	<input type="checkbox" name="check" value="3" />乒乓球<br/>
    	<input type="checkbox" name="check" value="4" />羽毛球<br/>

    	<input type="radio" name="radio" value="1" checked="checked"/>篮球<br/>
    	<input type="radio" name="radio" value="2" />足球<br/>
   	<input type="radio" name="radio" value="3" />乒乓球<br/>
    	<input type="radio" name="radio" value="4" />羽毛球<br/>

	jQuery:
   	$("#send").click(function(){
        	var $data =  $(":checkbox,:radio").serialize();
        	alert( $data );//check=1&radio=1
   	})
	把复选框和单选框的值序列化为字符串形式,只会被选中的值序列号

2.【serializeArray()】方法
	在jQuery中还有一个与serialize()类似的方法--serializeArray(),该方法不是返回字符串,而是将DOM元素序列化后,返回JSON格式的数据
	DOM结构:
        <input type="checkbox" name="check" value="1" checked="checked"/>篮球<br/>
        <input type="checkbox" name="check" value="2" checked="checked"/>足球<br/>
        <input type="checkbox" name="check" value="3" checked="checked"/>乒乓球<br/>
        <input type="checkbox" name="check" value="4" />羽毛球<br/>


        <input type="radio" name="radio" value="1" checked="checked"/>篮球<br/>
        <input type="radio" name="radio" value="2" />足球<br/>
        <input type="radio" name="radio" value="3" />乒乓球<br/>
        <input type="radio" name="radio" value="4" />羽毛球<br/>

	jQuery代码:
         var fields = $(":checkbox,:radio").serializeArray();
             console.log(fields);// Firebug输出
             $.each( fields, function(i, field){
                $("#results").append(field.value + " , "); //1 , 2 , 3 , 1 
            }); 
       })
3.【$.param()】方法,必须外部是对象,内部是数组或对象键值对都能拼接url字符串并编码
	它是serialize()方法的核心,用来对一个数组或对象按照key/value进行序列号
	比如将一个普通的对象序列号:
	var obj = {a:1,b:2,c:3}
	var k = $.param(obj);
	alert(k); //输出a=1&b=2&c=3

6.7 jQuery中的Ajax全局事件
	jQuery简化Ajax操作不仅体现在调用Ajax方法和处理响应方面,而且还体现在对调用AJax方法的过程中的HTTP请求的控制.通过jQuery提供的一些自定义全局函数,能够为各种与Ajax相关的事件注册回调函数.例如当Ajax请求喀什时,会触发ajaxStart()方法的回调函数,当Ajax请求结束时,会触发ajaxStop(0方法的回调函数.这些方法都是全局的方法,因此无论创建它们的代码位于何处,只要有Ajax请求时,就会触发它们.在前面例子中,远程读取Flicker.com网站的图片速度可能会比较慢,如果在加载的过程中,不给用户提供一些信息和反馈信息,很容易让用户误认为按钮单击无用,使用户对网站失去信息.

此时,就需要为网页添加一个提示信息
	<div id="loading">加载中...</div>
	loading装载
	然后用CSS控制元素隐藏,当AJax请求开始的时候,将此元素显示,用来提示用户Ajax请求正在进行.当Ajax请求结束后,将此元素隐藏.
	$('#loading').ajaxState(function(){
		$(this).show();
	})
	$('#loading').ajaxStop(function(){
		$(this).hide();
	}) //也可以使用链式写法

	这样一来,在Ajax请求过程中,只要图片还未加载完毕,就会一直显示"加载中..."的提示信息,看似和简单的一个改进,却将极大地改善用户的体验

	如果在此页面中的其他地方也使用Ajax,该提示信息仍然有效,因为它是全局的.

	jQuery的AJax全局事件中还有几个方法,也可以在使用AJax方法的过程中为其带来方便.
===================================================================
方法名称			说明	
ajaxComponent(callback)		Ajax请求完成时执行的函数
ajaxError(callback)		AJax请求发生错误时执行的函数
ajaxSend(callback)		Ajax请求发送前执行的函数
ajaxSuccess(callback)		Ajax请求成功时执行的函数
===================================================================
	※注:如果想使某个Ajax请求不受全局方法的影响,那么可以在使用$.ajax(options)方法时,将参数中的global设置为false,jQuery代码如下:
	$.ajax({
		url : "test.html",
		global : false //不触发全局Ajax事件
	});
	global 全球的,全局的
	2.在jQury1.5版本之后,如果ajax请求不触发全局方法,那么可以设置
	$.ajaxPrefilter(function(options){
		options.global = true;
	})
	【$.ajaxPrefilter】
	具体原因请查看:http://bugs.jquery.com/tickt/8338

	
	

6.8	基于jQuery的Ajax聊天室程序
	下面,将讲解一个较为复杂的Ajax实例,可以帮助读者更好地掌握Ajax的精髓--一个无需刷新技术开发的聊天室程序,改程序允许多用户在网页上聊天,并且可以实时地更新信息.

6.8.2设计数据库
	这里使用MySql数据库来储存信息
	首先构建一个聊天信息表messages,它有4个字段,即消息编号(id),姓名(user),内容(msg)以及一个数字时间戳(time).下面是创建该表的SQL代码:
	CREATE_TABLE 'messages' {
		'id' int(7) NOT NULL auto_increment,
		'user' varchar(255) NOT NULL,
		'msg' text NOT NULL,
		'time' int(9) NOT NULL,
		PRIMARY KEY ('id')
	};
6.8.3	服务器端处理
	服务器端主要用来处理用户提交的信息以及输出返回
		首先需要在服务器端链接数据库.
		其次如果有用户提交新信息,则把信息插入数据库,同时删除旧的数据信息(保持数据库中只有10条信息)
		最后从数据库中获取新的信息并以XML格式输出返回
	这里可以先模拟服务端输出的XML代码结构,XML文档代码如下:
	<?xml version="1.0" encoding="UTF-8"?>
	<response>
		<status>1<status>
		<time>1170323512</time>
		<message>
			<author>张三</author>
			<text>沙发!</text>
		</message>
		<message>
			<author>李四</author>
			<text>板凳!</text>
		</message>
	</response>
在这个XML结构中,不光只有消息的实体(包括作者及其聊天信息),还增加了一个"status"标签和一个"time"标签.其中"status"标签用来表示信息请求的状态,如果值为1,则表示新信息请求成功,如果值为2,则表示请求成功但没有新信息."time"标签用来记录信息请求的时间,可以被用来读取该时间戳后用户提交的新数据.

6.8.4	客户端处理
	在客户端需要做两项工作.
		首先提交用户聊天信息,然后处理服务器端返回的聊天信息,将信息实时呈现出来.
		每隔一定时间发起查询数据库中聊天记录,然后处理服务端返回的聊天信息,将信息实时呈现出来.
	(1)提交用户聊天信息
	使用POST方式向服务器发送请求,将用户填写的姓名和内容等数据传递到服务器端,在服务器端处理后返回相应的XML数据,然后使用回调函数处理服务器端返回的这些数据,并将新信息追加到客户端的信息显示区中.
	(2)浏览器每隔一定时间更新数据
	增加一个定时器,并且每隔一定时间调用一次.然后使用回调函数处理服务器端返回的XML数据,并将新信息追加到客户端的消息显示器中
	由于上面的两项工作都需要对XML文档进行解析,然后追加到信息显示区,因此可以将此操作进行封装,以便于重复利用.在设计该XML文档操作时,应注意通过状态("status"标签)和时间戳('time'标签)来控制获取聊天信息

6.8.5	客户端代码
	1.客户端HTML代码
	首先建立一个HTML页面.从前面的外观设计可以知道页面需要一个外围<div>,一个消息段落(用来显示聊天信息),姓名文本框,消息文本,提交按钮的表单和一个加载信息时的提示.HTML代码如下:
	
	DOM结构:
		<div id="wrapper">
		<p id="messagewindow"><span id="loading">加载中...</span></p>
		<form id="chatform" action="#">
			姓名： <input type="text" id="author" size="50"/><br />
			内容： <input type="text" id="msg"  size="50"/>   <br /> 
			<input type="submit" value="发送" /><br />
		</form>
	</div>

2.客户端jQuery代码
	首先,需要设置当前消息的时间戳为0,并且调用函数来加载数据库已有的聊天消息,代码如下:
	timestamp = 0;  //时间戳
	updateMag(); //调用更新信息函数(后面讲解该函数的具体内容)
	然后,为表单添加一个submit事件,代码如下:
	$('#chatform').submit(function(){
		//代码
	})
	在submit事件函数中,可以使用jQuery的$.post()方法来发送一个POST请求,把要传递的数据都放入第2个参数中,用{}包裹,代码如下
	$.post('backend.php',{
		message : $('#msg').val(),
		name : $('#author').val(),
		action : "postmsg",
		time : timestamp
	},function(xml){
		//处理xml
	});
	接下来,如何响应返回的XML呢?为了使代码能被重用,这里创建一个处理XML的函数并且调用该函数(在updateMsg()方法中,也要用到这个解析XML的函数).函数如下
	addMessages(xml); //处理xml
	addMessages()函数里的具体内容将在后边实现.

	$('#chatform').submit(function(){
		$.post('backend.php',{
			message : $('#msg').val(),
			name : $('#author').val(),
			action : "postmsg",
			time : timestamp
		},functiom(xml){
			$('#msg').val(""); //清空信息文本框内容
			addMessages(xml)	//调用解析xml的函数
		});	
		return false;	//阻止表单提交
	})

	在表单提交事件的最后一行添加了"return false";语句,可以用来阻止浏览器提交表单.
	
	现在再看addMessges()函数,它是用来处理XML响应信息的.前面讲解过,jQuery遍历XML文档与遍历DOM一样.使用XML文档中的状态码,其代码如下:
	function addMessages(xml){
		if($('status',xml).text() == '2') return; //如果值为2,则表示请求成功但没有新信息
	}
	上段代码中使用$('status',xml)方法来通知jQuery去XML文档中寻找"status"标签.如果状态代码为2,则表示完成了请求但没有新信息需要添加到该客户端的消息显示区中,因此使用"return"语句终止函数调用.如果状态代码不为2,则继续往下执行.
	解析来需要为XML的时间戳设定新的值,用来传递给后台去查询新的数据,获取时间戳的代码如下:
	timestamp = $('time',xml).text();
	然后使用$.each()函数将XML文档里的数据遍历出来.在示例中,需要显示到客户端消息显示区的元素就是服务器端返回的每一个"message"标签的实例,每个实例代表一条要显示的消息.
	$('message',xml).each(function(){
		var author = $('author',this).text(); //发布者 
		var conten = $('text',this).text;	
		var htmlcode = '<strong>' + author + '</strong>: '+ content + '<br />';
	})
	得到了所需的数据之后,就可以将其追加到消息显示区里.消息显示窗体的id为"messagewindow",因此可以使用$('#messagewindow')来选择到它并且使用prepend()来追加数据,代码如下
	function addMessages(xml) {
	    //如果状态为2，则终止
		if($("status",xml).text() == "2") return;
		timestamp = $("time",xml).text(); //更新时间戳		
		$("message",xml).each(function() { //使用$.each()方法循环数据
		    var author = $("author",this).text(); //发布者
			var content = $("text",this).text();  //内容
			var htmlcode = "<strong>"+author+"</strong>: "+content+"<br />";
			$("#messagewindow").prepend( htmlcode ); //添加到文档中
		});
	}

	最后只剩下刚开始调用的函数updataMag()还未完成.该函数的功能是到服务器查询新信息,并且调用addMessahes函数来响应返回的XML文档,同时需要设置一个间隔时间,让聊天窗口自动更新.要开始做这些工作,只需要向服务器提交一个时间戳,引发这个$.post()调用即可,代码如下
	$.post('backend.php',{time:timestamp},function(xml){
		//处理xm文档
	});
	在回调函数里,首先应该移除loading消息,可以在这个元素上调用remove()方法
	$('loading').remove();
	然后,在回调函数中将接受到的XML文档对象传递给addMessages()函数,
	addMessages(xml);
	最后调用JavaScript的setTimeout()方法来每隔一定时间执行updateMsg函数:
	updateMsg()函数内容代码
	function updateMsg(){
		$.post("backend.php",{ time: timestamp }, function(xml) {
			//移除掉 等待提示
			$("#loading").remove();
			//调用解析xml的函数
			addMessages(xml);
		});
		 //每隔4秒，读取一次.
		setTimeout('updateMsg()', 4000);
	}
============================================================
完整jq聊天室代码
	→DOM结构
	<div id="wrapper">
		<p id="messagewindow"><span id="loading">加载中...</span></p>
		<form id="chatform" action="#">
			姓名： <input type="text" id="author" size="50"/><br />
			内容： <input type="text" id="msg"  size="50"/>   <br /> 
			<input type="submit" value="发送" /><br />
		</form>
	</div>

	→jQuery代码	$(function(){
	    //定义时间戳
		timestamp = 0;
		//调用更新信息函数
		updateMsg();
		//表单提交
		$("#chatform").submit(function(){
			$.post("backend.php",{
						message: $("#msg").val(),
						name: $("#author").val(),
						action: "postmsg",
						time: timestamp
					}, function(xml) {
				//清空信息文本框内容
				$("#msg").val("");
				//调用解析xml的函数
				addMessages(xml);
			});
			return false; //阻止表单提交
		});
	});
    //更新信息函数，每隔一定时间去服务端读取数据
	function updateMsg(){
		$.post("backend.php",{ time: timestamp }, function(xml) {
			//移除掉 等待提示
			$("#loading").remove();
			//调用解析xml的函数
			addMessages(xml);
		});
		 //每隔4秒，读取一次.
		setTimeout('updateMsg()', 4000);
	}
    //解析xml文档函数，把数据显示到页面上
	function addMessages(xml) {
	    //如果状态为2，则终止
		if($("status",xml).text() == "2") return;
		//更新时间戳
		timestamp = $("time",xml).text();
		//$.each循环数据
		$("message",xml).each(function() {
		    var author = $("author",this).text(); //发布者
			var content = $("text",this).text();  //内容
			var htmlcode = "<strong>"+author+"</strong>: "+content+"<br />";
			$("#messagewindow").prepend( htmlcode ); //添加到文档中
		});
	}

	→xml代码:
        <?xml version="1.0" encoding="UTF-8"?>
        <response> 
         <status>1</status> 
         <time>1170323512</time> 
         <message> 
           <author>张三</author> 
           <text>沙发!</text> 
         </message> 
         <message> 
           <author>李四</author> 
           <text>板凳!</text> 
         </message> 
        </response>

	→SQL数据库代码:
	--Database "chat"

	CREATE TABLE `messages` (
  	`id` int(7) NOT NULL auto_increment,
 	 `user` varchar(255) NOT NULL,
 	 `msg` text NOT NULL,
 	 `time` int(9) NOT NULL,
 	 PRIMARY KEY  (`id`)
	);

	→PHP代码:
		<?php
		// 配置信息：
		// 1,数据库连接的具体信息
		// 2,我们要存储的消息的数目
		// 3,用户进到聊天室的时候消息显示的数目
		$dbhost = "localhost";
		$dbuser = "root";
		$dbpass = "root";
		$dbname = "chat";
		$store_num = 10;
		$display_num = 10;

		// 错误报告
		error_reporting(E_ALL);

		// 头部信息
		header("Content-type: text/xml");
		header("Cache-Control: no-cache");

		//连接mysql
		$dbconn = mysql_connect($dbhost,$dbuser,$dbpass);
		mysql_select_db($dbname,$dbconn);

		//为容易操作请求数据,我们为请求中的每个参数设置一个变量,每个变量将把请求中的参数值作为其自己的值
		//foreach语句遍历所有的POST数据,并且为每个参数创建一个变量,并且给它赋值
		foreach($_POST as $key => $value){
			$$key = mysql_real_escape_string($value, $dbconn);
		}

		//屏敝任何错误提示,判断action是否等于 postmsg
		if(@$action == "postmsg"){
			//插入数据
			mysql_query("INSERT INTO messages (`user`,`msg`,`time`) 
			             VALUES ('$name','$message',".time().")",$dbconn);
			//删除数据(因为我们默认值存储10条数据)
			mysql_query("DELETE FROM messages WHERE id <= ".
						(mysql_insert_id($dbconn)-$store_num),$dbconn);
		}

		//查询数据
		$messages = mysql_query("SELECT user,msg
								 FROM messages
								 WHERE time>$time
								 ORDER BY id ASC
								 LIMIT $display_num",$dbconn);
		//是否有新记录
		if(mysql_num_rows($messages) == 0) $status_code = 2;
		else $status_code = 1;

		//返回xml数据结构
		echo "<?xml version=\"1.0\"?>\n";
		echo "<response>\n";
		echo "\t<status>$status_code</status>\n";
		echo "\t<time>".time()."</time>\n";
		if($status_code == 1){ //如果有记录
			while($message = mysql_fetch_array($messages)){
				$message['msg'] = htmlspecialchars(stripslashes($message['msg']));
				echo "\t<message>\n";
				echo "\t\t<author>$message[user]</author>\n";
				echo "\t\t<text>$message[msg]</text>\n";
				echo "\t</message>\n";
			}
		}
		echo "</response>";
		?>


7.1 jQuery表单验证插件---Valldation
	最长使用JavaScript场合就是表单的验证,而jQuery作为一个优秀的JavaScript库,也提供了一个优秀的表单验证插件---Validation.Validation是历史最悠久的jQuery插件之一,经过了全球范围内不同项目的验证,并得到了许多Web开发者的好评.作为一个标准的验证方法库,Valition拥有以下特点:
	1.内置验证规则:拥有必填,数字,E-Mail,URL和信用卡号码等19类内置验证规则.
	2.自定义验证规则:可以很方便地自定义验证规则
	3.简单强大的验证信息:默认了验证信息提示,并提供自定义覆盖默认提示信息的功能
	4.实时验证:可以通过keyup或bluer事件触发验证,而不仅仅在表单提交的时候验证.
	
	https://github.com/jquery-validation/jquery-validation/tree/1.16.0
	https://github.com/jquery-archive/jquery-metadata

→【※注:jquery1.9.0及之后之后版本不支持validate插件,所以要使用用1.8多的版本】

三种使用方法:
	1.在jQuery入口函数内,直接内开启插件
		 $("#这是form的id").validate();
	再在要验证的inout内添加class【required】
	如果是验证用户名在元素名添加属性名【minlength="2"】
	如果是验证电子邮箱在class填【required email】
	如果验证URL网址在class内填【url】
	如果验证textarea评论,在class内填【required】
	
第二种:使用class添加对象实现
	用户名: class填【{validate:{required:true, minlength:2}}】
	电子邮箱:class填【{validate:{required:true, email:true}}】
	URL网址:class填【{validate:{url:true}}】
	textarea评论:class填【{validate:{required:true}}】

第三种:使用name,直接用jquery实现 ←推荐 但不支持自定义
    $("#commentForm").validate({
      rules: {
        username: {
          required: true,
          minlength: 2
        },
        email: {
          required: true,
          email: true
        },
        url:"url",
        comment: "required"
      }
      });

	【rules】条例
	【required】必须的





	【jquery.validate.js】默认是英文,需要引入中文验证信息库
	【validate.messages_cn.js】是将
	【jquery.metadata.js】



7.1.4 不同的验证写法
	以上,必须把required,url和email写到class属性里,才能完成验证,url验证和E-mail验证,把mainlength属性的值设置为2,才能完成最小长度为2的验证.虽然class和minlength属性都符合W3C规范,但对于开发者来说,时而将与验证相关的信息写在class属性里面,时而又写在minlength属性里面实在很麻烦,Validation充分考虑到了这一点,读者可以将所有的与验证相关的信息写在class属性中方便管理.为了实现这个功能,
	(1)引入一个新的jQuery插件-jquery-metadata.js
	注意:jQuery.metadata.js是一个支持固定格式解析的jQuery插件,Validation插件将其很好地融合到验证规则编码中,通过下面的例子,读者可以很容易了解到需要掌握的格式,更详细metadata参见http://plugins.jquery.com/projiect/metadata

	(2)改用调用的方法

第一种:class内填写
	改成$('#formId').validata(meta : "validate")
	用户名class填【{{validate:{required:true, minlength:2, messages:{required:'请输入姓名', minlength:'请至少输入两个字符'}}}】
	新增【messages:{required:'请输入姓名', minlength:'请至少输入两个字符'}】可自定义提示信息
	
第二种jQuery 添加自定义提示信息并美化:
	→【在rules里添加messages : {name名 : "自定义信息"}】
	如果不添加中文信息库,自定义提示信息,就默认英文.
	像url和评论框直接设置 "url" : "提示信息",不用写大括号

	要设置正确,错误图标,在css填写 em.error{定义背景图,设置样式},不用写在标签内
		→※注:添加类名必须是error和success,否则无法使用
	在errorElement: "em"后面填写要提示正确.错误图标的标签名
	再使用success回调函数,添加添加正确的class,如果不对,会默认选择另一个不正确的class.
 		success : function(index){
           		 index.text('')
				 .addClass('success')
		}
           →※注:这里要注意,形参代表的就是上面显示正确.错误图标的标签名.
    $("#commentForm").validate({
        rules: {
            username: {
                required: true,
                minlength: 2
            },
            email: {
                required: true,
                email: true
            },
            url:"url",
            comment: "required"
        },
        
        messages: {
            username: {
                required: '请输入姓名',
                minlength: '请至少输入两个字符'
            },
            email: {
                required: '请输入电子邮件',
                email: '请检查电子邮件的格式'
            },
            url: '请检查网址的格式',
            comment: '请输入您的评论'
        },  
        
        errorElement: "em", //可以用其他标签，记住把样式也对应修改
        success: function(label) {
            //label指向上面那个错误提示信息标签em
            label.text(" ")             //清空错误提示消息
                .addClass("success");   //加上自定义的success类
        }
      });
7.1.6自定义验证规则
	衡量一个表单验证插件是否优秀的重要标准是看它是否有良好的自定义验证规则.由于需求的多种多样,除提供的默认验证规则外,还需要自定义验证规则,满足业务需要.
	在很多网站中,表单中都包括验证码,通过自定义验证规则,可以轻易地完成验证码的验证.
	
	在很多网站中,表单中都包括验证码,通过自定义验证规则,可以轻易地完成验证码的验证.
	首先在上面例子的基础上,添加验证"验证码"的HTML代码,代码如下:
	<p>
		<label for="cvalcode">验证码</label>
		<input id="cavlcode" name="valcode" size="25" value="" /> = 7+9
	</p>
	为了实现验证"验证码"的功能,需要完成以下几个步骤
	(1)自定义一个验证规则
	$.validator.addMethod(
    		"formula", //验证方法名称
   		 function(value, element, param) {//验证规则
        		return value == eval(param);
    		},
		'请正确输入数学公式计算后的结果'//验证提示信息'
	);
	(2).调用该验证规则.
	jQuery代码中rules中加入valcode:{formula : "7+9"},其中"7+9"这个字符串可以通过其他手段获得,例如获取页面某个元素的text()或则通过Ajax来取得.这里为了简化就简单写成了"7+9"
	     valcode: {formula: "7+9"}
7.1.7 API
		Validation 插件的官方API地址为:
		http://docs.jquery.com/Plugins/Validation

	 【$.validator.addMethod()】添加一个验证规则
    //自定义一个验证方法
    $.validator.addMethod(
    "formula", //验证方法名称
    function(value, element, param) {//验证规则
        return value == eval(param);
    }, 
    '请正确输入数学公式计算后的结果'//验证提示信息
    );
    $("#commentForm").validate({
        rules: {
            username: {
                required: true,
                minlength: 2
            },
            email: {
                required: true,
                email: true
            },
            url:"url",
            comment: "required",
            valcode: {
                formula: "7+9"  
            }
        },
        messages: {
            username: {
                required: '请输入姓名',
                minlength: '请至少输入两个字符'
            },
            email: {
                required: '请输入电子邮件',
                email: '请检查电子邮件的格式'
            },
            url: '请检查网址的格式',
            comment: '请输入您的评论'
        },  
        errorElement: "em",             //用来创建错误提示信息标签
        success: function(label) {          //验证成功后的执行的回调函数
            //label指向上面那个错误提示信息标签em
            label.text(" ")             //清空错误提示消息
                .addClass("success");   //加上自定义的success类
        }
      });

	
7.2 jQuery表单插件-Form [jq表单插件]
	jQuery Form插件是一个优秀的Ajax表单插件,可以非常容易地,无侵入地升级HTML表单以支持Ajax.jQuery Form有两个核心方法---ajaxForm()和ajaxSubmit(),它们集合了从控制表单元素到决定如何管理提交进程的功能.另外,插件还包括其他的一些方法: formToArray(),formSerialize()().fieldSerialize(),fieldVakue(),clearForm(),clearFields()和resetForm()等.
	【field】接收
	Mike Alsup 设计了jQuery Form插件,并进行改善和维护.
		
7.2.2 下载地址:
jQuery Form 表单插件的下载地址为:
	http://jquery.malsup.com/form/#download
	在图7-9所示的界面中,可以下载该插件,并在该网站上查看简单上手说明,API,实例代码.文件上传说明和FAQ等.

	AjaxForm插件
	→【注:jquery-1.3.2可使用】1.4以上版本不支持

	DOM结构:
	<form id="myForm" action="demo.php" method="post"> 
	    名称： <input type="text" name="name" /> <br/>
		地址： <input type="text" name="address" /><br/> 
	    自我介绍： <textarea name="comment"></textarea> <br/>
	    <input type="submit" id="test" value="提交" /> <br/>
	    <div id="output1" style="display:none;"></div>
	</form>

7.2.4	核心方法-ajaxForm()和ajaxSubmit()
	通过核心方法ajaxForm(),能很容易的将表单升级为Ajax提交方式.
  		$('#myForm').ajaxForm(function() {   
               		$('#output1').html("提交成功！欢迎下次再来！").show();    
        	});

	Form插件还有一个核心方法ajaxSubmit()也能完成同样的功能
        	$('#myForm').submit(function() { 
                  	 $(this).ajaxSubmit(function() {   
                		$('#output1').html("提交成功！欢迎下次再来！").show();    
               		 }); 
               		return false; //阻止表单默认提交
        	});
	通过调用ajaxSubmit()方法来响应用户的提交表单操作,从而使表单的提交方式由传统的提交方法转变为AJax提交方式.
	
	通过Form插件的这两个和新方法,都可以在不修改表单的HTML的HTML代码结构的情况下,轻易地将表单的提提交方式升级为Ajax提交方式.

	ajaxForm()方法和ajaxSubmit()方法都能接收0个或者1个参数.当为单个的参数时,该函数既可以是一个回调函数也可以是一个opetions对象.上面例子参数就是回调函数.接下来介绍options对象,通过给ajaxForm()方法和ajaxSubmit()方法传递options对象,使得它们对表单拥有更多的控制权.

	首先定义一个对象opations,然后在对象里设置参数,代码如下:
	var options = {
		target : '#output1', //将服务器返回的内容放入id为output1的元素中
		beformSubmit : showRequest, //提交前的回调函数
		success ; showResponse,	//提交后的回调函数
		url : url,	//默认是form的action,如果申明,则会覆盖
		type : type,	//默认是form的method('get' or 'post'),如果申明,则会覆盖
		dataType : null, //"xml","script",or"json"(接受服务端返回的类型)
		clearForm : true, //成功提交后,清除所有表单元素的值
		resetForm : true, //成功提交后,重置所有表单元素的值
		timeout : 3000	//限制请求的事件,当强求大于3秒后,跳出请求
	}

	定义options对象之后,就可以把这个options对象传递给ajaxForm()方法,jQuery代码如下
	$('#myForm').ajaxForm(options)
	或者传递给ajaxSubmit()方法
	$('#myForm').submit(function(){
		$(this).ajaxSubmit(options);
		return false;
	})

	在opations对象里,指定了两个回调函数,即beforeSubmit:showRequest和success:showResponse,它们分别会在表单提交前和表单提交后被调用

	下面来看看这两个回调函数具体有哪些参数.
	【beforeSubmit】提交前的回调函数
	提交前的回调函数的代码如下:
	function showRequest(formData,jqForm,options){
		var queryString = $.param(formData);
		return true;
	}
	这个回调函数有3个参数.
	第一个参数formdata是数组对象.在这里,使用$.param()方法把它转换为字符串,得到如下这种格式:
	name=1&address=2
	
	这种格式可以使用【serialize()】将表单所有value转换成url格式	

	需要注意的是,当表单提交时,Form插件会以Ajax方式自动提交这些数据.
	第2个参数jqForm是一个jQuery对象,它封装了表单的元素.
	如果需要访问jqForm的DOM元素,可以把jqForm转换为DOM对象.
	var formElement = jqForm[0];
	var address = formElement.address.value;

	注:第二个参数其实就是使用$()获取form的id或class
	转换DOM对象,使用$()[0]或get(0)
	
	第3个参数options就是options对象.前面已经声明了options对象里的一些属性,其他声明的,则会使用默认的属性.
	在这个回调函数中,只要不返回false,表单都被允许提交,如果返回false,则会阻止提交.可以利用这个特性,在表单提交之前验证数据(后面将详细讲解),如果不符合验证规则,则阻止表单提交.

	【succes】--提交后的回调函数
	提交后的回调函数的代码如下:
	function showResponse(responseText,statusText,xhr,$form){
		alert('状态: ' + statusText + '\n 返回的内容是: ' \n + responseText);
	}
	success有4个参数responseText,statusText,xhr和$form.其中responseText和statusText2个比较常用

	statusText只是一个返回状态，例如success、 error等

	responseText携带着服务器返回的数据内容。responseText会根据设置的options对象中的
	dataType属性来返回相应格式的内容。具体情况如下。

	(1) 对于缺省的HTML返回，回调函数的第1个参数是XMLHttpRequest对象的responseText属性。
	(2) 当dataType属性被设置为xml时，回调函数的第1个参数是XMLHttpRequest对象的responseXML属性。
	例如声明服务器返回数据的类型为xml，然后以XML方式解析数据，代码如下:

	$('#xmlForm').ajaxForm({
		dataType : 'xml',
		success : processXml
	});
	function processXml(responseXML){
		var name = $('name',responseXML).test();
		var address = $('address',responseXML).text();
		$('#xmlOut').html(name +　' ' + address);
	}
	(3)当dataType属性被设置为json时，回调函数的第1个参数是从服务器返回的json数据对象。
	例如声明服务器返回数据的类型为json，然后以json方式解析数据，代码如下
	$('#myForm').ajaxForm({
		dataType : 'json',
		success : processJson
	})
	function processJson(data){
		$('#jsonOut').html(data.name + ' ' + data.address);
	}

	7.2.6 表单提交之前验证表单
	大多数情况下，需要在表单提交前对表单元素的值进行一次验证，如果不符合验证规则，则阻止表单提交。
	【beforeSubmit】会在表单提交前被调用。如果beforeSubmit返回false,则会阻止表单提交，利用这个特性，就可以轻松地完成验证表单元素的任务。
	首先定义一个validate回调函数，把它设置为beforeSubmit的值。
	beforeSubmit: validate

	然后编写validate函数，它有3个参数:
	function validata(formDate,jqForm,optins){
		在这里需要对表单元素进行验,如果不符合规则,
		将返回false来阻止表单提交,直至符合规则为止
		var queryString = $.param(formDate); //组装数据
		return true;

	}


	通过获取表单元素的值，对表单元素进行验证。Form插件获取表单数据的方式有多种，下面讲解其中的3种方式
	
	→方式1.利用参数【formData】
		参数formData是一个数组对象,其中的每个对象都有名称和值.其数据格式如下
	[
		{ name:  name, value: nameValue },
		{ name:  password, value: passwrdValue}
	]
	由于是数组，因此可以根据循环来获取每个元素的值，然后判断元素的值是否符合验证规则(这里只判断元素是否为空），如果有一项不符合验证规则，就返回false,来阻止表单提交。代码如下-
	
	function validata(formData,jqForm,options){
		for(var i = 0; i < formData.length; i++){
			if(!formDate[i].value){
				alert('用户名.地址和自我介绍都不能为空!');
				return false;
			}
		}
		var queryString = $.param(formData);
		return true;
	}
	
	→方式2.利用参数【jqForm】
	不仅可以利用第一个参数formData来获取表单数据,而且可以用第2个参数jqForm来达到同样的效果

	参数jqForm是一个jQuery对象，可以把jqForm转为DOM对象。
	它封装了表单的元素。如果需要访问jqForm的DOM元素,可以把jqForm转为DOM对象
	var form = jqForm[0];
	然后通过【form.name.value】来获取用户名的值；通过【form.address.value】来获取地址的值。代码如下:
	function validata(formData,jqForm,options){
		var form = jqForm[0];
		if(!form.name.value || !form.address.value){
			alert('用户名和地址不能为空,自我介绍可以为空!');
			return false;
		}
		var queryString = $.param(formData);
		return true;
	}
	
   	→ 方式3:利用【fieldValue()】方法
			field领域
		fieldValueO方法会把匹配元素的值插入到数组中，然后返回这个数组。
		如果表单元素的值被判定无效，则数组为空，否则数组将包含一个或多个元素的值。由于返回的是一个数组，而不是jQuery
对象，因此不能进行链式操作。
		利用fieldValueO方法，也能很容易地获取到表单元素的值。例如可以通过$('input[name=address]').fieldValue()来获取name为"address"的<input>元素的值的数组集合，然后通过数组下标来获取数组中对应的值。
	代码如下：
	function validata(formData,jqForm,options){
		var usernameValue = $('input[name:name]').fieldValue(),
		    addressValue = $('input[name=address]').fieldValue();
		if(!usernameValue[0] || !addressValue[0]){
			alert('用户名和地址不能为空,自我介绍可以为空!');
			return false;
		}
		var queryString = $.param(formData);
		return true;
	}
	通过以上几个例子可以清楚地知道，使用jQuery Form插件能够很容易地把一个传统的表单提交方式改变为Ajax提交方式，没有比这更简单的方法了。

	form插件的使用--formSerialize()组装表单数据,用于jQuery中的.ajax()

	【formSerialize()】拼接form表单里的,name和value值为url字符串
	【$('#formID名 *').fieldValue()】后面加星号就是索引以下的所有内容.fieldValue()获取以下value值
	【fieldValue()】 是表单插件的一个方法，它能找出表单中的元素的值，返回一个集合。
	
	【resetForm()】重置表单,恢复默认位置,包括单选框还原默认位置
	【clearForm()】清除表单,会连单选框也清空,需注意
	DOM结构:
      <!-- demo1 -->
          <form id="myForm" action="demo.php" method="post"> 
              名称： <input type="text" name="name" /> <br/>
          	地址： <input type="text" name="address" /><br/> 
              自我介绍： <textarea name="comment"></textarea> <br/>
              <input type="submit" id="test" value="提交" /> <br/>
              <div id="output1" style="display:none;"></div>
          </form>

          <br/><br/><br/>

          <!-- demo2 -->
          <form id="myForm2" action="demo.php" method="post"> 
              名称： <input type="text" name="name2" class="special"/> <br/>
          	地址： <input type="text" name="address2" /><br/> 
              自我介绍： <textarea name="comment2" class="special"></textarea> <br/>
              单选：男<input type="radio" name="a" value="男" checked/> 
                 女<input type="radio" name="a" value="女"/><br/>
              <input type="submit" id="test2" value="提交" /> <br/>
        </form>

	jQuery代码:
	//提交按钮
 	$('#test').click(function(){
              var queryString = $('#myForm').formSerialize();
              alert(queryString);
              // 组装的数据可以用于 $.get, $.post, $.ajax ...
              $.post('demo.php', queryString ,function(data){
                  $('#output1').html("提交成功！欢迎下次再来！").show();      
              }); 
              return false;
         })
         
         //demo2
         $('#test2').click(function(){
              var queryString = $('#myForm2 *').fieldValue(); 
              alert(queryString);
              return false;
         })
         
         //重置表单
         $('#test3').click(function(){
             $('#myForm').resetForm();
             $('#myForm2').resetForm();
         })
          //清除表单
         $('#test4').click(function(){
             $('#myForm').clearForm();
             $('#myForm2').clearForm();
         })



	form插件的使用--ajaxForm()和ajaxSubmit()
	【ajaxForm()】以ajax发送form
	【ajaxSubmit())】以ajax得到数据
	options自定义对象参数
		【target】用服务器返回的数据 更新 id为output1的内容.
		【beforeSubmit】提交前
		【success】提交成功后 

		【url】默认是form的action，如果写的话，会覆盖from的action. 
		【type】默认是form的method，如果写的话，会覆盖from的method.('get' or 'post').
		【dataType】'xml', 'script', or 'json' (接受服务端返回的类型.) 
		【clearForm】成功提交后，清除所有的表单元素的值.
		【resetForm】成功提交后，重置所有的表单元素的值.
		【timeout】由于某种原因,提交陷入无限等待之中,timeout参数就是用来限制请求的时间
                    
                
          $(document).ready(function() { 
                var options = { 
                    target:        '#output1',   // 用服务器返回的数据 更新 id为output1的内容.
                    beforeSubmit:  showRequest,  // 提交前
                    success:       showResponse,  // 提交后 
                    //另外的一些属性: 
                    //url:       url         // 默认是form的action，如果写的话，会覆盖from的action. 
                    //type:      type        // 默认是form的method，如果写的话，会覆盖from的method.('get' or 'post').
                    //dataType:  null        // 'xml', 'script', or 'json' (接受服务端返回的类型.) 
                    //clearForm: true        // 成功提交后，清除所有的表单元素的值.
                    resetForm: true        // 成功提交后，重置所有的表单元素的值.
                    //由于某种原因,提交陷入无限等待之中,timeout参数就是用来限制请求的时间,
                    //当请求大于3秒后，跳出请求. 
                    //timeout:   3000 
                }; 
             
                //'ajaxForm' 方式的表单 .
                $('#myForm').ajaxForm(options);  
                //或者 'ajaxSubmit' 方式的提交.
                //$('#myForm').submit(function() { 
                //    $(this).ajaxSubmit(options); 
                //    return false; //来阻止浏览器提交.
                //}); 
            }); 

           // 提交前
          function showRequest(formData, jqForm, options) { 
             // formdata是数组对象,在这里，我们使用$.param()方法把他转化为字符串.
              var queryString = $.param(formData); //组装数据，插件会自动提交数据
              alert(queryString); //类似 ： name=1&add=2  
              return true; 
            } 

          //  提交后
        function showResponse(responseText, statusText)  { 
               alert('状态: ' + statusText + '\n 返回的内容是: \n' + responseText); 
         } 
	

	【formData】返回的是表单元素value的数组对象,使用for遍历得到索引值来操作
	【jqForm】 返回的是jquery对象,使用[0]或.get(0)转换原生DOM来直接操作
	【options】使用jQuery选择器获取元素,添加 fieldValu()获取所有value值进行操作



	→ form插件的使用--dataType的其他方式.
	DOM结构:
	<!-- demo1 json-->
        <h4>json方式返回</h4>
        <form id="myForm" action="json.php" method="post"> 
            名称： <input type="text" name="name" id="name" /> <br/>
        	地址： <input type="text" name="address" id="address"/><br/> 
            自我介绍： <textarea name="comment" id="comment" ></textarea> <br/>
            <input type="submit" id="test" value="json方式返回" /> <br/>
            <div id="jsonOut" ></div>
        </form>
         
        <!-- demo2 xml-->
        <h4>xml方式返回</h4>
        <form id="xmlForm" action="xml.php" method="post"> 
            名称： <input type="text" name="xmlname" id="xmlname" /> <br/>
        	地址： <input type="text" name="xmladdress" id="xmladdress"/><br/> 
            自我介绍： <textarea name="xmlcomment" id="xmlcomment" ></textarea> <br/>
            <input type="submit" id="xmltest" value="xml方式返回" /> <br/>
            <div id="xmlOut" ></div>
        </form>

        <!-- demo3 html-->
        <h4>html方式返回</h4>
        <form id="htmlForm" action="html.php" method="post"> 
            名称： <input type="text" name="htmlname" id="htmlname" /> <br/>
        	地址： <input type="text" name="htmladdress" id="htmladdress"/><br/> 
            自我介绍： <textarea name="htmlcomment" id="htmlcomment" ></textarea> <br/>
            <input type="submit" id="htmltest" value="html方式返回" /> <br/>
            <div id="htmlOut" ></div>
        </form>
	jQuery代码:
             // json
                    $(document).ready(function() { 
                        $('#myForm').ajaxForm({ 
                            // 声明 服务器返回数据的类型.
                            dataType:  'json', 
                            success:   processJson 
                        }); 
                    });
                    function processJson(data) { 
                            // 'data'是一个json对象，从服务器返回的.
                            $('#jsonOut').html(data.name +  "   "+data.address + "  "+data.comment); 
                    }
            // xml 
                $(document).ready(function() { 
                    $('#xmlForm').ajaxForm({ 
                        // 声明 服务器返回数据的类型.
                        dataType:  'xml', 
                        success:   processXml 
                    }); 
                }); 
                function processXml(responseXML) { 
                    // 'responseXML' 是一个XML的文档 ，从服务器返回的.
                    var name = $('name', responseXML).text(); 
                    var address = $('address', responseXML).text(); 
                    var comment = $('comment', responseXML).text(); 
                    $('#xmlOut').html(name +  "   "+address + "  "+comment); 
                }
            
            // html 
                $(document).ready(function() { 
                    $('#htmlForm').ajaxForm({ 
                        // 用服务器返回的数据 更新 id为 htmlcssrain 的内容.
                        target: '#htmlOut', 
                        success: function() { 
                            $('#htmlOut').fadeIn('slow'); 
                        } 
                    }); 
                });

// 【livequery】livequery插件 使动态添加元素事件能继承使用
	简单示例:
	DOM结构:
 	 <a href="#">被HTML页面中的a标签包裹</a>
  	   <button>修改rel属性的值</button>

	jQuery代码:
       	$('a').livequery('click', function(event) { 
            	alert('livequery导致的点击'); 
            	return false; 
        	}); 

      	$('a[rel*=friend]').livequery('click', function(event) { 
           	 alert('livequery匹配rel属性值中含有"friend"的A标签导致的点击'); 
            	return false; 
        });

      	$('a').click( function(){
        	alert('普通的点击'); 
        	return false; 
      	});
      
      	$(":button").click(function(){
        	$("#test").attr("rel","another");
      	});

      	
    });
	→※:注:如果livequert和on同样绑定事件,livequert优先级最高,如果body有触发的元素事件源,那么就会限制性livequery事件,再执行普通的事件,如果是之后动态添加的元素,原生事件就会不生效,而livequery会生效,这是它最大的优点.

	→ 添加hover的class切换
	jQuery代码;
    	$('li').livequery(function(){ 
            // 使用hover函数 绑定mouseover和mouseout事件
            $(this) 
                .hover(function() { 
                    $(this).addClass('hover'); 
                }, function() { 
                    $(this).removeClass('hover'); 
                }); 
     	}, function(){ 
        // 解除绑定mouseover和mouseout事件
        $(this) 
            .unbind('mouseover') 
            .unbind('mouseout'); 
    	}); 





7.3 模态窗口插件--Simple Modal 简单模型

7.3.1 SimpleModal是一个轻量级的jQuery插件，它为模态窗口的开发提供了一个强有力的接口，可以把它当作模态窗口的框架。SimpleModal非常的灵活，可以创建你能够想像到的任何东西，并且你还不需要考虑UI开发中的跨浏览器相关问题。
	Eric Martin设计了 SimpleModal插件，并一直在进行改善和维护。


7.3.2   下载地址
	jQuery SimpleModel插件的下载地址为：
	http://www.ericmrnartin.com/projects/simplernodal/
	在图7-11所示界面中，读者可以下载该插件、査看英文文档和版本

→【注:普通的动态添加元素,无法继承之前设置绑定事件,无论js还是jQuery,所有才要使用simple Mode,让动态添加的DOM结构也继承绑定事件】

	7.3.3快速上手
	SimpleModal提供了两种简单方法来调用模态窗口。
	第一种方法是作为一个链式的jQuery函数。你可以在一个用jQuery获取的元素上调用modal()函数，之后用这个元素的内容来显示一个模态窗口。比如-
	$("#element-id").model();

	第二种方法是作为一个单独函数使用。通过传递一个jQuery对象，DOM元素或纯文本（可以包含HTML来创建一个模态窗口。比如：
	$.modal('<div><h1>SimpleModel</h1></div>')
	以上的两种方法都可以接受一个可选参数,比如
	$('#element-id').modal({options});
	$.modal('<div><h1>SimpleModal</h1></div>',{options})
	因为SimpleModel不仅仅是一个模态窗口框架,
	
	因为SimpleModal不仅仅是一个模态窗口框架，以上的两个例子只是创建非常基本的没有样式模态窗口。你也可以通过外部CSS,选项对象或两个一起来应用样式。modal overlay、 container和data元素的CSS选项分别是：overlayCss、 containerCss和dataCss,它们都是键值对（Key/Value)属性。
	SimpleModal为显示一个模态窗口设置了必要的CSS，另外它动态地把模态窗口置于屏幕中间，除非预先使用了 position参数。
	SimpleModal在内部定义了如卜CSS类：simplemodal-overlay, simplemodal-container. simplemodal-wrap (如果内容比container大，那么它将自动设置overflow为auto)和simplemodal-datao
	SimpleModal的closeHTML参数默认声明一个用于关闭模态窗口的图片样式：modalcloseImg，
	因为它被定义在参数里面，不能通过参数来应用样式，所以一个外部css定义是必须的。
	
	#simplemodal-container a.modalCloseIng {
		width: 25px;
		height: 29px;
		display:inherit;
		z-index:3200;
		position: absolute;
		top:-15px;
		right:-18px;
		cursor:pointer;
	}

	如果IE6你也想用PNG图片的话，你可能要这么做-
	<!-[if It IE 7]>
	<sty1e type-'text/ess'>
		$simplemodal-container a.modalCloseIng{
		background:nome;
		right:-14px;
		width:22px;
		height:26px;
		fllter:progid DXImageTransform.Microsoft.AlphaImageLoabr(
		
		src='img/x.png',sizingMethod='scale
		)
	}
	</style>
	<![endif]-->

	7.3.4   关闭模态窗口
	SimpleModal自动为模态窗口内class是"simplemodal-close"的元素绑定了关闭函数。所以只要在HTML中添加如下代码就可以关闭窗口

	<button type- button  class- simplemodal-close >关闭</button>
	或者
	<a href="#" class-simplemodal-close">关闭</a>


	此外，你也可以通过调用$.modal.close()的方式关闭当前打幵的模态窗口。
	如果你不想使用"simplemodal-close"作为默认的关闭接口，而是想自己定义，那么你可以修
	改全局参数，代码如下：
	$.modal.defaults.closeClass = "modalClose"：

	以上代码将会为class为"xnodalClose"绑定关闭函数。
	如果要修改多个默认参数，可以使用如下代码-

	$.extend($.modal.defaults. {
		closeClass: "modalClose".
		closeHTML: "<a href='#'>Close</a>"
	})


	7.3.5   实际应用
	接下来我们使用SimpleModal来制作模态提示框和模态的iframe。
	首先我们在页而中插入将要弹出的内容，并把样式设置好-

	<div id="basic-dialog-warn">
	<！—普通弹出层[[-->
	  <div class="box-tit1e show"><j2>提示</h2></div>
		<div class-"box-main">
			<div class="tips"> 
				<span class- tips-ico >
				    <span class="ico-warn"><!--图标--></span>
				</span>
				<div-class="tips-content">
					<div class="tips-title">系统繁忙，请稍候重试</div>
					<div c1ass="t1ps-l1ne"></div>
				<div>
	     			<div class="box-buttons><button type="button" class="simplemodal-close">关闭</button></div>
	       		</div>
		<!-- 普通弹出层]]-- >
		</div>

	然后我们就可以利用下面的代码调用SimpleModah
	$('#basic-dia1og-warn').modal();

	同样，如果要弹出一个iframe页面，那么使用方式也类似。
	首先还是在页面中新建一段HTML代码，代码如下-

	<div id-"ifr-dialog" >
	<！-- iframe弹出层[[-->
	<iframe frameborder="O" scrolling="no" id="ifr-dialog-container" src="javascript:;' class="box-iframe"></iframe>
	<!--iframe弹出层]]-->
	</div>

	此时iframe的src是没有指向地址，我们可以在调用SimpleModal的时候，给它赋一个值，代
码如下：
	$("#1fr-dialog-container".attr("src","http//www.baidu.com");
	$("#1fr-dialog').moda1({
		"opacity":30,
		"overlayClose":true,
		"containerId":"ifr-dialog-content"
	})

	这样，我们就能把iframe页面以模态窗口的方式显示出来了。在以上代码中，在调用SimpleModal时，设置了 3个参数。"opacity"是用来设置遮罩层的不透明度的。
	"overlayClose"设置为true,代表着单击遮罩层也能关闭模态窗口。 
	"containerId"是一个非常有用的参数，它用来设置模态窗口容器的ID (默认值为simplemodal-container),通过这个钩子，我们能为容器定义各种规则。比如本例中，容器的ID被设置为ifr-dialog-content，在CSS样式中，为它设置的
	样式如下：
	#ifr-dialog-content{
		height:300px;
		width:700px;
	}

	7.3.6 API
	SimpleModal插件的官方API地址为：
	http://www.ericmmartin.com/projects/simplemodal/
	关于SimpleModal插件的API内容，读者可以参考附录F的介绍。
===================================
使用SimpleModal,必须head添加以下脚本和样式
	 <link rel="stylesheet" href="css/simplemodal.css" type="text/css" media="screen" title="no title" charset="utf-8">
	<script src="js/mootools-core-1.3.1.js" type="text/javascript" charset="utf-8"></script>
   	 <!-- 加载图片，点击左右切换 -->
    	<script src="js/mootools-more-1.3.1.1.js" type="text/javascript" charset="utf-8"></script>
	<script src="js/simple-modal.js" type="text/javascript" charset="utf-8"></script>

	去根据【demo.js】设置效果,样式自己调整
	示范:
	 $('box').addEvent('click',function(e){
        	e.stop();
        	var SM = new SimpleModal({'btn_ok':'关闭'});
            	SM.show({
              	'title' : '这是自定义头部',
              	'contents' : '这是弹框'
            })
     	})

【cookie插件】
	只能在firefix火狐使用,chrome不支持
	
	刷新记住用户名
	【DOM结构】:
	用户名：<input type="text" name="username" id="username"/> <br/>
       <input type="checkbox" name="check" id="check"/>记住用户名
	【jQuery代码】
 	$(function() {
                var userVal = 'username';
                if( $.cookie(userVal) ){
                    $("#username").val(  $.cookie(userVal) );
                }
                $("#check").click(function(){
                    if(this.checked){
                        $.cookie(userVal, $("#username").val() , { path: '/', expires: 10 });
                    }else{
                        $.cookie(userVal, null, { path: '/' });
                    }
                });
            });

	【DOM结构】:
   	 <p>
       	 	<a href="#">设置 cookie (设置有效期天数为 10 天)</a><br>
        	<a href="#">设置 cookie (通过 date 对象设置过期日期为 3 天后的那天)</a><br>
        	<a href="#">获取 cookie</a><br>
        	<a href="#">删除 cookie</a><br>
        	<a href="#">设置另一个 cookie</a><br>
        	<a href="#">获取另一个 cookie</a><br>
        	<a href="#">删除另一个 cookie</a>
    	</p>
	【jQuery代码】
    	$(function() {
            var valSave = 'test_cookie';
            var add_valSave = 'additional';
            $('a').eq(0).click(function() { // 用天数设置 cookie
                $.cookie(valSave, 'test', { path: '/', expires: 10 });
                return false;
            });
            $('a').eq(1).click(function() { // 用日期设置 cookie
                var date = new Date();
                date.setTime(date.getTime() + (3 * 24 * 60 * 60 * 1000));
                $.cookie(valSave, 'test', { path: '/', expires: date });
                return false;
            });
            $('a').eq(2).click(function() { // 获取 cookie
                alert($.cookie(valSave));
                return false;
            });
            $('a').eq(3).click(function() { // 删除 cookie
                $.cookie(valSave, null, { path: '/' });
                return false;
            });
            $('a').eq(4).click(function() { // 设置第二个 cookie
                $.cookie(add_valSave, 'foo', { expires: 10 });
                return false;
            });
            $('a').eq(5).click(function() { // 获取第二个 cookie
                alert($.cookie(add_valSave));
                return false;
            });
            $('a').eq(6).click(function() { // 删除第二个 cookie
                $.cookie(add_valSave, null);
                return false;
            });	



7.4.4 API
	写入Cookie
	【$.cookie('the_cookie','the_value');】
	说明："the_cookie"为待写入的Cookie名，"the—value"为待写入的值。
	 读取Cookie。
	【$.cookie('the.cookie')】
	说明："the一cookie"为待读取的Cookie名
	删除Cookie 。
	【$.cookie('the.cookie',null);】
	说明："the_cookie"为Cookie名，设置为null即删除此Cookie。必须使用与之前设置时相同的路径(path)和域名(domain),才可以正确删除Cookie"
^    其他可选参数。
	$.cookie('the_cookie',''the_value',{
		expires :7,
		path : '/',
		domain : 'jquery.com',
		secure :true
	})

	说明： expires: (Number|Date)有效期.可以设置一个整数作为有效期（单位：天），也可以直接设置一个日期对象作为Cookie的过期日期•如果指定日期为负数，例如已经过去的日子，那么此Cookie将被删除；如果不设置或者设置为null，那么此Cookie将被当作Session Cookie处理，并且在浏览器关闭后删除•
	【path】 : (String) cookie的路径属性.默认是创建该Cookie的页面路径。
	【domain】: (String) cookie的域名属性。默认是创建该Cookie的页面域名.
	【secure】: (Boolean )如果设为true,那么此Cookie的传输会要求一个安全协议例如HTTPS.

===========================
7.5 jQuery UI插件
	jQuery UI (http://ui.jquery.com)源自—个jQuery插件-Interface, Interface插件是由Stefan
	Petre创建的，Paul Bakaus也为该插件的幵发做出了重大贡献。Interface插件最早版本为1.2,只支持jQuery 1.1.2的版本，后来Paul Bakaus等人领导下，将Interface的大部分代码基于jQuery 1.2的API进行重构，并统一了 API。由于改进重大，因此版本号不是1.3而是直接跳到了 1.5，并且改名为jQueryUI,同时也确立 jQuery UI官方插件的地位，并逐步走向完善。由于jQueiy本身内核的逐渐完善，因此iQueryUI很有可能是jQueiy今后发展的重点，也预示着jQuery未来的走向。


	jQuery UI主要分为3个部分，交互、微件和效果库-
	交互。这里都是一些与鼠标交互相关的内容。包括拖动（Draggable )、置放（Droppable )、缩放（Resizable )、选择（Selectable)和排序（Sorlable )等。微件（Widget)中有部分是基于这些交互组件来制作的。此库需要一个jQueiy UI核心库——ui.core.js支持。
	 微件。这里主要是一些界面的扩展。里边包括了手风琴导航（Accordion)、自动完成(Autocomplete),取色器（Colorpicker )、对话框(Dialog),滑块（Slider),标签(Tabs),日历(Datepicker)、放大镜（Magnifier )、进度条（Progressbar )和微调控制器（Spinner )等。在将来jQuery1.7中还会有历史(History)、布局（Layout )、栅格（Grid )和菜单（Menu )等。此外，工具栏（Toolbar)和上传组件（Uploader)也正在讨论中。此库需要一个jQuery UI核心库ui.core.js的支持。
	效果库。此库用于提供丰富的动画效果，让动画不再局限于animate()方法。效果库有自己的一套核心即effects.core.js，无需jQuery UI的核心库ui.core.js支持。

7.5.2下载地址
	jQuery UI插件的下载地址为：
	http://ui.jquery.com/downloado
	在图7-17所示界面中，读者可以下载该插件。单击右上角区域的"build custom download"链接，
	可以直接下载完整套件，包括源码、发行版和测试驱动等。
	或者直接访问网址：
	http://jqueryui.com/download
	如图7-18所示页面，可以挑选需要的组件，在右側选择jQuery UI的版本等，然后单击左侧的"Download"按钮便可下载。


7.5.3快速上手
	jQuery UI插件的大部分API已经统一了 。以Draggables为例，有4个基本的API。
	[拖拽插件]
	→【注:jQueryUI-sortable 只有jquery-1.8以下版本能用】亲测jquery-1.7.2可用.1.8不能用
	ui.core.js ==>  jQuery UI 1.6rc6
	ui.sortable.js ==> jQuery UI Sortable 1.6rc6

	使用方法:
		$("UL的ID").sortable(); //直接让myList下的元素可以拖动排序


	【draggable(options)】:这是用来让一个DOM对象变成可拖动的对象的方法。其中的options可以设置各种不同的参数。
		drag拖拽
		gable两端
	【draggable("disable")】:让对应的DOM对象暂时禁用拖动。
	【draggable("enable")】:让对应的DOM对象重新启用拖动。
	【draggable("destroy")】:彻底移除拖动功能。
以上这些就是jQuery UI中大部分插件通用的用法。jQueiy UI插件系列众多，鉴于文章篇幅有限，这里只挑选出其中一个实用的拖动排序组件Sortable来进行简单介绍和讲解，
其他组件读者可以自行参考jQuery UI的官方网站。


	图7-19是某个网站右侧的一些条目，这些条目允许用户更改它们的
顺序，即个性化。利用jQueiyUI中的Sortable插件，可以容易地实现这本
来很复杂的一系列操作。

	首先构建一个简单的HTML结构并且引入Sortable库，以及其依赖的ui.core.js,完整程序代码如下-

	运行上面的代妈，列表元素就可以拖动排序了
	上面的代码中，引入的脚本都是sortable插件所必需的，没有引用多余的脚本，如果你对ui插件的依赖关系不是太了解，并对脚本的大小不是太关注的话，那么可以使用jQuery UI提供的custom包，它包含了 jQuery UI的所有扩展，是一个通用包。

7.5.4与单击專件冲突
	在某些特殊情况下会因为拖动事件抢在单击事件之前而导致单击事件失效。如果出现这种情况，可以设置参数delay延时1毫秒，即改为：
	$("#myList').sortab1e({delay:l});
	7.5.5   与后台结合
	如果要把Sortable插件与后台结合，需要完成两件事情，
		首先是査找触发排序后的回调函数，
		然后取得排列的顺序并通过Ajax发送给后台。
	首先解决回调函数。通过查找API,知道最符合要求的回调函数是stop,因此把前面的jQuery代码修改为:
	$("#myList").sortable({
		delay:1,	//修复潜在链接点击问题
		stop:function() {
			alert('触发排序停止后回调函数);
		}
	});

	接下来就需要得到列表元素拖动后的顺序，可以通过【sortable('serialize')】方法直接获取元素排列的顺序。但是排列要求id符合特定的命名规范，虽然可以自定义规则，但为了简化起见，这里还是将id修改为"name—value"的形式。例如，这里的<li>都改成如下代码：


	然后，使用$('#myList').sortabIe('serialize')方法就能得到以下形式的数据：
	【myLIst[]=mood&myList[]=share&myL1st[]=photo&myList[]=blog&myLlst[]=vote&myLlst[]=group】

	最后，可以利用Ajax方法把这组数据传递到后台，后台得到一个名为myList的数组。这里使用POST方式把数据提交给后台，代码如下：
			$.post(
				"sortable.php",
				$('#myList').sortable('serialize'),
					function(response) {
						alert(response);
					}
				);
			}
	正确发送请求后，sortable.php就可以获取相应的顺序，并且写入数据库，以便保存用户的个性化数据。在这里并不讨论后台如何保，因为这已经超出了本书介绍的范围。因此在这里的后台程序中只是简单处理一下获取的数组，并且按顺序将它们返回给前台，以表示后台已成功接受到数据并返回。代码如下-
	列表排序:
	【CSS样式】
	#myList{
		width: 80px;
		background: #EEE;
		padding: 5px;
		list-style: none;
	}
	#myList a{
		text-decoration: none;
		color: #0077B0;
	}
	#myList a:hover{
		text-decoration: underline;
	}
	#myList .qlink{
		font-size: 12px;
		color: #666;
		margin-left: 10px;
	}
	【DOM结构】
	<ul id="myList">
		<li id="myList_mood"><a href="#">心情</a></li>
		<li id="myList_photo">
			<a href="#">相册</a>
			<a href="#" class="qlink">上传</a>
		</li>
		<li id="myList_blog">
			<a href="#">日志</a>
			<a href="#" class="qlink">发表</a>
		</li>
		<li id="myList_vote"><a href="#">投票</a></li>
		<li id="myList_share"><a href="#">分享</a></li>
		<li id="myList_group"><a href="#">群组</a></li>
	</ul>
	</ul>
	
	【jQuery代码】
	  $(document).ready(function(){
			$("#myList").sortable({
				delay:1,	//修复潜在链接点击问题
				stop:function() {
					$.post(
						"sortable.php",
						$('#myList').sortable('serialize'),
						function(response) {
							alert(response);
						}
					);
				}
			});
		});
	delay延迟
	【php代码】
	<?php
		$myList = $_POST["myList"];
		foreach( $myList as $list){
		echo $list."\n";
		}
	?>

	必须在服务器打开,否则无法传入后台

返回结果:
	<br /><b>Warning</b>:  Unknown: failed to open stream: No such file or directory in <b>Unknown</b> on line <b>0</b><br /><br /><b>Fatal error</b>:  Unknown: Failed opening required 'C:/xampp/htdocs/test/第七章例子/7-4-jQueryUI-sortable/sortable.php' (include_path='C:\xampp\php\PEAR') in <b>Unknown</b> on line <b>0</b><br />
===========================================================
编写jQuery插件

	在前面几个章节中，已经介绍了 jQuery的大部分的基本应用，同时也看到了一些不错的插件。
这一节将介绍如何编写一个插件。

7.6.1插件的种类
	编写插件的目的是给已经有的一系列方法或函数做-个封装，以便在其他地方重复使用，方便后期维护和提高开发效率。
	jQuery的插件主要分为3种类型。
	封装，以便在其他地方重复使用，方便

1.【封装对象方法的插件】
	这种插件是将对象方法封装起来，用于对通过选择器获取的jQuery对象进行操作,是最常见的一种插件。
	
	据不完全统计，95%以上的jQuery插件都是封装对象方法的插件。此类插件可以发挥出jQuery选择器的强大优势。有相当一部分jQuery的方法，都是在jQuery脚本库内部通过这种形式"插"在内核上的，例如parent()方法、appendTo()方法和addClass()方法等不少DOM操作方法。
	有不少用户对jQuery没有提供color()方法而表示遗憾，不得不用css("color")来代替。在后面的例子中将会讲解如何编写一个colorQ方法的jQuery插件

2.【封装全局函数的插件】
	可以将独立的函数加到jQuery命名空间之下。例如第1章提到的解决冲突用的jQuery.
	noConflict()方法、常用的jQuery.ajax()方法以及去除首位空格的jQueiy,trim()方法等，都是jQuery内部作为全局函数的插件附加到内核上去的。

3.【选择器的插件】
	个别情况下，会需要用到选择器插件。虽然jQuery的选择器十分强大，但还是会需要扩充一些自己喜欢的选择器，例如用：color(red)来选择所有红色字的元素之类的想法。

7.6.2插件的基本要点
	jQuery插件的文件名推荐命名为jquery.[插件名]js，以免和其他JavaScript库插件混淆
	例如命名为jquery.color.js,


    所有的对象方法都应当附加到jQuery.ft对象上，而所有的全局函数都应当附加到jQuery对象本身上。
    在插件内部，this指向的是当前通过选择器获取的jQuery对象，而不像一般的方法那样，例如click()方法，内部的this指向的是DOM元素。
    可以通过this.each来遍历所有元素。
	所有的方法或函数插件，都应当以分号结尾，否则压缩的时候可能出现问题。为了更稳妥些，甚至可以在插件头部先加上一个分号，以免他人的不规范代码给插件带来影响。具体方法可以参考后面的代码。
	插件应该返回一个jQuery对象，以保"ii插件的可链式操作。除非插件需要返回的是一些需要获取的量，例如字符串或者数组等。
	避免在插件内部使用$作为jQuery对象的别名，而应使用完整的jQuery来表示。这样可以避免沖突。当然，也可以利用闭包这种技巧来回避这个问题，使插件内部继续使用$作为jQuery的别名。很多插件都是这么做的，本书也会利用这种形式。

	7.6.3   插件中的闭包
关于闭包，ECMAScript对其进行了简单的描述：允许使用内部函数（即函数定义和函数表达式位于另一个函数的函数体内），而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数，当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。即内部函数会在外部函数返回后被执行。而当这个内部函数执行时，它仍然必须访问其外部函数的局部变量、参数以及其他内部函数。这些局部变量、参数和函数声明（最初时）的值是外部函数返回时的值，但也会受到内部函数的影响。
	利用闭包的特性，既可以避免内部临时变量影响全局空间，又可以在插件内部继续使用$作为jOuerv的别名。常见的iQuery插件都是以下这种形式的：
	(function(){
	/*这里置放代码*/
	})();

	//注意为了更好的兼容性，开始前有个分号
	;(function($){ //此处将$作为匿名函数的形参|
	/*这里置放代码，可以使用$作为jQuery的缩写»
	))(iQuery): 这里就将jQuery作为实参传递给匿名函数了

	上段代码是一种常见的jQuery插件的结构。

	接下来看下面这段jQuery代码-
	;(function($) {
		//这里编写插件的代码，可以继续使用$作为jQuery的别名
		//定义一个局部变置foo，仅函数内部可以访问，外部无法访问
		var foo;
		var bar=function(){
		/*
			在匿名函数内部的函数都可以访问foo，即便是在匿名函数的外部调用bar()的时候，也可以在bar()的内部访问到foo，但在匿名函数的外部直接访问foo是做不到的
		}
		/*
		下面的语句让匿名函数内部的函数bar()逃逸到全局可访问的范围内
		这样就可以在匿名函数的外部通过调用jQuery.BAR()来访问内部定义的函数bar(),并且内部函数bar()也能访问匿名函数内的变量foo
		*/
		$.BAR = bar;
	})(jQuery);

	里只是简单地介绍了闭包的概念，显然闭包不是几句话就能讲清楚的。但对于插件的制作来说读者只需要知道所有的插件代码必须放置在下面这两句代码内就可以了。
	;(function($) {
		//此处编写jQuery插件代码
	})(jQuery);
如果需要获取更多关于闭包的知识，读者可以自行査阅相关资料。


7.6.4  jQuery插件的机制
	jQuery提供了两个用于扩展jQuery功能的方法，即jQuery.fii.extendO方法和jQueiy.extendO方法。
	前者用于扩展之前提到的3种类型插件中的第1种，后者用于扩展后两种插件。这两个方法都接受—个参数，类型为0bject。 Object对象的"名/值对"分别代表"函数或方法名/函数主体"。具体内容将会在下面讲解。
	jQuery.extendO方法除了可以用于扩展jQuery对象之外，还有一个很强大的功能，就是用于扩展已有的Object对象。
jQuery代码如下-
	jQuery. extend(target,objl.......[objN])

	用一个或多个其他对象来扩展一个对象，然后返回被扩展的对象。
	例如合并settings对象和options对象，修改并返回settings对象。

	var settings = { validate: false, limit: 5, name: "Mfoo" };
	var options = { validate: true, name: "bar" };
	var newOptions = jQuery.extend(settings, options);
	结果为:
	Object {validate: true, limit: 5, name: "bar"}

	jQueiy.extendO方法经常被用于设置插件方法的一系列默认参数，如下面的代码所示
        function foo(options){
            options = $.extend({
            name:"bar",
            length:5,
            dataType:"xmV"
            },options);
        }


	如果用户调用foo()方法的时候，在传递的参数options对象中设置了相应的值，那么就使用设置的值，否则使用默认值。代码如下-
    foo({
        name : "aH",
        length : "4",
        dataType : "json"
    })
    foo({ name : "a" , length : "4" });
    foo({ name : "a" });
    foo();

通过使用jQuery.extend()方法，可以很方便地用传入的参数来覆盖默认值。此时，对方法的调用依旧保持一致'只不过要传入的是一个映射而不是一个参数列表。这种机制比传统的每个参数都去检测的方式不仅灵活而且更简洁。此外，使用命名参数意味着再添加新选项也不会影响过去编写的代码，从而使开发者使用起来更加直观明了。


7.6.5   编写jQuery插件
	1.封装jQuery对象方法的插件
	  编写设置和获取颜色的插件。
	首先介绍如何编写一个color插件。该插件用于实现以下两个功能。


	(1) 设置匹配元素的颜色。
	(2) 获取匹配的元素(元素集合中的第1个)的颜色。
	首先将该插件按规范命名为jquery.color.js。然后在JavaScript文件里搭好框架，代码如下-

	;(function($) {
		〃这里写插件代码
	})(jQuery);

	由于是对jQuery对象的方法扩展，因此采用扩展第1类插件的方法jQuery.fii.extendO来编写,
	代码如下：
	
	;(function($) {
		$.fn.extend({
		"color":function(value){
		//这里写插件代码
		}
	});
	})(jQuery)

这里给这个方法提供一个参数value,如果调用方法的时候传递了 value这个参数，那么就是用这个值来设置字体颜色；否则就是获取匹配元素的字体颜色的值。
	首先实现第1个功能，设置字体的颜色。
	只需要简单地调用jQueiy	提供的css方法，直接写成this.css("color", value)即可。注意，插件内部的this指向的是jQuery对象，而非普通的DOM对象。接下来要注意的是，插件如果不需要返回字符串之类的特定值，应当使其具有可链接性。为此，直接返回这个this对象，由于.css()方法也会返回调用它的对象，即此处的this,因此可以将代码写成:

	;(function($){
		$.fn.extend({
		'color' : function(value){
			return this.css('color',value);	
		}
	   })	
	})(jQuery)
	
	接下来实现第2个功能。如果没有给方法传递参数，那么就是获取集合对象中第1个对象的color的值。由于cssO方法本身就具有返回第1个匹配元素的样式值的功能，因此此处无需通过eq()来获取第1个元素。只要将这两个功能结合起来,判断—下Value是否Undefmed
即可。

	此时colorO插件的功能已经全部实现了，通过该插件可以获取和设置兀素的color值。实际上，css()方法内部已经有判断value是否为undefined的机制，所以才可以根据传递参数的不同而返回不同的值。因此，可以借助cssO方法的这个特性来处理该问题。删除if()部分，最终剩余的代码实际上与先前那一段是一样的。jQuery代码如下： '

	;(function($) {
		$.fn.extend({
			"color"：function(value){
			if (value == undefined) {
				return this.ess("color");

			} else {
				return this.css("colop",value);
			}
		}
		})
	})(jQuery);

	此时colorO插件的功能已经全部实现了，通过该插件可以获取和设置元素的color值。实际上，css()方法内部已经有判断value是否为undefined的机制，所以才可以根据传递参数的不同而返回不同的值。因此，可以借助cssO方法的这个特性来处理该问题。删除if()部分，最终剩余的代码实际上与先前那一段是一样的。jQuery代码如下：

	另外，如果要定义一组插件，可以使用如下所示写法:
	;(function($){
		$.fn.extend({
		"color" : function(va1ue){
		//插件代码
		},
		"border"：function(va1ue){
		//插件代码
		},
		"background" : function(value){
		//插件代码
		}
	});
	})(jQuery):

	表达隔行变色插件:
	这里将第5章的表格隔行变色的代码制作成一个插件，以便于重复使用。表格隔行变色的
	jQuery代码如下：

	$("tbody>tr:odd").addClass("odd")：
	$("tbody>tr:even").addClass("even"):
	$('tbody>tr').c1ick(function() {
	//判断当前是否选中
		var hasSelected = $(this).hasClass('selected');
		〃如果选中,则移出selected类，否则就加上selected类
		$(this)[hasSelected ? "removeClass":" addClass"]('selected')
		査找内部的checkbox,设置对应属性
		.find(':checkbox';).attr('checked',！hasSelected);
	})
	
	如果复选框默认情况下是选择的，则高色
	$('tbody>tr:has(:checked)').addC1ass('selected');

	首先把插件方法取名为alterBgColor,然后为该插件方法搭好框架，jQuery代码如下:

	;(function($) {
		$.fn.extend({
			"alertBgColor" : function(options){
			//插件代码
			
		}
	  })
	})(jQuery);


	框架完成后，接下来就需要为options定义默认值。默认构建这样（{odd: "odd", even:" even",selected:"selected"})—个Object。这样就可以通过$("#sometable").alterBgColor({odd: "odd",even:"even"， selected:"selected"»自定义奇偶行的样式类名以及选中后的样式类名。同时，直接使用$("#somelable").alterBgColorO就可以应用默认的样式类名。

	jQuery代码如下:
	;(function($)(
		$.fn.extend({
			"alterBgColor":functlon(options){
				options-S.extend({
			odd:"odd",    /*偶数行样式*/
			even:"even,   /*奇数行样式*/
			selected:'selected", /*选中行样式
			},options);
		}
		})
		})(jQuery);

	如果在后面的程序中需要使用options对象中的属性，可以使用如下方式来获得:

	最后就是匹配元素的问题了。显然不能直接用$('tbodd>tr')选择表格行,这样会使页面中全部的<tr>元素都隔行变色。应该使用选择器选中某个表格，执行alterBgColorQ方法后，将对应的表格内<tr>元素进行隔行变色。因此，需要把所有通过$('tbody>lr')选择的对象改写成$('tbody>tr',this),表示在匹配的元素内（当前表格内）査找，并应用上一步中的默认值。jQuery代码如下：
	//表格tabody隔行变色插件
	//先选择table元素,再设置三个class,分别为odd,设置偶数行背景,even设置奇数行背景,selected点击选中class,设置背景和字体颜色
	;(function($) {
		$.fn.extend({
			bgTab : function(options){
				//设置默认值
				options = $.extend({
					odd : "odd",	/* 偶数行样式*/
					even : "even", /* 奇数行样式*/
					selected : "selected" /* 选中行样式*/ 
				},options);
				$("tbody > tr : odd",this).addClass(options.odd);
				$("tbody > tr : even",this).addClass(options.even);
				$('tbody > tr',this).click(function() {
					//判断当前是否选中
					var hasSelected = $(this).hasClass(options.selected);
					//如果选中，则移出selected类，否则就加上selected类
					$(this)[hasSelected ? "removeClass" : "addClass"](options.selected)
						//查找内部的checkbox,设置对应的属性。
						.find(':checkbox').attr('checked',!hasSelected);
				});
				// 如果单选框默认情况下是选择的，则高色.
				$('tbody>tr:has(:checked)',this).addClass(options.selected);
				return this;  //返回this，使方法可链。
			}
		});
	})(jQuery);
	在代码的最后，返回this,让这个插件具有可链性.
	此时，插件就完成了。现在来测试这个插件。构造两个表格，id分别为tablel和table2，然后使用其中一个<table>调用alterBsColor()方法，以便査看插件是否能独立工作，并且具有可链性。

	jQuery代码如下:
	$('#table2')
		.alterBgColor() //应用插件
		.find('th').css('color','red'); //可以链式操作
	从图7-25可以看到，第1个表格没有变化，第2个表格不仅隔行变色，同时表格头部的<th>标签的字体颜色变为红色。

	需要注意的是，jQuery的选择符可能会匹配1个或多个元素。因此，在编写插件时必须考虑到这些情况。可以在插件内部调用each()方法来遍历匹配元素，然后执行相应的方法，this会依次引用每个DOM元素。如下jQuery代码所示-

	;(funct1on($) {
		$.fn.extend({
		"somePlugin" : function(options){
			return this.each(functionO {
				//这里置放插件代码
			});
		 }
	 });
	})(jQuery);

	2.封装全局函数的描忤
	这类插件是在jQuery命名空间内部添加一个函数。这类插件很简单，只是普通的函数，没有特别需要注意的地方。
	例如新增两个函数，用于去除左侧和右侧的空格。虽然jQuery已经提供了 jQuery.trim()方法来去除两端空格，但在某些情况下，会只希望去除某一侧的空格。
	去除左侧、右侧的空格的函数分别写成如下jQuery代码

【】
































































【】
【jquery】【$】【$q】【jq】[jq][j][$]


[jq定时器]
	//设置定时器
       var interval;
        function run() {
              interval = setInterval(chat, "100");  //设定定时器，每隔100毫秒调用chat函数。
          }
        var i = 0;
           function chat() {
           	i++
               console.log(i);  //每隔一段时间要执行的代码
           }
	run();             //加载页面时启动定时器

     $(".mode").click(function(){  //元素点击时
         clearTimeout(interval);  //关闭定时器
     })





====================================================
【AngularJS】【angular】[angular][AngularJS]

	【View】==>【ViewMoudel】==>【Model】
		>== 【DOM Listeners】
		<== 【DateBindings】

	listeners倾听者
	bindings捆绑

	引入angular.js文件后会在全局下多了一个angular全局变量
	 	1.创建app模块(module) //app
	 	2.通过app创建控制器(controller),自定义指令(directive),服务(service,provider)


	在html标签内写【<html lang="en" ng-app>】
		ng-app指令(ng开头的都是内置的指令)指定了angular的作用范围

	【ng-init】初始化变量,字符串,数组,对象......
		{{}}表达四,计算表达式值,将计算的结果显示出来

	<div ng-init="name='姓名'">{{name}}</div>
	<div ng-init="arr=['第一个','第二个','第三个','第四个']">{{arr[3]}}</div>
	<div ng-init="obj={name : 'obj对象创建,对象使用'}">{{obj.name}}</div>
	<div ng-init="obj2={name : 'obj对象创建,数组使用'}">{{obj2["name"]}}</div>
	
	<div ng-init="obj3={age : 18}">{{obj3.age >= 16 ? '可以观看' : '不能观看'}}</div>
	
	<div ng-init="name='刘德华'" ng-bind="name">
		<span>刘青云</span>
		<span>黎明</span>
	</div>

	【ng-bind】将绑定的变量的值取出来,替换原来标签中的所有内容
	DOM结构:
	<div ng-init="name='刘德华'" ng-bind="name">
		<span>刘青云</span>
		<span>黎明</span>
	</div>

指令中的ng-model
	【ng-model】
	demo,双向绑定,输出input的值
	<input type="text" ng-model="name">
	<p>输入的name值：{{name}}</p>

	<!--练习: 创建两个input文本框, 一个输入价格, 一个输入数量, 创建一个p标签, 显示出总价-->
	<input type="text" ng-init="price=0" ng-model="price">
	<br>
	<input type="text" ng-init="count=0" ng-model="count">
	<p>{{price*count}}</p>


【index索引和判断】
	<!--将数组中的每个成员显示到一个li标签中-->
	<!--<li ng-repeat="item in arr">{{item}}</li>-->
	<!--<li ng-repeat="(item,index) in arr">{{index + " : " + item}}</li>-->
	<!--防止数组中出现重复的值-->
	<li ng-repeat="(index,item) in arr track by $index">{{index + " : " + item}}
	<span>{{item}}</span>
	<span>{{arr[$index]}}</span>
	<span>{{arr[index]}}</span>
	<span>{{$last}}</span>
	<span>{{$first}}</span>
	<span>{{$even}}</span>
	<span>{{$odd}}</span>
	</li>
	<!--<li>{{arr[0]}}</li>
	<li>{{arr[1]}}</li>
	<li>{{arr[2]}}</li>
	<li>{{arr[3]}}</li>
	<li>{{arr[4]}}</li>-->
</ul>
	输入结果result:
	0 : 1 1 1 1 false true true false
	1 : 2 2 2 2 false false false true
	2 : 3 3 3 3 false false true false
	3 : 4 4 4 4 false false false true
	4 : 5 5 5 5 false false true false
	5 : 5 5 5 5 true false false true

	demo演示2:
	DOM结构:
	<ul ng-init="obj={name: '张学友', height: 177, age: 54}">
    		<li ng-repeat="(attr, val) in obj">{{attr + ':' +val}}</li>
	</ul>
	→【注:如果ng-repeat内"(attr,val) in obj"括号有两个值,第一个指向对象属性名,第二个指向对象属性值】

	retult结果:
		name:张学友
		height:177
		age:54


指令中的ng-class
	【第一种】:设置单个元素样式
		【ng-init初始化】名称等于定义class名,然后设置class添加属性ng-init="name"
		注:这里name可自定义

	DOM结构:
		<div ng-init="name='sty2'" ng-class="name">设置这个div的class为sty2,背景为黄色</div>
	CSS样式:
        .sty1{
            background: red;
        }
        .sty2{
            background: yellow;
        }
        .sty3{
            font-size: 50px;
        }
        .sty4{
            color: #00B7FF;
        }

	【第二种】添加两个class类的样式切换
		这里【ng-init初始化】用变量保存flag标识符, 【ng-class】设置class为对象,保存判断true和false,符合每个条件进行操作,以下是后面加[false]默认选择了false,所以选择了第二个样式,一般是用来判断后再进行来回切换使用
	DOM结构:
	<!--两个样式之间切换-->
	<div ng-init="flag=true" ng-class="{true:'sty1',false:'sty2'}[flag]">两个样式之间切换</div>
	
	【第三种】在多个class类的切换
		和以上的原理完全相同,这次是在【ng-init初始化】定义多个标识符,并每个保存不同的class名,然后在设置class【ng-class】内添加,属性名添加class名,属性值添加定义的不同标识符后面的判断就好,如果改成true就执行这个样式,否则不执行
	→注:对象左侧如果不是有-分隔符的可以不加引号,但后面属性值必须添加引号

	DOM结构:	
	<!--多个样式之间切换-->
	<div ng-init="flag1=true; flag2=false; flag3=false; flag4=true"ng-class="{'sty1' : flag1,'sty2':flag2, 'sty3' : flag3,'sty4':flag4}">多个样式之间切换</div>


	<!--练习:创建一个按钮,点击按钮的时候将div的样式在style和style2之间切换(提示:点击按钮ng-click)-->
		<div ng-init="flag=false" ng-class="{true :'sty1',false : 'sty2'}"></div>
		<button ng-click="flag =! flag">按钮</button>


	【tab切换】
		→注:给【ng-init初始化】定义识别符等于以下内容要切换a标签内容,默认第一个首页要切换内容,
			设置class【ng-class】,设置对象,左面是要选中的class名,右侧是表达式,判断是否等于内容,
			最后在【ng-click】点击事件里添加【flag=切换文本内容】 就好了
	<!--多个样式之间切换-->
	<ul class="nav nav-tabs"  ng-init="flag = 'Home'">
		<li role="presentation" ng-class="{'active' : flag == 'Home'}" ng-click="flag = 'Home'">
			<a href="#">Home</a>
		</li>
		<li role="presentation" ng-class="{'active' : flag == 'Profile'}" ng-click="flag = 'Profile'">
			<a href="#">Profile</a>
		</li>
		<li role="presentation" ng-class="{'active' : flag == 'Messages'}" ng-click="flag = 'Messages'">
			<a href="#">Messages</a>
		</li>
	</ul>

指令的ng-hide,ng.hide和ng-if 显示和隐藏
	【ng-show="true/false"】
	【ng-hide="true/false"】
	【ng-if="true/false"】

	<div ng-show="true">ng-show显示</div>
	<div ng-show="false">ng-show不显示</div>

	<div ng-hide="true;">ng-hide不显示</div>
	<div ng-hide="false">ng-hide显示</div>
	
	<div ng-if="true;">ng-if显示</div>
	<div ng-if="false">ng-if不显示</div>

	demo练习:
	【切换class,和直接更改隔行变色】
		在父级,ul添加初始化【ng-init】并设置变量,保存数组,为之后动态生成内容
			→ng-init="phones=['小米','苹果','华为','小米','苹果']""phones=['小米','苹果','华为','小米','苹果']"
		第一种:切换class实现
			CSS样式:
			.bg1{
				background:red;
			 }
			 .bg2{
				background:yellow;
			 }
		使用方法: 
			1.在li添加设置【ng-class】={'bg1' : $even,'bg2' : $odd},因为索引是从0开始,所以先从偶数开始
			2.遍历数组,添加【ng-repeat】="i in phones track by $index", 循环遍历数组,后面track by $index是防止相同的出现
			3.在标签内添加{{i}}添加数组的内容,这里大括号里面的当前索引位置,可自定义
		第二种:使用true和false来实现
			1.在li添加设置【ng-class】={true : 'bg1','false' : 'bg2'}[$even],这里添加索引值$even,默认是从第一个开始
			之后相同
		第三种:使用三目表达式来实现
			1.在li添加设置【ng-class】=$even ? {background : 'red'} : {background : 'yellow'}"
				是否为偶数,是的话添加红色背景,否则黄色背景
			之后相同	

	※:前两种都是使用class切换,第三种是直接使用三目来设置样式,不用切换class.
		且只有【ng-class】判断条件更改,其他不变

	<div ng-init="sty={'font-size' : '50px',color:'blue',background : 'red'}" ng-style="sty">文字</div>
	<!--练习:实现隔行变色效果,遍历数组phones=['小米','苹果','华为','小米','苹果']-->
		<ul ng-init="phones=['小米','苹果','华为','小米','苹果']">
			<!--<li ng-class="{'bg1' : $even,'bg2' : $odd}" ng-repeat="phone in phones track by $index">{{phone}}</li>-->
		<!--	<li ng-class="{true : 'bg1','false' : 'bg2'}[$even]" ng-repeat="phone in phones track by $index">{{phone}}</li>-->
			<li ng-style="$even ? {background : 'red'} : {background : 'yellow'}" ng-repeat="phone in phones track by $index">{{phone}}</li>
		</ul>

	【过滤器】
		<!--货币过滤器-->
		<input type="text" ng-model="money"/><br>
		{{money | currency : 'RMB'}}<br>
		{{money | currency : 'YB'}}<br>
		<!--时间过滤器-->
		<h3>时间过滤器</h3>
		{{1492417280713 | date : 'yyyy-MM-dd HH:mm:ss'}}<br>
		{{1492417280713 | date : 'yyyy/MM/dd HH:mm:ss'}}<br>
		{{1492417280713 | date : 'HH:mm:ss'}}<br>
		<!--json过滤器-->
		<h3>json过滤器</h3>
		{{{'name': '张学友'} | json}}<br>
		<!--字符串大小写转换-->
		<h3>字符串大小写转换</h3>
		<input type="text" ng-model="str"/>
		<p>{{str | uppercase}}</p>
		<p>{{str | lowercase}}</p>
		<!--截取小数点位数-->
		<h3>截取小数点位数</h3>
		<input type="text" ng-model="num"/>
		<p>{{num | number : 3}}</p>
		
		<!--截取指定长度-->
		<h3>截取指定长度</h3>
		<input type="text" ng-model="inp"/>
		<p>{{inp | limitTo : 3}}</p>


	【orderBy】排序: orderBy,一般配合ng-repeat使用
		order命令
		
		1.父级定义数组变量,降序排序
		<ul ng-init="ary=[5,3,6,2,8,12,7]">
			<li ng-repeat="num in ary | orderBy : num">{{num}}</li>
		</ul>
			
		2.父级定义数组对象,降序排序,输出用【变量名+点+属性名】,或【变量名['属性名']】
			只要在【ng-repeat】的索引值 in persons 后面添加【| orderBy : age"】这样就好,按照属性名进行升序
		<h3>升序</h3>
		<ul class="list-group"  ng-init="persons = [{name : '姓名',age : 18},{name : '姓名',age : 15}]">
			<li class="list-group-item" ng-repeat="person in persons  | orderBy : age">
				<span>{{person.name}}</span>
				<span>{{person.age}}</span>
			</li>
		</ul>
		3..父级定义数组对象,升序排序,输出用【变量名+点+属性名】,或【变量名['属性名']】
			只要在【ng-repeat】的索引值 in persons 后面添加【| orderBy : age : 1"】这样就好,按照属性名进行降序
		<h3>降序</h3>
		<ul class="list-group"  ng-init="persons2 = [{name : '姓名',age : 18},{name : '姓名',age : 15}]">
			<li class="list-group-item" ng-repeat="person2 in persons2  | orderBy : age: 1 ">
				<span>{{person2.name}}</span>
				<span>{{person2.age}}</span>
			</li>
		</ul>

	【搜索关键字】
		1.在要搜索input里添加【ng-model="query"】 ←重要
		2.在ul初始化【ng-init】数组对象
		3.在li内【ng-repeat】自定义索引方式 in persons | orderBy : age : 1后面添加【| filter : query"】,配合排序和遍历,查找对应获取内容
		4.在li下的标签,输出数组对象的内容{{定义数组名.name}}

		DOM结构:
		search <input type="text" ng-model="query">
		<ul class="list-group"  ng-init="persons = [{name : 'chenchao',age : 18},{name : 'liudehua',age : 15},{name : 'wuyanxuan',age : 35},{name : 'wumengda',age : 60}]">
			<li class="list-group-item" ng-repeat="person in persons  | orderBy : age : 1 | filter : query">
				<span>{{person.name}}</span>
				<span>{{person.age}}</span>
			</li>
		</ul>

	→【demo点击表格年龄排序和搜索关键字】
	<br>
		请输入过滤条件: <input type="text" ng-model="query">
	<br>
	<br>
	<br>
	<table class="table table-bordered"
	       ng-init="persons=[{name:'张三', age:20, score: 80}, {name:'李四', age:30, score: 90}, {name:'王二麻子', age:20, score: 70}]; flag=false;">
	    <tr>
	        <td>序号</td>
	        <td>姓名</td>
	        <!--点击age这一列的时候, 首先将排序标志符flag置反, 然后将排序方式按照age进行排序-->
	        <td ng-click="flag=!flag; order='age'">年龄</td>
	        <td>分数</td>
	    </tr>
	    <!--切记如果想要在orderBy排序的同时使用track by, 需要将track by写在orderBy后面-->
	    <tr ng-repeat="person in persons|filter: query| orderBy: order: flag track by $index">
	        <!--序号列不参与过滤-->
	        <td>{{$index+1}}</td>
	        <td>{{person.name}}</td>
	        <td>{{person.age}}</td>
	        <td>{{person.score}}</td>
	    </tr>
	</table>

	orderBy命令
	module模块
	rootScope根处理
	scope处理
	controller管理者
	cancel取消


指令中的模板
	 module:创建模块,angular中的一切从模块开始
	 	参数一:模块的名字-->和ng-app指令对应的值相同的
	 	参数二:当前模块所依赖的其他模块,如果不依赖任何模块(空数组)
	 	
	 	参数二不传值,默认是获取该模块
	【run()】是获取根节点的模板,也就是设置在设置<html>标签下的ng-app下,进一步说就是在body里最上面
		【rootScope】 根 处理
		可以使用run获取到的回调函数的$rootScope服务添加内容
	DOM结构:
		{{height}}
		<div ng-controller="myCtrl">
			{{name}}
			{{age}}
			<div ng-controller="myCtrl2">
				{{name}}
				{{age}}
				{{test}}
			</div>
		</div>
	js代码:
	var app = angular.module('myApp',[]);
		app.run(function($rootScope){
			$rootScope.height = 183;
	})
	
	 	controller:创建控制器
	 		参数一:控制器的名字
	 		参数二:控制器对应的方法
	 		
	 	创建一个控制器,白送一个$scope,用来管理该控制下所有的数据
	 
	app.controller('myCtrl',function($scope){
		$scope.name = '陈超';
		$scope.age = 18;
		$scope.addr = '安徽';
	})
	app.controller('myCtrl2',function($scope){
		$scope.name = '张建';
		$scope.addr = '安徽';
		$scope.test = '测试';
	})
	
指令中的【$apply】应用,强制刷新页面
	angular定时器
	DOM结构:
	<div ng-controller="myCtrl" id="box">
			{{name}}
	</div>

	Angular代码:
	→方法一:使用强制刷新来触发定时器
	app.controller('myCtrl',function($scope){
		$scope.name = 0;
		
		setInterval(function(){
			$scope.name++;
			$scope.$apply(); //强制刷新页面
		},1000)
	})
	→方法二:使用【cancel(timer)】,到判断条件代码块中,取消定时器
	app.controller('myCtrl',function($scope,$interval){
		$scope.num = 0;
		var timer = $interval(function(){
			$scope.num++;
			if($scope.num >= 10){
				$interval.cancel(timer); //取消定时器
				return;
			}
		},1000);
	})

	→方法三:使用函数的递归来实现定时器,到一定范围,清除递归
	app.controller('myCtrl',function($scope,$interval,$timeout){
		$scope.num = -1;
		//timeout实现刚才$interval的功能
		function addNum(){
			$scope.num++;
			if($scope.num >= 10){
				return;
			}
			$timeout(addNum,1000);
		}
		addNum();
	})	

	→ 第四种 【$interval】 使用angular中提供的内置的服务
		  【$timeout】超时,停止定时器
	Angular代码:
   	app.controller('myCtrl', function ($scope, $interval, $timeout) {
        	$scope.num = 0;
		//$timeout实现刚才$interval的功能
        	function addNum(){
           	 $scope.num++;
           	 if ($scope.num >= 5){
           	     return;
           	 }
            		$timeout(addNum, 1000);
        	}
        	addNum();
   	 });
	原生js定时器:
	var i = 0;
		setInterval(fn,1000)
		function fn() {
			i++;
			box.innerHTML = '{{' + i + '}}';
		}


	


【数组求最大值】【数组最大值】【数组求最小值】【数组最小值】【数组排序】[数组求最大值][数组最大值][数组求最小值][数组最小值][数组排序]
	第一种:最简单 ←推荐
	var ary = [1,5,3,100,7,9,4];
	var max = Math.min.apply(null,ary);
	console.log(max);

	第二种:排他思想
	for(var j = 0; j < arr.length - 1; j++){
		for(var i = 0; i < arr.length - 1; i++){
			if(arr[i] > arr[i + 1]){
				//交换
			}
		}
	}

	第三种:使用数组内置sort方法,利用回调函数得到最大,最小值
	var ary = [1, 5, 3, 7, 9, 4];

    	ary.sort(function (a, b) {
        	return a-b;
    	});
    	console.log(ary[ary.length-1])

指令中的【$watch】
	watch监视

	Angular代码:
	app.controller('myCtrl',function($scope) {
		/*
			【$watch】: 检测数据的变量
			【newVal】: 变化后的新值 可自定义
			【oldVal】: 变化前的值 可自定义
		*/
		 $scope.$watch('val',function (newVal,oldVal) {
		 	console.log(newVal);
		 	console.log(oldVal);
		 })
	})	
	
	demo示范二:
		DOM结构:
		<div ng-controller="myCtrl">
			<div>书的名字:{{name}}</div>
			<div>书的价钱:{{price}}</div>
			<!--初始化: 10 满 100 的时候 邮费变成0-->
			<div>书的邮费:{{postage}}</div>
			<div>
				书的数量:{{quantity}}<br>
				<input type="text" ng-model="val" placeholder="请输入数量">
				
			</div>
			<div>
				总价:{{sum}}
			</div>
		</div>

	Angular代码:
	app.controller('myCtrl',function($scope) {
		$scope.name = 'javascript权威指南';
		$scope.price = 60;
		$scope.postage = 10;
	 $scope.$watch('val',function (newVal,oldVal) {
		 	if(newVal == undefined){
		 		newVal = 0;
		 	}
	 		$scope.quantity = newVal;
	 		$scope.sum = $scope.price * $scope.quantity < 100 ? $scope.price * $scope.quantity + $scope.postage : $scope.price * $scope.quantity;
//		 		console.log(newVal);
	 	})
	})

指令中的【ng-change】触发更改value事件
	和【ng-click】相同
	DOM结构:
	<div ng-controller="myCtrl">
		<input type="text" ng-model="val" ng-change="changeVal()" />
	</div>

	Angular代码:
	app.controller('myCtrl',function($scope) {
		/*
			【ng-change】: 当input框中值发生变化的时候触发该事件
		*/
		$scope.changeVal = function(){
			console.log($scope.val);
		}
	})

指令中的broadcast和on.html
	【broadcast()】广播
	【on()】接收
		broadcast广播
		emit发出

	DOM结构:
	<div ng-controller="myCtrl1">
		<button ng-click="broadcastVal()">点击</button>
		<div ng-controller="myCtrl2">
			{{name}}
			<div ng-controller="myCtrl2-1">{{name}}</div>
		</div>
		<div ng-controller="myCtrl3">{{name}}</div>
	</div>

	Angular代码:
	app.controller('myCtrl1',function($scope) {
			$scope.broadcastVal = function (){
			/*
			 	【$broadcast】:父控制器向子控制器广播事件,参数一是事件的名字,参数二传递的事件

			  */
			$scope.$broadcast('val','张建');
		}
	})
	app.controller('myCtrl2',function($scope) {
		//【$on】:监听事件,获取传递给来的数据
		$scope.$on('val',function(ev,data){
			console.log(data);
			$scope.name = data;
		})
	})
	app.controller('myCtrl2-1',function($scope) {
		//【$on】:监听事件,获取传递给来的数据
		$scope.$on('val',function(ev,data){
			console.log(data);
			$scope.name = data;
		})
	})
	app.controller('myCtrl3',function($scope) {
		//【$on】:监听事件,获取传递给来的数据
		$scope.$on('val',function(ev,data){
			console.log(data);
			$scope.name = data;
		})
	})


指令中的emit和on.html
	【emit()】发出
	DOM结构:
	<div ng-controller="myCtrl1">
	    {{name}}
	    <div ng-controller="myCtrl2">
	        <button ng-click="emitVal()">点击我</button>
	    </div>
	</div>

	Angular代码:
	    app.controller('myCtrl1', function ($scope) {
	        //【$on】：监听事件，获取传递给来的数据
	        $scope.$on('val', function (ev, data) {
	            $scope.name = data;
	        });
	    });
	    app.controller('myCtrl2', function ($scope) {
	        $scope.emitVal = function () {
	            //【$broadcast】: 子控制器向子父控制器广播事件，参数一也是事件的名字，参数二也是传递的数据
	            $scope.$emit('val', '张健');
	        }
	    });

指令中的事件广播和发射的练习
	DOM:
	<div ng-controller="myCtrlParent">
		<!--总价-->
		<input type="text" ng-model="total" ng-change="totolChange()"/>
		<div ng-controller="myCtrlChild">
			书的名字: <span>{{name}}</span><br />
			书的价格: <span>{{price}}</span><br> <!--10-->
			<!--数量-->
			书的个数: <input type="text" ng-model="count" ng-change="countChange()"> <!--10-->
		</div>
	</div>

	Angular代码:
	app.controller('myCtrlParent',function($scope) {
		$scope.totolChange = function(){
			$scope.$broadcast('total',parseFloat($scope.total));
		}
		$scope.$on('count',function (ev,data) {
			$scope.total = parseFloat(data);
		})
	})
	app.controller('myCtrlChild',function($scope) {
		$scope.name = '锋利的jQuery';
		$scope.price = 10;
		
		$scope.countChange = function(){
			$scope.$emit('count',(parseFloat($scope.count)) * (parseFloat($scope.price)));
		}
		//监听input的总价,然后更改个数的input值
		$scope.$on('total',function(ev,data){
			$scope.count = Math.floor(parseFloat(data) / parseFloat($scope.price));
	})

	兄弟元素广播:
	<div ng-controller="myCtrl">
		<div ng-controller="numParent">
			数量: <input type="text" ng-model="num" ng-change="numChange()"/>
		</div>
		<div ng-controller="sumParent">
			总价: <input type="text"  ng-model="sum" ng-change="sumChange()"/>
		</div>
	</div>

	Angular代码:
	app.controller('myCtrl',function($scope){
		var cmd = $scope;
			//总数接收并广播
			cmd.$on('sum',function(ev,data){
				cmd.$broadcast('numVal',Math.floor(data / 10));
			})
			//数量接收并广播
			cmd.$on('num',function(ev,data){
				cmd.$broadcast('sumVal',data * 10);
			})
	})
	app.controller('numParent',function($scope){
		var cmd = $scope;
		//当input改变就发送给父级div
		cmd.numChange = function(){
			cmd.$emit('sum',parseInt(cmd.num));
		}
		//获取总价的input值,因为已经在父级计算过转换数量,所以直接从爷爷级赋值给数量的input值就好
		cmd.$on('sumVal',function(ev,data){
			cmd.num = data;
		})
	})
	
	app.controller('sumParent',function($scope){
		var cmd = $scope;
		//当input改变就发送给父级div
		cmd.sumChange = function(ev,data){
			cmd.$emit('num',parseInt(cmd.sum));
		}
		//获取数量的input值,因为已经在父级计算过转换总价,所以直接从爷爷级赋值给总价的input值就好
		cmd.$on('numVal',function(ev,data){
			cmd.sum = data;
		})
	})

防止闪烁的三种方式
	【ng-bind】 直接设置变量名
	【ng-bind-template】{{属性名}}
	【ng-cload】在标签内填写{{变量名}}
	
	CSS样式:
	[ng-cloak]{
		display: none;
	}
	DOM结构:
	<div ng-controller="myCtrl">
		<!--防止闪烁的三种方式-->
		<div ng-bind = "name"></div>
		<div ng-bind-template = "{{name}}{{age}}"></div>
		<div ng-cload>
			{{name}}
			{{age}}
		</div>
	</div>

	Angular代码:
	app.controller('myCtrl',function($scope){
		$scope.name = '刘青云';
	})

	【ajax】
Angular指令中的$http服务
	DOM结构:
	<div ng-controller="myCtrl">
		<ul class="list-group-item" ng-repeat="obj in ary">
			<span>{{obj.name}}</span>
			<span>{{obj.age}}</span>
			<span>{{obj.addr}}</span>
		</ul>
	</div>
	Angular代码:
	app.controller('myCtrl',function($scope,$http){
		$http({
			type : 'get',
			url : 'js/1.json',
			async : true,0
			dataType : 'json',
			data : null
			/*
			 	data :向服务器请求回来的数据
			 	status : http状态码
			 	headers : 响应头信息(函数)
			 	config : 配置信息
			 	
			 */
		}).success(function(data,status,headers,config){
			$scope.ary = data;
			console.log(data);
		})
		
	})

指令中的jsonp跨域请求.html
    app.controller('myCtrl', function ($scope, $http) {
        $http.jsonp('http://suggestion.baidu.com/su?wd=a&cb=JSON_CALLBACK')
                .success(function (data, status, headers, config) {
                    $scope.ary = data.s;
                })
    });

	百度搜索,需jsonp跨域
	DOM结构:
	<div ng-controller="myCtrl">
		<div>
			百度一下,你就知道
			<input type="text" placeholder="请输入关键字" ng-change="onchange()" ng-model="val"/>
			
		</div>
	    <ul class="list-group">
	        <li class="list-group-item" ng-repeat="obj in ary">
	            {{obj}}
	        </li>
	    </ul>
	</div>

	Angular代码:
    	app.controller('myCtrl', function ($scope, $http) {
    		$scope.onchange = function () {
    			$http.jsonp('http://suggestion.baidu.com/su?wd=' + $scope.val + '&cb=JSON_CALLBACK')
               	 	.success(function (data, status, headers, config) {
                    	$scope.ary = data.s;
                	})
    		}
   	});

	原生js下载json数据
	同步和异步区别在于,同步 send发送状态,必须放在onreadystatechange对象之后才能生效

    var xhr = new XMLHttpRequest();//创建ajax对象

    //get post (head delete update options)
    //同步传输  
 	xhr.open('get', 'js/1.json', false);//发送ajax前的准备

	xhr.onreadystatechange = function () {
        if ((xhr.readyState == 4) && /^2\d{2}$/.test(xhr.status)){
            console.log(xhr.responseText);
        }
	}
    xhr.send(null);

   
    //异步传输    
 	xhr.open('get', 'js/1.json', true);//发送ajax前的准备
	xhr.send(null);
	xhr.onreadystatechange = function () {
        	if ((xhr.readyState == 4) && /^2\d{2}$/.test(xhr.status)){
            		console.log(xhr.responseText);
        	}
	}
	on:监听事件,获取传递给来的数据



→【Angular自定义指令】
	//创建使用驼峰命名法,调用时使用横杠分割法
	【directive】指令的创建
	【myDire】指令的名字


	<!--自定义指令-->
	<my-dire></my-dire>
		
	<!--指令作为类名使用-->

	<div class="my-dire"></div>

	/*
	 	directive:指令的创建
	 	myDire:指令的名字
	 */
	app.directive('myDire',function(){
		return { //配置指令的相关属性
			
			
		}
	})

→【Angular指令的模板】
/*
	 	directive:指令的创建
	 	myDire:指令的名字
	 */
	app.directive('myDire',function(){
		return { //配置指令的相关属性
			/*
			 tenplate:配置指令的模板信息,最终会用模板中的内容替换原来指令标签中的内容
			 */
			template : '<div>创建指令</div>'
		}
	})


→【Angular指令的使用范围】
	/*
	 	directive:指令的创建
	 	myDire:指令的名字
	 */
	app.directive('myDire',function(){
		return { //配置指令的相关属性
			/*
			 tenplate:配置指令的模板信息,最终会用模板中的内容替换原来指令标签中的内容
			 */
			template : '<div>创建指令</div>',
			/*
			 	E:element 元素
			 	C:class 类名
			 	M: comment 注释
			 	A: attribute 属性
			 */
			restrict : 'ECMA',
			//是否将最外的指令进行替换
			replace : true
		}
	})
	→※注:这里需要注意,如果模板是元素标签使用【template】,如果是外部文件,使用【templateUrl】,否则外部文件不生效.
共4种使用
	DOM结构:
	E第一种,作为元素标签使用:
		<!--自定义指令-->
		<my-dire></my-dire>
	C第二种,作为类名使用:
		<!--指令作为类名使用-->
		<div class="my-dire"></div>
	M第三种,作为注释名使用:
		<!--作为注释-->
		<!--属性名左侧可以加空格和换行,右面不可加空格.否则不生效-->
		<!--属性值左右都可加空格和换行-->
		<!--
			directive: my-dire 
		-->
	A第四种,作为属性使用:
		<!--作为属性出现-->
		<div my-dire></div>
		
		
	<!--作为属性出现-->
	<div my-dire></div>

	 tenplate:配置指令的模板信息,最终会用模板中的内容替换原来指令标签中的内容
	template : '<div>创建指令</div>',
	 	E:element 元素
	 	C:class 类名
	 	M: comment 注释
	 	A: attribute 属性
	 
	//restrict : 'ECMA',
	//是否将最外的指令进行替换
	//没写范围,默认是EA
	//replace : true


→【Angular link方法】
	【link:(callback)】可返回回调函数,来操作样式之类操作
	DOM结构:
		<div my-dire age="18" addr="安徽"></div>
	Angular代码:
	app.directive('myDire',function(){
		return { 
			template : '<div>{{content}}</div>',
			link : function (scope,ele,attrs) {
				scope.content = '这是内容设置';
				console.log(ele); //jQuery元素
				ele.css({
					color : "red",
					fontSize : "50px",
					background : 'blue'
				})
				console.log(attrs.age);
				console.log(attrs.addr);
			}
		}
	})

→【Angular装饰型指令】
	Angular拖拽
	DOM结构:
		<div my-drag></div>

	Angular代码:
	app.directive('myDrag', function() {
		return { //配置指令的相关属性
			template: '<div>{{content}}</div>',
			link: function(scope, ele, attrs) {
				scope.content = '来呀,拽我呀';
				ele.css({
					width: '100px',
					height: '100px',
					background: "red",
					position: 'absolute',
					left: 0,
					top: 0,
					cursor: "move",
				})
				ele.on("mousedown", function(e) {
					var disX = e.pageX - this.offsetLeft,
						disY = e.pageY - this.offsetTop;
		
					var minX = 0,
						maxX = (document.documentElement.clientWidth || document.body.clientWidth) - parseFloat(ele.css('width')),
						minY = 0,
						maxY = (document.documentElement.clientHeight || document.body.clientHeight) - parseFloat(ele.css('height'))
		
		/*			var minX = 0,
						maxX = (document.documentElement.clientWidth || document.body.clientWidth) - this.clientWidth,
						minY = 0,
						maxY = (document.documentElement.clientHeight || document.body.clientHeight) - this.clientHeight;*/
		
		/*			var minX = 0,
						maxX = (document.documentElement.clientWidth || document.body.clientWidth) - ele[0].clientWidth,
						minY = 0,
						maxY = (document.documentElement.clientHeight || document.body.clientHeight) - ele[0].clientHeight;*/
					angular.element(document).on('mousemove', function(e) {
					var changeX = e.pageX - disX,
						changeY = e.pageY - disY,
						changeX = ((changeX < minX) ? minX : (changeX > maxX ? maxX : changeX)),
						changeY = ((changeY < minY) ? minY : (changeY > maxY ? maxY : changeY));
						ele.css({
							left: changeX + 'px',
							top: changeY + 'px'
						});
					});
				
				});
				
				angular.element(document).on('mouseup', function(e) {
					angular.element(document).off("mousemove");
				})
			}
		}
	})
	
【获取body可视宽度】【获取可视宽度】【可视宽度】[获取body可视宽度][获取可视宽度][可视宽度]
	jQuery通过
		【$(document.documentElement.clientWidth)[0]】或【$(document.body.clientWidth).get(0)】来转换可视窗口获取高度
	※注:通过【document.documentElement.clientWidth】或【document.body.clientWidth】获取当前可视窗口宽度
	     通过【document.documentElement.clientWidth】或【document.body.clientWidth】获取当前可视窗口宽度
		client当事者

	获取当前元素的可视宽度/高度:
	第一种:
		用css的方法来获取【parseFloat(ele.css('width'))】或【parseFloat(ele.css('height'))】
	第二种:
		用this直接指向当前事件源【this.clientWidth】或【this.clientHeight】 ←最推荐
	第三种,
		转换成DOM再进行操作【ele[0].clientWidth】
	

→【Angular组件型指令】
	 指令的分类
		 1.装饰型指令
		 2.组件型指令
【模块.directive()】指针


示范一:
	DOM结构:
	<!--自定义指令-->
	<panel title="这是标题" content="这是内容"></panel>

	Angular代码:
	var app = angular.module('myApp',[]);
	app.directive('panel',function(){
		return {//配置指令的相关属性
		templateUrl : './views/template.html',
			link : function(scope,element,attrs){
				scope.title = attrs.title;
				scope.content = attrs.content;
			}
		}
	})

	templateUrl模板:
	<div class="panel panel-default">
		<div class="panel-heading">
			{{title}}
		</div>
		<div class="panel-body">
			{{content}}
		</div>
		
		</div>
	</div>

示范二:只正常显示内容1-4,不正常显示标题1到4
	【transclude】 true保留原来指令中的内容,也就是保留标签内属性,内容不更改
		在模板文件属性写【ng-transclude】来实现最终效果
	【ng-transelude】
	transclude : 不更改指令中的内容
		 配合transclude:true一起使用
		 	
		 自定义指令不会创建自己的作用域,使用的是父级的作用域
		 【ng-transclude】会创建自己的作用域
		也就是说不使用transclude,模板会优先覆盖指令,使用transclude,指令优先于模板而已

	DOM结构:
		<panel title="这是标题1">这是内容1</panel>
		<panel title="这是标题2">这是内容2</panel>
		<panel title="这是标题3">这是内容3</panel>
		<panel title="这是标题4">这是内容4</panel>
	Angular代码:
	app.directive('panel',function(){
		return {//配置指令的相关属性
		templateUrl : './views/template2.html',
		/*
		 	【transclude】 : true保留原来指令中的内容
		 	配合【ng-transelude】指令一起使用
		 	
		 	自定义指令不会创建自己的作用域,使用的是父级的作用域
		 	ng-transclude会创建自己的作用域
		  
		 */
		transclude : true,
			link : function(scope,element,attrs){
				scope.title = attrs.title;
				scope.content = attrs.content;
			}
		}
	})


【指令中父子作用域的分离】实例二改,正常显示标题1到4
	分离父子作用域的方式
		【scope】
			有两个参数
			true:不完全分离,但是仍然能够访问父作用域中的相关数据
		 	{} 完全分离,不能访问父作用域中的相关数据 ←常用这个


	DOM结构:
		<!--自定义指令-->
		<panel title="这是标题1">这是内容1</panel>
		<panel title="这是标题2">这是内容2</panel>
		<panel title="这是标题3">这是内容3</panel>
		<panel title="这是标题4">这是内容4</panel>

	Angular代码:
	var app = angular.module('myApp',[]);

	app.run(function ($rootScope) {
		$rootScope.name = '陈超';
	})
	app.directive('panel',function(){
		return {//配置指令的相关属性
		templateUrl : './views/template2.html',
		transclude : {},
		/*
		 	分离父子作用域的方式
		 		1:scope:true不完全分离,但是仍然能够访问父作用域中的相关数据
		 		2.scope:{} 完全分离,不能访问父作用域中的相关数据
		  
		 */
//			scope : true,
			scope : {},
			link : function(scope,element,attrs){
				scope.title = attrs.title;
			}
		}
	})


	模板:
	<div class="panel panel-default">
		<div class="panel-heading">{{title}}</div>
		<div class="panel-body" ng-transclude></div>
	</div>
	{{name}}


→【控制器和指令之间数据的传递】
	【title : '@title'】 //scope.title = attrs.title取的是一个常量字符串
	【title : '=title'】 //scope.title = attrs.title取的是一个变量字符串,如果和模板变量相同,可省略=后面变量


	DOM结构:
	<!--自定义指令-->
	<div ng-controller="myCtrl">
		<panel title="titleNew" click="click(info)">这是内容1</panel>
		<panel title="titleNew2" click="click(info)">这是内容1</panel>
	</div>

	Angular代码:
	var app = angular.module('myApp',[]);
	app.controller('myCtrl',function ($scope) {
		var cmd = $scope;
			cmd.titleNew = '这是新的标题1';
			cmd.titleNew2 = '这是新的标题2';
			cmd.click = function (info) {
				alert(info);
			}
	})

	app.directive('panel',function(){
		return {//配置指令的相关属性
		templateUrl : './views/template3.html',
		transclude : true,
//			scope : true,
			scope : {
				//title : '@title' //scope.title = attrs.title取的是一个常量字符串
				title : '=title', //scope.title = attrs.title取的是一个变量字符串,如果和模板变量相同,可省略=后面变量
				click : '&click'
			},
			link : function(scope,element,attrs){
				/*scope.title = attrs.title;
				scope.click = function () {
					alert(1)
				}	
				*/
			}
		}
	})

	模板文件:
	<div class="panel panel-default">
		<div class="panel-heading" ng-click="click({info : title})">{{title}}</div>
		<div class="panel-body" ng-transclude>/div>
	</div>


【angular中指令之间的数据传递】
	angular点击显示隐藏
	【title : '@'】 
		1.title里面是固定的中文时使用，如果是num这种变量才用【=】;
		2.如果title里面是{{num}},这时候使用@传变量。
		2种方法都行。

	DOM结构:
	<opener title="这是标题">这是内容</opener>
		opener开启者

	Angular代码:
	var app = angular.module('myApp',[]);
	app.directive("opener",function(){
		return {
			templateUrl : './views/opener.html',
			transclude : true,
			scope : {
				title : '@' //1.title里面是固定的中文时使用，如果是num这种变量才用=;2.如果title里面是{{num}},这时候使用@传变量。2种方法都行。
			},
			link : function(scope,ele,attrs){
				scope.flag = false;
				scope.btnClick = function(){
					scope.flag = ! scope.flag;
				}
			}
		}
	})

	模板:
	<div>
		<div ng-click="btnClick()" class="header">{{title}}</div>
		<div ng-show="flag" class="content" ng-transclude></div>
	</div>


【angular手风琴效果】
	【require:"^group"】^只用group方法,用组来使用
		require需求
		group组
	【groupController.addScope(scope);】将自己的scope交给group,
			groupController可自定义,在link回调函数的第四个形参内定义

		

	DOM结构:
		<group>
			<opener title="这是标题1">这是内容1</opener>
			<opener title="这是标题2">这是内容2</opener>
			<opener title="这是标题3">这是内容3</opener>
		</group>

	Angular代码:
	var app = angular.module('myApp',[]);
	app.directive('group',function(){
		return {
			//进行指令之间通信的
			controller : function () {
				var aryScope = [];
				//将所有子指令中的scope交给group统一管理
				this.addScope = function (scope) {
					aryScope.push(scope);
				}
				//除了当前scope其他的scope中的flag都要变成false
				this.changeValue = function (scope) {
					for (i in aryScope) {
						if(aryScope[i] != scope){
							aryScope[i].flag = false;
						}
					}
				}
			}
		}
	})
	app.directive("opener",function(){
		return {
			//只用group方法
			require:"^group",
			templateUrl : './views/opener.html',
			transclude : true,
			scope : {
				title : '@' //1.title里面是固定的中文时使用，如果是num这种变量才用=;2.如果title里面是{{num}},这时候使用@传变量。2种方法都行。
			},
			link : function(scope,ele,attrs,groupController){
				scope.flag = false;
				//将自己的scope交给group
				groupController.addScope(scope);
				
				scope.btnClick = function(){
					scope.flag = ! scope.flag;
					//将其他opener的flag置成false
					groupController.changeValue(scope);
				}
			}
			
		}

	模板:
	<div>
		<div ng-click="btnClick()" class="header">{{title}}</div>
		<div ng-show="flag" class="content" ng-transclude></div>
	</div>


	服务的创建
	【app.provi(function(){})】
	provider : 创建自定义服务
	 	参数一 : 服务的名字
	 	参数二 : 回调方法
	服务的配置
	【app.config(funtion(){})】
		con用
		fig无果	
	【服务创建】==>【共5种】
		最底层实现还是通过provider
	`	【provider】提供者
		【factory】工厂
			fact事实
		【service】服务
		【value】值
		【constant】持续的
		constant和value区别在于可以直接更改为自定义服务名

指令中的【ng-disabled】
		disabled无能力的
	//constant服务配置
	//服务的配置
	app.config(function(my){
		my.currency = '#';
		console.log(1);
	});
	app.run(function(){
 	    my.currency = '$';
		console.log(2);
	})
	→※注:config比run先执行


	<div ng-controller="myCtrl">
		<input type="button" ng-disabled="true" value="不能点击我"/>
		<input type="button" ng-disabled="false" value="能点击我"/>
	</div>


【服务】
	【模块.provider(服务,callback)】
	封装服务【this.$get=function () {return{}}】


	DOM结构:
	<input type="text" ng-model="num1">
	+
	<input type="text"  ng-model="num2">
	=
	{{result}}
	<br>
	<button ng-click="addClick()">求和</button>

	Angular代码:
	var app = angular.module('myApp',[]);
	/*
	 	provider : 创建自定义服务
	 	参数一 : 服务的名字
	 	参数二 : 回调方法
	 */
	
	//封装服务,实质也就是对象里添加方法(函数)封装
	app.provider('my',function () {
		this.$get = function () {
			return { //服务中的内容
				'+' : function(num1,num2){ //求和
					return parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求和
					return parseInt(num1) - parseInt(num2);
				}
			}
		}
	})
	//angular中的服务,对常用方法的封装
	app.controller('myCtrl',function($scope,my){
		var cmd = $scope;
			cmd.addClick = function () {
				cmd.result = my['+'](cmd.num1,cmd.num2);
			}
	})
	

【配置服务】
	【模板.config(callback)】
	【currency】通用
	在控制器内用变量保存this,然后使用this.currency使用就好
	
	Angular代码:
	var app = angular.module('myApp',[]);
	//服务的配置
	app.config(function(myProvider){
		myProvider.currency = '#';
	});

	app.provider('my',function () {
		var _this = this;
		this.$get = function () {
			return { //服务中的内容
				'+' : function(num1,num2){ //求和
					return (_this.currency) + parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求减
					return (_this.currency) - parseInt(num1) - parseInt(num2);
				}
			}
		}
	})
	
	//angular中的服务,对常用方法的封装
	app.controller('myCtrl',function($scope,my){
		var cmd = $scope;
			cmd.addClick = function () {
				cmd.result = my['+'](cmd.num1,cmd.num2);
			}
	})
【factory创建服务】
	省略了this.$get = function (){}
		直接return{}就好

	/*
	 	factory : 创建自定义服务
	 	参数一 : 服务的名字
	 	参数二 : 回调方法
	 */
	app.factory('my',function () {
			return { //服务中的内容
				'+' : function(num1,num2){ //求和
					return parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求减
					return parseInt(num1) - parseInt(num2);
				}
			}
	})
	app.factory('my',function () {
			return { //服务中的内容
				'+' : function(num1,num2){ //求和
					return parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求减
					return parseInt(num1) - parseInt(num2);
				}
			}
	})
【service创建服务】
	连return{}也省略了,直接
	【this['+'] = callback】

	app.service('my',function () {
			this['+'] = function (num1,num2) {
				return parseInt(num1) +  parseInt(num2);
			}
	})
【value创建服务】
	连funtion(){}也省略了,直接使用{}添加服务内容就好

	app.value('my',{
				'+' : function(num1,num2){ //求和
					return parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求减
					return parseInt(num1) - parseInt(num2);
				}
	})

【constant创建服务】
	//和value区别在于constant能配置

	//服务的配置
	//constant服务配置可以直接更改为my自定义服务名
	app.config(function(my){
		my.currency = '#';
		console.log(1);
	});

	app.constant('my',{
				'+' : function(num1,num2){ //求和
					return parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求减
					return parseInt(num1) - parseInt(num2);
				}
	})


【服务的装饰】
	服务的装饰:
	 	1.内置服务装饰
	 	2.自定义服务装饰

→【修改默认的服务】
	【delegate】代理
		delegate:服务的装饰
		 	参数一:装饰的服务
		 	参数二:【$delegate】 服务的代理,$delegate中拥有参数一服务下所有的方法

	【Angular代码】
	
	var app = angular.module('myApp',[]);
	app.config(function ($provide) { //$provide找到所有的服务
		$provide.decorator('$log',function ($delegate) {
			var log = $delegate.log;
			$delegate.log = function () {//输出所有的信息的前面加上一个当前时间
				var arg = Array.prototype.slice.call(arguments);//获取所有的参数
					arg.unshift(new Date());
					log.apply(null,arg);
			}
			return $delegate;
		});
		
	})
	
	//angular中的服务,对常用方法的封装
	app.controller('myCtrl',function($scope,$log){
		$log.log('今年天气真好,才怪!'); //Fri Apr 21 2017 17:44:18 GMT+0800 (中国标准时间) "今年天气真好,才怪!"
	})
	

→【修改默认的服务】
	【DOM结构】
	<input type="text" ng-model="num1">
	+
	<input type="text"  ng-model="num2">
	=
	{{result}}
	<br>
	<button ng-click="addClick()">求和</button>

	【Angular代码】
	app.config(function ($provide) { 
		$provide.decorator('my',function ($delegate) {
			console.log($delegate);
			$delegate['+'] = function (num1,num2,num3) {
				return parseInt(num1) + parseInt(num2) + parseInt(num3);
			};
			return $delegate;
		});
	})
	
	app.factory('my',function(){
		var _this = this;
		return {
				'+' : function(num1,num2){ //求和
					return _this.currency + parseInt(num1) + parseInt(num2);
				},
				'-' : function(num1,num2){ //求减
					return _this.currency - parseInt(num1) - parseInt(num2);
				}
		}
	})
	

	//angular中的服务,对常用方法的封装
	app.controller('myCtrl',function($scope,my){
		$scope.result = my['+'](3,4,5);
	})


===================================================================
路由切换
	1.页面元素切换
	【$routeProvider】路由服务
		【.when('href/url',{})】
			when什么
		【.otherwise】
			otherwise否则
	【template】是页面元素
	【templateUrl】是外部文件

	【DOM结构】
		<a href="#/home">首页</a>
		<a href="#/user">用户</a>
		<!--ng-view显示路由中对应的模板信息-->
		<ng-view></ng-view>
	【Angular代码】
	//创建模块,依赖于ngRoute模块
	var app = angular.module('myApp',['ngRoute']);
	app.config(function ($routeProvider) {
		$routeProvider
			.when('/home',{
				template : '<div>{{name}}</div>',
				controller : function ($scope) {
					$scope.name = '测试';
				}
			})
			.when('/user',{
				template : '<div>{{name}}</div>',
				controller : function ($scope) {
					$scope.name = '用户页';
				}
			})
		.otherwise('/home');
	})

切换页面
	【Angular代码】
	//创建模块,依赖于ngRoute模块
	var app = angular.module('myApp',['ngRoute']);
	//angularJs路由切换页面
	app.config(function ($routeProvider) {
		$routeProvider
			.when('/home',{
				templateUrl : './views/home.html',
				controller : function ($scope) {
					$scope.title = '首页标题';
					$scope.content = '首页内容';
				}
			})
			.when('/user',{
				templateUrl : './views/user.html',
				controller : function ($scope) {
					$scope.title = '用户页标题';
					$scope.content = '用户页内容';
				}
			})
			.otherwise('/home');
	})
	Page页面1 和Page页面2:
	<div class="container">
		<!--默认面板-->
		<div class="panel panel-danger">
			<div class="panel-heading">
				{{title}}
			</div>
			<div class="panel-body">
				{{content}}
			</div>
		</div>

【监测路由的变化】
	【'ngRoute'】 创建模块,依赖于ngRoute模块	
	$routeProvider路由服务
		【.when('/user/:id',{ //问号传参  rarams})】:id == ?都是传参用的
			【$location】位置服务,相当于localstorage
			$location.path('/user/5');
			通过【path】选择跳转页面最后面/是传ID值
		【.otherwise】否则
		这是为了点击按钮跳转,如果直接点跳转页面会调到设置页面
	

	【DOM结构】
		<a href="#/home">首页</a>
		<a href="#/user">用户</a>
		<a href="#/setting">设置</a>
		<!--ng-view显示路由中对应的模板信息-->
		<ng-view></ng-view>
	
	【Angular代码】
	//创建模块,依赖于ngRoute模块
	var app = angular.module('myApp',['ngRoute']);
	//angularJs路由切换页面
	app.config(function ($routeProvider) {
		$routeProvider
			.when('/home',{
				templateUrl : './views/home2.html',
				controller : function ($scope,$location) {
					$scope.title = '首页标题';
					$scope.content = '首页内容';
					$scope.btnClick = function(){
						$location.path('/user/5');
					}
				}
			})

			.when('/user/:id',{ //问号传参  rarams
				templateUrl : './views/user2.html',
				controller : function ($scope,$http,$routeParams) {
					$scope.title = '用户页标题';
					$http({
						type : 'get',
						url : './js/data.json'
					}).success(function (data) {
						$scope.ary = data;
					})
					$scope.id = $routeParams.id;
				}
			})
			.when('/setting',{
				template : '<div>设置页</div>',
				controller : function ($scope,$http) {
				}
			})
			.otherwise('/home');
	})
		app.run(function($rootScope,$location){
			$rootScope.$on('$routeChangeStart',function (e,toState,fromState) {
				console.log(toState);
				console.log(formState);
			})
		})
	
	Page页面2:
	<div class="panel panel-default">
	 	{{id}}
		<div class="panel-heading">{{title}}</div>
		<div class="panel-body">
			<ul class="list-group">
				<li class="list-group-item" ng-repeat="user in ary track by $index">
					<span>{{user.name}}</span>
					<span>{{user.age}}</span>
					<span>{{user.score}}</span>
				</li>
			</ul>
		</div>
	</div>













	【DOM结构】
		
	【Angular代码】
【AngularJS】【angular】[angular][AngularJS]




	AngularJS 扩展了 HTML
	AngularJS 通过 【ng-directives】 扩展了 HTML。
	【ng-app】 指令定义一个 AngularJS 应用程序。
	【ng-model】 指令把元素值（比如输入域的值）绑定到应用程序。
	【ng-bind】 指令把应用程序数据绑定到 HTML 视图。
	【AngularJS 实例
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"></script>
	</head>
	<body>
		<div ng-app="">
  			<p>名字 : <input type="text" ng-model="name"></p>
  			<h1>Hello {{name}}</h1>
		</div>

	</body>
</html>


创建自定义的指令
	除了 AngularJS 内置的指令外，我们还可以创建自定义指令。
	你可以使用 .directive 函数来添加自定义的指令。
	要调用自定义指令，HTMl 元素上需要添加自定义指令名。
	使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive:
	AngularJS 实例
	<body ng-app="myApp">
		<runoob-directive></runoob-directive>
	<script>
	var app = angular.module("myApp", []);
	app.directive("runoobDirective", function() {
   		 return {
       		 template : "<h1>自定义指令!</h1>"
    		};
	});
	</script>

</body>
验证用户输入
AngularJS 实例
	<form ng-app="" name="myForm">
    		Email:
    	<input type="email" name="myAddress" ng-model="text">
    	<span ng-show="myForm.myAddress.$error.email">不是一个合法的邮箱地址</span>
	</form>



<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"></script> 
	</head>
	<body>

	<form ng-app="" name="myForm">
   		 Email:
    		<input type="email" name="myAddress" ng-model="text">
    		<span ng-show="myForm.myAddress.$error.email">不是一个合法的邮箱地址</span>
	</form>
	<p>在输入框中输入你的游戏地址，如果不是一个合法的邮箱地址，会弹出提示信息。</p>
	</body>
</html>
			
应用状态
	【ng-model】 指令可以为应用数据提供状态值(invalid, dirty, touched, error):
AngularJS 实例
<form ng-app="" name="myForm" ng-init="myText = 'test@runoob.com'">
    Email:
    <input type="email" name="myAddress" ng-model="myText" required></p>
    <h1>状态</h1>
    {{myForm.myAddress.$valid}}
    {{myForm.myAddress.$dirty}}
    {{myForm.myAddress.$touched}}
</form>

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script src="http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js"></script> 
	</head>
	<body>
		<form ng-app="" name="myForm" ng-init="myText = 'test@runoob.com'">
			Email:
			<input type="email" name="myAddress" ng-model="myText" required>
			<p>编辑邮箱地址，查看状态的改变。</p>
			<h1>状态</h1>
			<p>Valid: {{myForm.myAddress.$valid}} (如果输入的值是合法的则为 true)。</p>
			<p>Dirty: {{myForm.myAddress.$dirty}} (如果值改变则为 true)。</p>
			<p>Touched: {{myForm.myAddress.$touched}} (如果通过触屏点击则为 true)。</p>
		</form>
	</body>
</html>

根作用域
	所有的应用都有一个 $rootScope，它可以作用在 ng-app 指令包含的所有 HTML 元素中。
	【$rootScope】 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。
AngularJS 实例
	创建控制器时，将 $rootScope 作为参数传递，可在应用中使用：
	<div ng-app="myApp" ng-controller="myCtrl">
		<h1>{{lastname}} 家族成员:</h1>
		<ul>
    		<li ng-repeat="x in names">{{x}} {{lastname}}
		</ul>
	</div>

	<script>
		var app = angular.module('myApp', []);

		app.controller('myCtrl', function($scope, $rootScope) {
   		 	$scope.names = ["Emil", "Tobias", "Linus"];
    			$rootScope.lastname = "Refsnes";
		});
	</script>

		
AngularJS Filters
	过滤器可以使用一个管道字符（|）添加到表达式和指令中。

	AngularJS 过滤器
	AngularJS 过滤器可用于转换数据：
	过滤器	描述
	【currency】	格式化数字为货币格式。
	【filter】	从数组项中选择一个子集。
	【lowercase】	格式化字符串为小写。
	【orderBy】	根据某个表达式排列数组。
	【uppercase】	格式化字符串为大写。

表达式中添加过滤器
	过滤器可以通过一个管道字符（|）和一个过滤器添加到表达式中。.
	(（下面的两个实例，我们将使用前面章节中提到的 person 控制器）)
	【uppercase】 过滤器将字符串格式化为大写：
AngularJS 实例
	<div ng-app="myApp" ng-controller="personCtrl">
		<p>姓名为 {{ lastName | uppercase }}</p>
	</div>

	AngularJS 【$http】 是一个用于读取web服务器上数据的服务。
	【$http.get(url)】 是用于读取服务器数据的函数。
	AngularJS 实例
	<div ng-app="myApp" ng-controller="customersCtrl"> 
		<ul>
  			<li ng-repeat="x in names">
    			{{ x.Name + ', ' + x.Country }}
  			</li>
		</ul>
	</div>

	<script>
	var app = angular.module('myApp', []);
		app.controller('customersCtrl', function($scope, $http) {
   	 	$http.get("http://www.runoob.com/try/angularjs/data/Customers_JSON.php")
    		.success(function(response) {$scope.names = response.records;});
	});
	</script>


1.ng-show 指令
	【ng-show】 指令隐藏或显示一个 HTML 元素。
AngularJS 实例
	<div ng-app="">
		<p ng-show="true">我是可见的。</p>
		<p ng-show="false">我是不可见的。</p>
	</div> 

2．ng-hide 指令
	ng-hide 指令用于隐藏或显示 HTML 元素。
	AngularJS 实例
	<div ng-app="">
	<p ng-hide="true">我是不可见的。</p>
	<p ng-hide="false">我是可见的。</p>
	</div> 


AngularJS 全局 API 用于执行常见任务的 JavaScript 函数集合，如：
	比较对象
	迭代对象
	转换对象
全局 API 函数使用 angular 对象进行访问。
	以下列出了一些通用的 API 函数：
	API	描述
	【angular.lowercase()】	转换字符串为小写
	【angular.uppercase()】	转换字符串为大写
	【angular.isString()】	判断给定的对象是否为字符串，如果是返回 true。 
	【angular.isNumber()】	判断给定的对象是否为数字，如果是返回 true。

	angular.lowercase()
实例
	<div ng-app="myApp" ng-controller="myCtrl">
		<p>{{ x1 }}</p>
		<p>{{ x2 }}</p>
	</div>

	<script>
	var app = angular.module('myApp', []);
		app.controller('myCtrl', function($scope) {
		$scope.x1 = "JOHN";
		$scope.x2 = angular.lowercase($scope.x1);
	});
	</script> 


	实例解析
	AngularJS 【ng-model】 指令用于绑定输入元素到模型中。
	模型对象有两个属性： user 和 email。
	我们使用了 ng-show指令， color:red 在邮件是 $dirty 或 $invalid 才显示。
	属性	描述
	【$dirty】	表单有填写记录
	【$valid】	字段内容合法的
	【$invalid】	字段内容是非法的
	【$pristine】	表单没有填写记录


	AngularJS 指令
	指令	描述
	【ng-app】	定义应用程序的根元素。
	【ng-bind】	绑定 HTML 元素到应用程序数据
	【ng-bind-htm】l	绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字符
	【ng-bind-template】	规定要使用模板替换的文本内容
	【ng-blur】	规定 blur 事件的行为
	【ng-change】	规定在内容改变时要执行的表达式
	【ng-checked】	规定元素是否被选中
	【ng-class】	指定 HTML 元素使用的 CSS 类
	【ng-class-even】	类似 ng-class，但只在偶数行起作用
	【ng-class-od】d	类似 ng-class，但只在奇数行起作用
	【ng-click】	定义元素被点击时的行为
	【ng-cloak】	在应用正要加载时防止其闪烁
	【ng-controller】	定义应用的控制器对象
	【ng-copy	规定拷贝事件的行为
	【ng-csp】	修改内容的安全策略
	【ng-cut】	规定剪切事件的行为
	【ng-dblclick】	规定双击事件的行为
	【ng-disabled】	规定一个元素是否被禁用
	【ng-focus】	规定聚焦事件的行为
	【ng-form】	指定 HTML 表单继承控制器表单
	【ng-hide】	隐藏或显示 HTML 元素
	【ng-href】	为 the <a> 元素指定链接
	【ng-if】	如果条件为 true 移除 HTML 元素
	【ng-include】	在应用中包含 HTML 文件
	【ng-init】	定义应用的初始化值
	【ng-jq】	定义应用必须使用到的库，如：jQuery
	【ng-keydown】	规定按下按键事件的行为
	【ng-keypress】	规定按下按键事件的行为
	【ng-keyup】	规定松开按键事件的行为
	【ng-list】	将文本转换为列表 (数组)
	【ng-model】	绑定 HTML 控制器的值到应用数据
	【ng-model-options】	规定如何更新模型
	【ng-mousedown】	规定按下鼠标按键时的行为
	【ng-mouseenter】	规定鼠标指针穿过元素时的行为
	【ng-mouseleave】	规定鼠标指针离开元素时的行为
	【ng-mousemove】	规定鼠标指针在指定的元素中移动时的行为
	【ng-mouseover】	规定鼠标指针位于元素上方时的行为
	【ng-mouseup】	规定当在元素上松开鼠标按钮时的行为
	【ng-non-bindable】	规定元素或子元素不能绑定数据
	【ng-open】	指定元素的 open 属性
	【ng-options】	在 <select> 列表中指定 <options>
	【ng-paste】	规定粘贴事件的行为
	【ng-pluralize】	根据本地化规则显示信息
	【ng-readonly】	指定元素的 readonly 属性
	【ng-repeat】	定义集合中每项数据的模板
	【ng-selected】	指定元素的 selected 属性
	【ng-show】	显示或隐藏 HTML 元素
	【ng-src】	指定 <img> 元素的 src 属性
	【ng-srcset】	指定 <img> 元素的 srcset 属性
	【ng-style】	指定元素的 style 属性
	【ng-submit】	规定 onsubmit 事件发生时执行的表达式
	【ng-switch】	规定显示或隐藏子元素的条件
	【ng-transclude】	规定填充的目标位置
	【ng-value】	规定 input 元素的值

【angular事件】[angular事件]

	过滤器解析 AngularJs 过滤器。
	
	AngularJS 事件
	AngularJS 支持以下事件:
	【ng-click】
	【ng-dbl-click】
	【ng-mousedown】
	【ng-mouseenter】
	【ng-mouseleave】
	【ng-mousemove】
	【ng-keydown】
	【ng-keyup】
	【ng-keypress】
	【ng-change】
	事件解析： Angular 事件。
	
	AngularJS 验证属性
	【$dirty】
	【$invalid】
	【$error】
	验证解析：Angular 验证。
	
	AngularJS 全局 API
	转换
	API	描述
	【angular.lowercase()】	将字符串转换为小写
	【angular.uppercase()】	将字符串转换为大写
	【angular.copy()】	数组或对象深度拷贝
	【angular.forEach()】	对象或数组的迭代函数
	比较
	API	描述
	【angular.isArray()】	如果引用的是数组返回 true
	【angular.isDate()】	如果引用的是日期返回 true
	【angular.isDefined()】	如果引用的已定义返回 true
	【angular.isElement()】	如果引用的是 DOM 元素返回 true
	【angular.isFunction()】	如果引用的是函数返回 true
	【angular.isNumber()】	如果引用的是数字返回 true
	【angular.isObject()】	如果引用的是对象返回 true
	【angular.isString()】	如果引用的是字符串返回 true
	【angular.isUndefined()】	如果引用的未定义返回 true
	【angular.equals()】	如果两个对象相等返回 true
	JSON
	API	描述
	【angular.fromJSON()】	反序列化 JSON 字符串
	【angular.toJSON()】	序列化 JSON 字符串
	基础
	API	描述
	【angular.bootstrap()】	手动启动 AngularJS
	【angular.element()】	包裹着一部分DOM element或者是HTML字符串，把它作为一个jQuery元素来处理。
	【angular.module()】	创建，注册或检索 AngularJS 模块






====================================================
【node.js】
Node.js是什么?
	Node.js不是一种独立的语言,与PHP,java,net即是开发语言也是平台不同,也不是javaScript的框架,jquery,更不是浏览器的库ExtJs,能不与ExtJs相提并论.
	核心:【Node.js是一个让javascript运行在服务端的开发平台】工作环境
Node.js能做什么?
	JavaScript是有客户端产生,Node为网络而生.
	具有复杂逻辑的网站
	基于社交网络的大Web的应用
	Web Soket服务器
	TCP/UDP套接字应用程序
	命令行工具
	交互式终端程序

Node.js的产生因素
	【chrome V8引擎】
	【JacaScript在服务器端空白】
	【事件驱动】
	【CommonJs的规范化】

	【IIS】:
	Microsoft的web服务器产品为Internet Information Services(IIS),时允许在公共Intranet或Internet上发布信息的web服务器.IIS是目前最流行的web服务器产品之一,很多著名的平台上.

	【Kangle】
	kangle web服务器(简称: kangle)是一款跨平台,功能强大,安全稳定,易操作的高性能Web服务器和反向代理服务器软件.

	【WebLogic】是一种多功能,基于标准的web应用服务器,为企业构建自己的应用提供了坚实的基础.各种应用开发,部署所有关键性,无论是集成各种系统和数据库,还是提交服务,跨Internet 写作,起始点都是 BEA WebLogic Server.由于 它具有全面的功能,对开放标准的遵从性,多层架构,支持基于组件的开发,基于Internet的企业都选择它来开发,部署最佳的应用.

		BEA WebLogic Server		

	【Apache】
	Apache仍然是世界上用的最多的Web服务器,市场占用率达60%左右.它源于NCSAhttpd服务器,当NCSAWWW服务器项目停止后,那些使用NCSA WWW服务器的人们开始交换用于此服务器的补丁,这也是apache名称的由来(pache 补丁).世界上很多著名的网站都是Apache的产物,它的成功之处主要在于它的源代码开放,有一支开放的开放队伍,支持跨平台的应用(可以运行在几乎所有的Unix,Window,Linux系统平台上)以及它的可移植性等方面.


	【Tomcat】 Java使用
		Tomcat是一个开发源代码,运行servle和JSP Web应用软件的基于Java的Web应用软件容器.Tomcat Server是根据servlet和JSP规范的,因此我们就可以说TomcatServer也实行了Apache-Jakarta规范且比绝大多数商业应用软件服务器要好.
	【Node.js】 是一个基于【Chrome V8】 引擎的JavaScript 运行环境.Node.js使用了一个事件驱动,非阻塞式I/O的模型,使其轻量又高效.Node.js的包管理器【npm】,是全球最大的开源库生态系统.


https://nodejs.org/cn/#download
http://nodejs.org/dist/npm/
https://nodejs.org/dist/


npm config set prefix "E:\nodejs\npm-global"
npm config set cache  "E:\nodejs\npm-global"

prefix在..之前加上



方法一

运行以下两个命令：

npm config set prefix "E:\nodejs\npm-global"
npm config set cache  "E:\nodejs\npm-cache"
运行完后，在你的 %HOMEPATH% 下面会出现一个名为 .npmrc 的文件，将其重命名为 npmrc，并移动到目录 E:\nodejs\node_modules\npm 下。


方法二

直接在 D:\DevPack\opt64\nodejs\node_modules\npm 目录下新建一个 npmrc 文件，并写入以下内容并保存：

prefix = D:\DevPack\opt64\nodejs\npm-global
cache = D:\DevPack\opt64\nodejs\npm-cache

要卸载 javascripting，只需运行 npm remove javascripting -g 即可。

https://github.com/tanepiper/SublimeText-Nodejs


server.js默认放在
C:\Users\电脑用户名,目录下,也可以在其他路径打开
只要在cmd 输入node server.js就能启动服务器

用bat直接输入node 路径\server.js也可以启动服务器

==================================================================
var http = require('http');//引入http模块

//开启服务，监听8888端口
//端口号最好为6000以上
var server = http.createServer(function(req,res){
    /*
        req用来接受客户端数据
        res用来向客户端发送服务器数据
    */

    console.log('有客户端连接');//创建连接成功显示在后台

    //一参是http请求状态，200连接成功
    //连接成功后向客户端写入头信息
    res.writeHeader(200,{
        'Content-Type' : 'text/html;charset="utf-8"'
    });

    res.write('这是正文部分');//显示给客户端
    res.end('hello World\n');

}).listen(3000,"127.0.0.1");

console.log('服务器开启成功');
==================================================================
第二个
var http = require('http');
http.createServer(function(req,res){
    res.writeHead(200,{'Content-Type':'text/html'});
    res.writeHeader(200,{
        'Content-Type' : 'text/html;charset="utf-8"'
    });
    res.write('<h1>Node.js我们已经有服务了</h1>');
    res.end('<p>视频出处,PCAT</p>')
}).listen(5858);
==================================================================
关闭服务器,只要在批处理内Ctrl+C就能强制终止



PS:如果修改server.js文件后,必须终止服务器,并重新练习才能生效






==================================================================
【安装node.js】
1.首先下载node.js对应的x86和x64版本msi后缀版本
2.打开【计算机-属性-远程高级设置-高级-环境变量(N)...】
	在变量名(N):写【PATH】
	变量值(V):写【C:\Program Files\nodejs\】自定义路径就写自定义路径
		C:\Users\ECY\AppData\Roaming\npm
	【确定】


	【Window+R】打开运行,输入cmd【确定】
	命令行输入:
	【node】进入编译模式
	【node -v】命令行工具 检测版本
	【cd node】进入定义目录
	【node -e "console.log('这里命令')"】执行那个js代码
		ps1:引号只能用外双里单,不能相反
		ps2:如果-e后面每空格,就会显示乱码
	【node -e "eval script eval('这里命令')";】
	console.log(1);
	第一行时输出,第二行是返回值
4.调试代码
	CD C:\Program Files\nodejs\node_modules\npm
	【npm -g install supervisor】


	npm install -g supervisor
	npm install -supervisor -g


	一直开启【supervisor server.js】
	https://segmentfault.com/q/1010000000209492
	http://www.lifeba.org/arch/nodejs_npm_express.html
	【http://localhost:5858/】
	【http://localhost:3000/】


	【npm config ls】查看当前配置
npm install -g javascripting
npm install -g npm@版本
npm config set cache  "E:\nodejs\"
npm config set prefix "E:\nodejs\"
npm config set cwd "E:\nodejs\"
npm config set HOME "E:\nodejs\"


npm -v
node -v
npm mysql
npm jade
npm express



	module对应prefix
	cache对应cache
====================================================================
命令符使用外部js:
1.cmd打开node.js程序目录
2.目录下有js文件,如果有中文,编码必须是【UTF-8】格式,否则不生效
3.切换到当前目录,直接使用【node test.js】就能执行


====================================================================
修改【node.js路径问题】

1.打开cmd命令行，查看当前配置

输入 【npm config ls】

先看一下当前npm的配置环境，由于我已经修改过，所以可以看到修改后的路径


2.修改路径

这里需要修改两个路径，module路径和cache路径
	module对应prefix
	cache对应cache

首先在别的盘新建两个目录

	【F:\node-js\node_modules\npm\npm\node_global_modules】
	【F:\node-js\node_modules\npm\node_cache】

然后依次执行

	【npm config set prefix"F:\node-js\node_modules\npm\node_global_modules"】
	【npm config set cache"F:\node-js\node_modules\npm\npm\node_cache"】


3.修改环境变量

新增环境变量【NODE_HOME】
	【F:\node-js】
修改Path，追加【%NODE_HOME%\;%NODE_HOME%\node_modules;%NODE_HOME%\node_modules\npm\node_global_modules\;】
修改后:
	【C:\Users\ECY\AppData\Roaming\npm%NODE_HOME%\;%NODE_HOME%\node_modules;%NODE_HOME%\node_modules\npm】


4.测试一下

重新打开一个cmd命令行，安装一个插件试试

执行
【npm install cordova -g】// -g意思是安装到全局目录下

安装完毕后打开设置的安装路径看下是否成功

大功告成!



====================================================================
异步显示文件内容
var fs = require('fs');
fs.readFile('file.txt','UTF-8',function(err,data){
  if(err){
      console.log('read file err');
  } else{
      console.log(data);
  }
})
console.log('end');


同步显示文件内容

var fs = require("fs");
var data2 = fs.readFileSync('file.txt','utf-8');
console.log(data2);
console.log('end');


测试:前者,模块文件不可更改变量名，只能使用默认的，后者的调用变量，可以自己定义变量名，引号也可以随意，但嵌套时记住【内单外双】或【内双外单】。【utf-8】大小写不敏感

PS:调用模板文件，后面必须添加【引号】,否则会报错
====================================================================
创建一个事件和时间间隔

  //声明事件对象
  var EventEmitter = require('events').EventEmitter;
  var event = new EventEmitter();

  //注册事件
  event.on('myEvent',function(){
    console.log('这是自定义时间?ok');
  });

  //触发事件
  setTimeout(function(){
    event.emit('myEvent');
  },1000)


测试和js相同,不但能使用setTimeout,还能使用setInterval事件,比如

  //触发事件
  setInterval(function(){
    event.emit('myEvent');
  },1000)

如上,调用模板变量不可更改,声明调用模板变量可更改
====================================================================
	模块(Module)和包(Package)是Node.js最重要的支柱.开发一个具有一定规模的程序不可能只用一个文件,通常需要把各个功能拆分,分装,然后组合起来.模块正是为了实现这种方式而诞生,在浏览器JavaScript中,脚本模块的拆分通常使用HTML的script标签来实现,Node提供了require函数来调用其他模块,而且【模块都是基于文件】,机制非常简单,模块和包的区别是透明的,因为经常不作区分.

2.创建及加载模块
	(1).创建模块
		Node.js提供了exports和require两个对象,其中exports是板块公开的接口,require用于从外部获取一个模块的接口,及获取模块的exports对象
		module.js和getModule.js
	//自己创建模块【module.js】
	var name;
  	exports.setName = function(thyName){
   	 name = thyName;
 	 }
  	exports.sayHello = function(){
    	console.log('hello ' + name);
  	}
	//调用自己创建模块【getModule.js】
  	var myMoudule = require('./module');
   	 myMoudule.setName('来吧,自己创建个模块');
   	 myMoudule.sayHello();

	(2) 单次加载
		上面的例子有点类型创建一个对象,但实际上和对象又有本质的区别,因为【require】不会重复加载模块,也就是说无论调用多少次require,获取的模块都是同一个
	getModule2.js
	(3)覆盖expots
		有时我们只是想把一个对象封装到模块中,例如
		定义模块:singleObject.js
		引入模块使用:getSingleObject.js
		繁琐:exports.hello = hellow;
		引入:require('./singleObject').hello;
		简易:module.exports = hello;
		exports本身仅仅是一个普通的空对象,即{},它是专门用来声明接口
	//自己创建模块【singleObject.js】
	  function hello(){
    		var nama;
    		this.setName = function(Name){
     		 name = Name;
    		}
   		this.setHello = function(){
      		console.log('hello ' + name);
   		 }
  	  }
     		module.exports = hello;
	//调用模板【getObject.js】
        var hello = require('./singleObject');
        var he = new hello();
          he.setName('这是第一个');
          he.setHello();
        var he2 = new hello();
          he2.setName('这是第二个');
          he2.setHello();

	二.创建包
	1.包的概念
	包是在模块基础上更深一步的抽象,Node.js的包类似于C/C++的函数库或者Java的类库,它讲某个独立的功能封装起来,用于发布,更新,依赖管理的版本控制.开发了npm来解决包的发布和获取需求
	2,如何创建一个包.
	CommonJs规范的包应该具备以下特征:
	package.json必须在包的顶层目录下
	二进制文件必须在【bin】目录下
	JavaScript代码应该在【bin】目录下
	文档必须在【doc】目录下
	单元测试应该在【test】目录下
Node.js对包要求并没有那么严格,只要顶层目录下有package.json,并符合基本规范即可
	(1)作为文件夹的模块
	somepackage文件夹
	最简单的包,就是一个作为文件夹的模块
	创建一个文件夹,somepackage,里面有一个index.js,里面提供一个方法sayHello()
	var somepackage = require('./somepack');
	somepackage.sayHello();
	我们使用这种方法可以把文件夹封装成一个模块,即所谓的包.包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库,通过定制package.jojn,我们可以创建更复杂,更完善,更符合规范的包用于发布.
	
	如以下:
	├─package
	│	│ └──-
	│      │       │
	│	│	└─bin
	│	│	│  doc
	│	│	│  lib
	│	│	│    └──-
	│	│	│          │
	│	│	│	  package.js
	│	│	└─test
	│	└──
	│	     │
	│	 package.json
	├─somepackage_____________
	│		     │
	│		  index.js
	│
	getPackage.js

	//【getPackage.js查询包设置】
	var pac = require('./somepackage');
	pac.sayHello();
	var pack = require('./package');
	pack.say();

	//【gsomepackage子目录下的index.js设置】
	exports.sayHello = function(){
  		console.log('中文');
	}
	//【package子目录下的package.json设置】
	{
  		"main" : "./lib/package.js"
	}
	//【package子目录下的lib子目录下的package.js设置】
	 exports.say = function(){
   		 console.log('test package!')
 	 }

	(2)package.json
	前面的例子,在somepackage文件夹下,我们创建一个package.json的文件,内容
	{
  		"main" : "./lib/index.js"
	}
	Node.js在调用某个包时,会检查包中package,json文件的main字段,将其作为包的接口模板,如果package.json或main字段不存在,会尝试寻找index.js或index.code作为包的接口
	【index.js】也必须放在【package】目录下,不能放在子目录和改名,否则搜索不到
	若【index.js】和【package,json】同时存在,会执行【index.js】,也就是js比json优先级更高

	package.json的规范属性:
		【name】:包的名称,必须是唯一
		【description】: 包的简要说明
		【version】: 符合语义化版本识别规范的版本字符串
		【keywords】: 关键字数组,每个元素要包含name,email,web可选字段
		【maintainers】:维护者数组,每个元素要包含name,emain,web可选字符
		【contributors】:贡献者数组,格式与maintainers相同,包的作者应该是贡献者数据的第一个元素
		【bugs】: 提交bug的地址,可以是网址或者电子邮件地址
		【licenses】:许可证数组,每个元素要包含type和url字段
		【repositories】:仓库托管地址数组,每个元素要包含type,url和path字段
		【dependencies】:包的依赖,一个关联数组,由包名称和版本号组成
====================================================================
	npm init
	name(名称):testpckage
	version(版本):1.0.0
	description(描述):this is a test
	entry point(入口指向):./lib/package.js
	test command(测试 命令):
	git repository(没用 仓库):
	keywords(关键字):test
	author(作者):waecy
	license(许可证):



README.md
安装包,返回父级目录:
	cd ..
	npm install testpackage/
	简称【npm i  testpackage/】
	npm list 查看有没有这个包
	var t = require('testpackage');
	t.say();
	最简单查询var t = require('testpackage');直接在后面添加t回车就能查询

	获取一个包
	npm [install/i][package_name]
	卸载包:
	npm uninstall 包名[-g]
	查看当前所有包:
	npm list



	uglifyjs压缩JS
	安装
	【npm install uglify-js -g】
	压缩
	【uglifyjs 要压缩的文件名.js -o inet-min.js】

	再运行如下代码，测试-m可选参数：
	【uglifyjs 要压缩的文件.js -m -o inet.min.js】


	压缩CSS
	【npm install clean-css -g】

cannot find module
不能 发现 模块

	【使用全局模式安装的包并不能在javascript文件中require获得】因为require不会搜索/user/local/lib/node_modules
	通俗讲:当我们要把某个包作为工程运作时的一部分时,通过本地模式获取,如果在命令行下使用,则使用全局模式

	包的发布:
	首选确保具备CommonJs为基础包的规范,但与Common并不完全一致,其主要差别在于必填字段的不同,通过使用nom init可以根据交互式问答产生一个符合标准的package.json
	dos进入package.jojn所在目录运行npn publist就完成了发布
	如果更新包:
	如果你的报内容有改动,则在版本上作改动,运行npm publish
	访问http://search/npmjs.org就可以找到自己刚刚发布的包了
	二:调试代码
	在exlipse装插件
		地址是:http://chromedevtools.googlecode.com/svn/update/dev/
		在debug中配置 端口为5858
	在命令行运行js文件的时候
	node --deug-brk=5858 文件名.js
	现在就在ecplise中启动debug就可以跟断点了

	npm help json
	默认在C:\Program Files\nodejs\node_modules\npm\html\doc\files\package.json.html文件夹内
	C:\Program Files\nodejs\node_modules\npm\html\doc
common普通
server侍者,服务员
require命令
listen倾听
local当地的
host主机


readFile 显示 发送
async 同步
emit 发出,发射
Emitter

module模块
exports输出
say表明
thy你的

single单一的,挑选

somepackage某个包装
some 某个
package 包
bin 二进制
lib 解放运动

端口号:一个服务器可以存放多个项目,项目之间可以通过端口号进行区别
端口号的范围:0~65535

谷歌: V8引擎
火狐: Gecko引擎
ie:Trident引擎


url请求地址的构成
	htnl://www.name.com:80/index.html?name=baizhi&age=18

	【url】[url]:统一资源定位符
	【urn】[urn]:统一资源名称
	【uri】[uri]:统一资源识标 uri = url + urn

	http:超文本传输链接协议
	www.chenchao.com:域名 解析 ip确定服务器
	80:端口,在服务器中找到对应的项目
	/html/index.html; 为了在项目中找到相应的文件
	?name=baizhi&age=18
	
	http:超文本传输链接协议
	https:更加安全的http
	ftp:文件传输协议

https://www.baidu.com; 端口号
每个协议对应都会一个默认的访问端口号:
	http:80
	https: 443 445
	ftp: 21

http到底做了什么?
	客户端传输给服务器的信息,还是服务器返回到客户端信息,统一都称之为报文

	[dos]
        基本的dos操作
       快捷键  window + R  => 输入cmd回车
       1.查看自己的IP地址 : ipconfig / ipconfig all
       2.跳转到指定盘符: 盘符名:
       3.创建文件夹: md 文件名
       4.查看当前文件目录: dir
       5.创建文件: cd > 文件名 echo 输入的文本 > 文件名
       6.删除文件: del 文件名
       7.返回上级目录:cd ../
       8.删除文件夹 : rd 文件夹名称
       9.清理命令行 : cls清除命令行
       10.终止程序,Ctrl + C
       11:退出命令行窗口:exit
       12.查看网络状态:ping ip地址

     二: 如何搭载一台自己的服务器
         1.前后代码要有
         2.买服务器(买了一个IP地址)
         3.代码部署 通过FTP 上传 将代码部署到服务器
         4.买域名 (www.yuming.com)
         5.DNS 域名解析

    三:客户端和服务器的交互模型
     http://www.yuming.com:8888/index.html?username=zhangsan&age=18

     客户端:
      1.输入url
      2.解析服务器返回的数据,并进行渲染

     DNS 域名解析:
      1.解析域名 得到ip地址
      2.通过 ip 找到服务器
      3.通过 端口 找到指定的项目
      4.通过路径找到指定的文件

     服务器:
      服务器将文件读取出来,并返回客户端

     四 相关概念的介绍
     http://www.yuming.com:8888/index.html?username=zhangsan&age=18

     http:超文本传输协议
     https:更加安全的超文本传输协议
          safe安全
     ftp:文件传输协议
          域名:www.zhangsan.com
          端口号: 0~65535 --> 定位项目
          路径: /index --> 指定了需要的文件
          参数: ?username=zhangsan&age=18

     http: 默认端口 80
     https: 默认端口 443
     ftp: 默认端口 21

    url: 统一资源定位符
    urn: 统一资源名称
    uri: 统一资源标识符

    谷歌的渲染引擎 (V8)
        火狐(gecko)

    五:什么是node.js?
        1.nodejs是对 谷歌V8 引擎的一种封装,实现了js程序的独立运行,nodejs是js的运行环境
        2.Node.js 使用了一个事件驱动,非阻塞式I/O的模型,使其轻量又高效.(nodejs的特点)
        3.Node.js的包管理器npm,是全球最大的开源库生态环境

    六: node 和 浏览器 有什么区别
        相同点: 都提供js的运行环境
        不同点: 浏览器是装在客户端,node一般转在服务器上
                浏览器内核的不同 渲染不同 node 不用考虑兼容
                浏览器不支持操作电脑文件 node可以借助fs模块操作文件

     七 node 中运行js代码
        1.右键直接点击运行
        2.在doc窗口中使用命令 node 文件名

     八 node当中的模块
        1.为了提高node.js复用性,提供一个模块系统
        2.模块是node中基本组成,一个js文件可以相当于一个模块

        模块导出
        1.模块必须导出才能使用,不导出 使用不了
        2.模块导出 用到module.exprots

        模块的引入
        1.使用模块必须引入模块;
        2.模块的引入使用 require(模块的路径)

        1.练习: 导出一个构造方法,通过该构造方法创建一个实例并调用其中的方法

        node 当中的分类
            内置模块 : node自身所带有的模块(http,url,fs)
            第三方模块: 别人写好封装好的模块 (express 模块)
            自定义模块: 自己的编写的模块

        内置模块引入 require(内置模块名) var fs = require('fs);

        第三方模块:npm install 第三方模块名 (安装第三方模块) require('模块名') var express = require('express')

        自定义模块: require(自定义模块的路径) var add = require('./add')



       node中的内置模块的学习
       http模块 : 创建服务,监听端口.根据请求的url 路径 执行相应的操作
       url : 要来解析路径 一个方法 url.parse(),两个属性 pathname : 路径 query : 参数
       fs: fs模块 是文件的操作,读取 写入



        基本的doc操作[cmd][cmd操作][命令行]
       快捷键  window + R  => 输入cmd回车
       1.查看自己的IP地址 : ipconfig / ipconfig all
       2.跳转到指定盘符: 盘符名:
       3.创建文件夹: md 文件名
       4.查看当前文件目录: dir
       5.创建文件: cd > 文件名 echo 输入的文本 > 文件名
       6.删除文件: del 文件名
       7.返回上级目录:cd ../
       8.删除文件夹 : rd 文件夹名称
       9.清理命令行 : cls清除命令行
       10.终止程序,Ctrl + C
       11:退出命令行窗口:exit
       12.查看网络状态:ping ip地址
   
	【Shift+↑】或【Shift+↑】能得到之前输入命令内容,不用一次又一次复制



=============================================================
	【mongodb】[mongodb]
	命令窗口-启动服务:
	【mongod --dbpath=E:\MongoDB\data】
	【mongod --storageEngine mmapv1 --dbpath=E:\MongoDB\data】32用这个启动
	命令窗口-打开客户端
	【mongo】

	错误解决:
	如果无法启动mongodb,把指定要存放的E:\MongoDB\data文件夹重命名或删除,再重启就好
	若无法启动www,检查是否模块损坏,重安装

        ## 什么是MongoDB
        > 1.mongodb 是一个基于分布式文件储存的开源数据库
        > 2.mongodb 将数据存储为一个文档(json) 数据结构是由键值对(key=value)组成
        > 3.mongodb 文档类似于json 对象,字段可以包含对象 数组.
    
        ## 2.mongodb的安装
            64位安装 64位
            32为安装 32位
            默认安装
    
        ## 3.mongodb的启动
        + 默认路径 C:\Program Files\MongoDB\Server\3.4\bin
        + 按住shift键 右键在此处打开命令窗口
        + 除在 C盘以外 新建一个空的目录 例如: D:\MongoDB\data
    
        ## 4.启动 mongdb 服务器
        + 在命令行中输入mongod --dbpath=E:\MongoDB\data
               mongod --storageEngine mmapv1 --dbpath=E:\MongoDB\data
        ## 5.mongdb 默认端口 27017
            成功启动的标志 waitiong for connections on port 27017
    
        ## 6.启动mongodb的客户端
        + mongo
        + 有大于号时 成功启动
    
        ## 7.mongodb中的一些基本概念
        + 数据库 : 数据库是有集合组成
        + 集合: 集合文档组成,一个集合可以表示一个实体
        + 文档 : 文档就是一条记录,比如一个同学的信息可以当做一个文档
    
        ## 8.数据库的实际操作
        + 1.查看所有数据库 show dbs
            默认数据库 3.4 admin local 默认不使用它们
                      3.2 local
        + 2. 创建数据库 : use 数据名称 例如 use student 创建学生数据库
    
        + 3. 查看当前数据库 : db(回车就可以)
    
        + 4. 创建集合 : db.createCollection('person');
    
        + 5. 查看当前集合 : show collections
    
        + 6. 集合下创建记录 :  db.h75.insert({})
            db.h75.insert({name:'姓名',age:1,height:180});
            db.h75.insert({name:'姓名2',age:25,height:182});
        + 7 查看所有记录 : db.集合名.find();
             例如:db.h75.find();
    
        + 8 怎么删除一个记录: db.h75.remove({});
    
        + 9 查看帮助: db.集合名.help();
    
        + 10 查找集合下的记录
            10.1 通过指定属性查找:db.h75.find({height : 182})
            10.2 只查找一条记录 : db.h75.findOne({height : 182})
            10.3 查询年龄大于25的记录:db.h75.find({age:{$gt : 25}})
            10.4 查询年龄大于等于25的记录 : db.h75.find({age:{$gte:25}})
            10.5 查询年龄小于25的记录 : db.h75.find({age:{$lt:25}})
            10.6 查询某条属性小于或等于多少的记录 : db.h75.find({age:{$lte:25}})
            10.7 查询大5岁 小于三十岁 : db.h75.find({age:{$gt:5,$lt:30}});
            10.8 查询年龄是25岁或者50岁 : db.h75.find({$or:[{age:25},{age:50}]});
            10.9 每一展示五条数据 : db.h75.find().limit(5);
            10.10 跳过前5条 展示剩下的数据:  db.h75.find().skip(5);
                   db.h75.find().skip(10).limit(5); //跳过前十条,展示后5条
    
        + 11 更新记录 :  db.h75.update({'name' : '姓名'},{$set : {age : 15}});


	1.express 介绍
          express 是一个简洁 高效的node web 用框架
            它提供了 例如:
                模板解析,静态文件处理,中间件,路由等,并且还可以配合其他的第三方模块,来快速的搭建一个具有完整功能的网站.
        2.使用
            /安装
        cd 5-15
        npm install express

	## 1.什么mongodb?
    	> 1.mongodb 是一个基于分布式文件储存的开源数据库
    	> 2.mongodb 将数据储存为一个文档(json) 数据是由键值对(key=value)组成
    	> 3.mongodb 文档类似json对象,字段可以包含对象 数组.提供了对于mongdb增删改查的一些方法


	## mongoose是什么?
    	+ 1.mongoose是mongodb的对象模型工具
    	- 2.同时他是针对mongodb操作的对象模型库
    	- 3.让node.js对于mongodb的操作变得更加简单

	## 安装 mongoose
    	npm install mongoose














[自动保存]
	browser-sync
	测试
	browser-sync start --server --files "*.html,*.css,*.js,*/*.css,*/*.js"
	选当前路径所有文件用【*.*】来代替
	若想让服务器自动刷新子目录,使用【*/*.*】来代替,每一层就添加一个【*/*.*】

	示范:10级子路径
browser-sync start --server --files "*.*,*/*.*,*/*/*.*,*/*/*/*.*,*/*/*/*/*.*,*/*/*/*/*/*.*,*/*/*/*/*/*/*.*,*/*/*/*/*/*/*/*.*,*/*/*/*/*/*/*/*/*.*,*/*/*/*/*/*/*/*/*/*.*,*/*/*/*/*/*/*/*/*/*/*.*"

	缺点:
		1.只支持html引入文件后自动保存,不支持没引入的单独css,js自动保存
		2.不能选择路径全部文件进行自动保存
		3.选择子级目录,需要大量自定义*号
	
【WebStorm】[WebStorm][WebStorm快捷键]
	【Ctrl+Shift+右键】,显示右键 =>在此处打开命令窗口(&W)
	【Ctrl+Shift+F10】调用控制台
	【Ctrl+Shift+F12】打开或关闭左面侧边栏
	【Shift+F6】重命名
	【F5】 复制
	【F6】移动
	【Ctrl + D】复制当前行
	【Ctrl + Shift + Enter】下面插入空行
	【Ctrl + 鼠标左键】点击引入模块,可确认是否引入正常
	【Ctrl + Shift + F4】关闭控制台当前选中选项卡
	【Ctrl +  F4】关闭当前代码选项卡窗口
	【Ctrl +  Alt + L】格式化代码
	【Ctrl +  F5】刷新服务 ←注:每次更新server服务后保存后都要刷新服务后,才能显示效果
	【Ctrl +  F2】停止服务


	在html文件内
	【Alt + F2】 再Enter回车,打开浏览器


	W3C离线手册搜索[mime]

	

	git config --global user.name 'dzk'


【node】【node.js】
___________________________________________________________

【bootstrap】【引导,框架】波特晒木
波特四抓


外部调用自己写的css
1.能设置buuton字体font,颜色,大小,类型，背景色,边框覆盖颜色，但不能设置默认鼠标不点击窗口的边框。

流式就是百分比的



定义了一个容器,
		两种容器: 【container-fiuid】
		【container】固定宽度容器,大型屏幕上两边有边距

【1. Bootstrap库的简介和配置】

	【什么是bootstrap?它的作用?做什么?】
	Bootstrap是一个前端UI库,利用bootstrap我们可以快速,高效的实现同时适配PC端和移动端的网站

		提供了以下功能:
			新的样式:让我们的网页更美观
			新的组件:很简单实现一个常用功能,例如下拉菜单,响应式导航栏等
			新的布局方式:使用网格系统布局,网页具有响应式效果(以前div+css)

	【使用bootstrap写一个helloworld】
		导入库: 先把bootstrap的库文件放在工程里面
		学习

		网页的前面:导入Bootstrap.min.css
			       jquery.min.js
			       bootstrap.min.js
		注意:jquery.min.js在bootstrap.min.js之前导入
【Bootstrap的网格系统】
	【什么是网格布局系统?】

基础知识:
	网格是平面内的概念,类似于棋盘,一个网格系统由多条横轴和纵轴构成,构建网页的时候,以前我们使用div+css构建,现在由bs提供网格系统
	网格系统的4种屏幕
超小型设备:xs: 宽度: 0~768px
		例如手机
	小型设备:sm: 宽度: 768px~992px
		例如平板
	中型设备:md: 宽度: 992px~1200px
		例如电脑
	大型设备:lg: 宽度: 1200px~......
		例如一些大屏电脑

	网格系统如何构成?
		最外层是一个容器
			每个容器中包含 多行
				每行中包含多列
					每列中添加标签,或则添加子网格(多行中包含多列)

【网格系统实例】
把握一个度:哪些地方用网格,哪些地方用普通div
		分析:一些大的模块使用网格,具有响应式效果
			一些网格内的内容,使用普通的div实现布局

		结构:
			container
				row
					col
				row
					col
						再加row->row
					col
						直接加普通的div
				row
					col
【响应式原理】
	【媒体查询】
	使用bootstrap的媒体查询
	【@media】
		要记住一句话,非常重要
		习惯用普通的if判断,就要把思维倒过来
		【max-width最大宽度就是最小宽度,min-width最小宽度就是最大宽度】
	container
		row行
			col-md-1(1~12)
	@media媒体查询是css3提供的新功能,利用媒体查询,实现不同的大小的屏幕上,显示不同样式的网页
	bootstrap依赖系统提供媒体查询功能
【网格的嵌套】
	网格结构:
		container
			row
				col
				col
			row
				col
					放什么?
					能放是row和一般的标题,例如div
					不能放:再放col
				col
			row
				col

	【container】自带居中和内col-md(1~12)左右padding，不需要可以手动在css去掉
		container容器
	【container-fluid】流媒体布局，和container最大不同，就是流媒体布局铺满全屏，不带居中和padding。
		fluid流体

【颜色】:
	【bg-info】水蓝
	【bg-success】绿色
	【bg-danger】 粉色
	【bg-primary】浅粉

【移动位置】
	【单个网格移动】
	【col-md-pull-1(1-12)】往左移动
	【col-md-push-1(1-12)】往右移动
pull拉,拉过来
push推
	【整行网格偏移】
	【col-md-offset-1(1-12)】


【列的定位(排序)】
	push: 向右推,不影响其他的列位置
		【col-md-push-0】
		【col-md-push-1】
		......
		【col-md-push-12】
	pull: 向左拉,不影响其他的列位置
		【col-md-pull-0】
		【col-md-pull-1】
		......
		【col-md-pull-12】
【列的偏移】
	offset: 向右偏移,影响其他的列位置
	【col-md-offset-0】
	【col-md-offset-1】
	......
	【col-md-offset-12】
【设置窗口】
mate设置元数据
		宽度为设备宽度
		设置缩放 - 初始值1,最大值1,最小值1,禁止用户缩放
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
	viewport
	device 设备
	initial 最初的
	scale规模
	minimum最低限度
	maximum最大限度
	scale规模
	//http-equiv 回传给浏览器的信息
	<meta http-equiv="Cache-Control" content="public">
	
	【width=device-width】页面大小屏幕等宽(宽度等于设备的宽度)
		如果屏幕小于页面宽度，会自动缩放到屏幕宽度

	【initial-scale=1.0】设置页面的初始缩放值
		初始缩放比例，1.0表示原始比例大小

	【minmum-scale=1.0】允许用户的最大\小缩放值
		允许缩放的最小比例
	【maxmum-scale=1.0】允许用户的最大缩放值
		允许缩放的最大比例

	【user-scalable=no】否允许用户进行缩放,值为"no"或"yes",no代表不允许,yes代表允许
		用户是否可以缩放，这里no表示不可以

	jQuery在移动端后有300毫秒延迟,缩放可以解决


	一般情况下,写bootstrap的网页,都加上是视口的设置,对PC端网页没什么影响,移动端解决一些问题
【padding】
	列col-md-1默认对子级有内边距,如果不想要的话,直接用class
		padding:0;就好

【行列的margin和padding】
	正常情况下,网格布局中列的左右两边都有默认的padding,布局需要注意:如果需要padding,使用默认,不需要,使用CSS去去除指定的col的padding

【可见性】
	【hidden-md】 隐藏
	【visible-lg】 显示
	visible看得见
	
	【要想让指定元素在放大显示,缩小隐藏】
在列的class内添加
		【visible-md visible-lg】记得用空格分开,不要连在一起

	【要想让指定元素在缩小显示,放大隐藏】
	必须在要隐藏的列的class的行添加
		【col-md-1 col-md-push-7】
	在要缩小显示元素class内添加
		【hidden-md hidden-lg】

	【visible-xs】只在xs上显示
	【visible-sm】 只在sm上显示
	【visible-md】 只在md上显示
	【visible-lg】 只在lg上显示

	联合使用: 【visible-md visible-lg】
	作用:只在md和lg上显示,其他上隐藏

	【hidden-xs】 只在xs上隐藏
	【hidden-sm】 只在sm上隐藏
	【hidden-md】 只在md上隐藏
	【hidden-lg】 只在lg上隐藏

	联合使用: hidden-md hidden-lg
	作用:只在md和lg上隐藏,其他上显示


【简介】
	系统原生的标签的样式非常简单,bs对这些标题做了优化和美化,添加很多比较大气美观的样式

【标题】
	原生的标题字体较粗,副标题较大
	bs的标准字体较细,副标题较小

【bs列表】
	【list-unstyled】 可以加在ul上,无样式列表
	【list-inline】 可以加在ul上,水平列表
	【list-horizontal】 可以加在dl上,水平定义的列表
		horizontal 水平的

【bs表格】
	【table】改变默认表格样式
	【table-striped】隔行变色
		striped有条纹的
	【table-hover】选中变颜色
	【table-bordered】加入边框
	【table-condensed】紧凑高度

	主要样式:
	最基本的: 表格添加样式"table",行列右边距,看起来大气

	【table-striped】 背景色交替,灰白灰白......

	【table-bordered】添加外边框

	设置背景色
	【bg-info】
	【bg-success】
	【bg-danger】
	【bg-warning】

	【table-hover】 添加鼠标悬停效果,经过的行背景色变灰
	【table-condensed】 紧凑表格,行高较以前的小一点

【bs表单】
	【form-group】给外层用户名,密码输入框div添加class
		group组
	【form-control】 给内部input添加类,占满全屏
		control 控制
	【form-inline】在form表单添加class,水平定义
		in内

	1.for添加class【form-horizontai】 form表单设置
 	2.lable内放在外层div内,class写【col-md-2 control-lable】
	3.把input放在一个外层div里,class写【col-md-10】
	4.把button放在一个外层div里,class写【col-md-10】
	想要居中,button内加个【btn btn-success btn-block col-lg-offset-1】
 
	结构 :
		form
			div
				label
				input
			div
				label
				input
			div
				label
				input
	普通表单样式
		【form-group】 加在form的div上
		【form-control】  加在input上,宽度变为100%,样式改变
			control 控制

	内联表单
		【form-innline】 所有的空间水平排布
	水平表单
		【form-horizontal】 加载form上,表示设置为水平表单
		【control-label】 加载label,label靠右显示



【bs按钮】
	样式:
		【btn】 基本样式
		【btn-default】 默认样式,白色
		【btn-primary】 主要样式,蓝色
			primary主要的
		【btn-info】 信息按钮,浅蓝
		【btn-success】 成功样式,绿色
		【btn-danger】 危险样式,红色
		【btn-warning】 警告样式,黄色
		【btn-link】 链接按钮,没有边框,蓝色文字

		【btn-xs】 超小型按钮
		【btn-sm】 小型按钮
		【btn-md】 普通按钮
		【btn-lg】 大型按钮

		btn-block 块状按钮

【bs图像】
	【img-rounded】圆角矩形图片 border-radius:5px;
	【img-circle】 圆形图片 100%
	【img-thumbnail】略缩图图片,两边多padding和边框
		thumbnail极小的
	【img-responsive】响应式图片随着分辨率大小改变
		responsive响应的

【bs文本】

	【text-left】 文本居左
	【text-center】 文本居中
	【text-right】 文本居右

	【text-muted】 减弱
	【tetx-primary】 主要
	【text-info】 信息
	【text-success】 成功
	【text-danger】 危险
	【text-warning】 警告


	【text-lowercase】 小写
	【text-uppercase】 大写
	【text-capitalize】 单词首字母大写

【bs背景颜色】
	【bg-info】
	【bg-success】
	【bg-primary】
	【bg-danger】
	【bg-warning】
	【bg-inverse】灰白


【bs位置控制】
	【pull-left】 靠左
	【pull-right】 靠右
	【center-block】 居中
【bs显示控制】
	show 显示
	hidden 隐藏
	
【4. Bootstrap的组件】
【bs图标】
	bootstrap提供了很多图标,都是已字体的形式存在

	注意: 使用注意导入 fonts文件夹路径,注意位置

	使用形式:
	<span class="glyphicon glyphicon-play"></span>
	能使用哪些图标?
		看文档

	【glyphicon-time】小时钟

【bs下拉菜单】
	快捷键:bsxlcd
	DOM:
		div
			button
			ul
				li 菜单1
				li 菜单2
				li 菜单3
		重要的类:
			【class="dropdown"】 加在最外层div上,表示是一个下拉菜单
			【class= "dropdown-menu"】 加在下拉的菜单上,表示是菜单
			【data-toggle="dropdown"】 加在按钮上,起到切换的作用

	1.外层必须添加一个div,添加class名【dropdown】
	2.内部有两个div或button和ul都可以,【总之要有两个标签存放】
	3.第一个标签属性内写【data-toggle="dropdown"】,第二个标签class写【dropdown-menu】就完成了
	<div class="dropdown">
		<div data-toggle="dropdown">
			下拉头部
		</div>
		<div class="dropdown-menu">
			下拉菜单
		</div>
	</div>

drop落下
menu菜单

【bs输入框组】
	快捷键:bssrkz

	DOM:
		div
			span
			input
	重要的类:
		【input-group】 表示输入框组
		【input-group-addon】 输入框附件元素
		【form-control】 表单中的控件

	<div class="input-group">
		<input type="text" class="form-control">
		<span class="input-group-addon">.00</span>
	</div>

【bs导航元素】
	快捷键:bsdhys
	DOM:
		ul
			li
			li
			li
	重要的类:
		【nav】 表示导航,默认是竖直显示的
		【nav-tabs】 水平的导航

		【active】(li上加),表示激活的项

【bs导航栏】
	快捷键:bsdhl
	DOM:
		div
			div
				div
				div
	重要的类:
		【navbar navbar-default】 导航栏样式
				【navbar-inverse】 黑色
				bar棒
		【container-fluid】 流式布局(两边不像container有边框)
		【navbar-header】 头部
		【nav navbar-nav】 导航的一些元素 ,取消后默认全部往下

		【navbar-left】往左移动
		【navbar-right】往右移动

		【nav-pills】固定背景色
			pills药丸
【bs响应式导航栏】
	快捷键:bsxysdhl
	DOM:
		div 导航栏
			div 容器
				div 头部

				div折叠的div

	重要的类:
		表示导航栏
		【navbar navbar-default】

		表示容器
		【contaitainer-fluid】

		表示导航栏头部
		【navbar-header】
		按钮,点击显示或隐藏data-target指向的标签
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#example-navbar-collapse">

		可能折叠的div,collapse表示折叠
		<div class="collapse navbar-collapse" id="example-navbar-collapse">

	【nav navbar-nav】清除导航的ul的list-style为none


【bs分页】
	快捷键:bsfy

	DOM：
		ul
			li
			li
			li
			li
	重要的类：
		【pagination】

		【&laquo;】<<
		【&raquo;】>>

【bs多媒体】
	快捷键:bsdmt
	DOM:
		div
			a
			div
				h3
				p
	重要的类：
		【media】 表示多媒体
		【media-object】 媒体对象-图片
		【media-body】 多媒体内容
		【media-heading】 头部



【bs列表组】
		快捷键:bslbz

	DOM：
		ul
			li
			li
	【list-group】 表示列表组
	【list-group-item】 表示列表组每一项
【bs面板】
		快捷键:bsmb
	div
		div
		div
	重要的类:
	【panel panel-default】 控制面板的样式
	【panel-heading】 头部
	【panel-body】 内容

【bs警告】
		快捷键:bsmb
	DOM：
		div
			button
	重要的类:【alert-success】 设置警告的样式
	
	属性：
		【data-dismiss="alert"】 控制点击后隐藏
		dismiss解雇，驳回
【bs巨幕】
快捷键:bsjm
	div class="container"
	div class "jumbotron"
	【container】 容器 外层div添加，用于居中整个页面
	【jumbotron】 内层div
	
	做流媒体页面时，不要在【jumbotron】巨幕外层加【container】，否则会撑开宽度滚动栏
	
【bs略缩图】
	快捷键:bslst

	DOM:
		div
			img
			div

	重要的类：
		【thumbnail】 略缩图
		【caption】 提示
【bs面包屑】

		快捷键:bsmbx

	DOM：
		ul
			li
			li
			li

	重要的类：
		【breadcrumb】 表示面包屑


【Bootstrap的插件】【bs的插件】

	【轮播】
		快捷键:bslb
	DOM:
		div 轮播组件
			ol 提示的几个点
			li 每个点
			li
			li
			li
		div 显示图片的区域，几个图片，里面就放几个div
			div
			div
			div
			div
		a 前一个图片-按钮
		a 后一个图片-按钮
		重要的类:

		【carousel slide】 表示轮播

		【carousel-indicators】 表示轮播的提示(小圆点)

		【carousel-inner】 放置图片

		【carousel-control left】 左边控制按钮
		【carousel-control right】 右边控制按钮
	重要的属性:
		data-slide-to="0" 表示切换到第几张图片

	初始化:
		其中参数可有可无,主要设置轮播间隔时间
		$('.carousel').carousel({		
				interval : 2000
			})

	【bs模态框】
		快捷键:bsmtk
	DOM:
		button

		div -弹出框-对话框本身
			div 弹出框-内容
				弹出的内容
	重要的类:
		再要点击的button属性内添加【data-toggle="modal" data-target="#myModa2"】
		

		在要显示的提示框div内:
			【class="modal fade" id="myModa2"】
		【fade】褪去，缓慢显示，这个可以不用写，其他都必须写，否则不生效
			提示框内部div内添加类名【modal-dialog】，否则会铺满全屏
				再在里面添加div，添加类名【modal-content】，如果没添加，会没有背景

		最后里面添加head，body和footer的div，可以自定义内容
		标题div的class添加【modal-header】内部可以更改
					头部div内添加button，添加属性【class="close" data-dismiss="modal"】
				【close】是往右移
					关闭
				【data-dismiss="modal"】是点击后关闭
					dismiss解雇
				aria-hidden="true"没什么用

		内容div的class添加【modal-body】内部可以更改
		底部div的class添加【modal-footer】内部可以更改

	【bs标签页】【bs选项卡】
		快捷键:bsbqy
	DOM:
		ul所有标签
			li 一个标签
			li
			li
		div 切换的内容的容器
			div 需要切换的第一个界面
			div 需要切换的第二个界面
			div 需要切换的第三个界面
	重要的类:
		li下添加a标签
		<a href="#page1" data-toggle="tab">
		【data-toggle="tab"】必须在a标签写，否则不生效
		在href内必须添加描文本，#ID【#page】
			
		<div class="tab-content">
			在切换内容div内添加【tab-content】类
		在切换内容下第一个div添加类为【tab-pane in active】
			【class="tab-pane in active" id="page1"】
		从第二个或以上div的话
			【class="tab-pane" id="page2"】
			
	【bs折叠】

		快捷键:bszd

	DOM：
		div 折叠组件本身
			div折叠的头部,一直显示
			div 折叠的内容,默认不显示,点击后显示


	重要的类:
		【panel panel-default】 折叠风格
		【panel-heading】 头部
		【panel-title】 标题
		【panel-collapse collapse】 折叠内容的风格







Snippets【片段】
templates
plates【盘子】


bootstrap和我自己的all.css库的wp有冲突
	如果使用wp就固定了宽度,就无法使用响应式布局,只要把wp替换成row就好,至于其他布局,再稍微改一下就好



=======================================================================
【mui】[mui]
	→ 导航栏-界面结构
		导航栏  mHeader
		标签栏 mTab
		主体   mBody
			其他标签放里面
	
			header 表示导航栏整体
				a 左侧按钮
				h1 标题
				a 右侧标签
			style:
				【mui-bar】表示栏样式,【mui-bar-nav】表示导航栏样式
				【mui-action-back】 就能返回上个界面
				【mui-icon mui-icon-left-nav】 设置图标
				【mui-pull-left】 图标居左
				【mui-pull-right】 图标居右
				

	【mui-content】内容设置
	按钮设置
	【mui-btn】必须添加,声明类型
	【mui-btn-block】设置全屏样式
	【mui-btn-success】设置成功 绿色样式
	【mui-title】设置标题文字

	【mui-icon-left-nav】返回上一页箭头
	【mui-action-back】选择 后退

	【mui-icon-trash】垃圾箱
	【mui-icon-upload】方块加上箭头
	【mui-icon-download】方块加下箭头
	【mui-icon-close】圆X关闭
	【mui-icon-closeempty】x关闭
	【mui-icon-redo】箭头返回右
	【mui-icon-undo】箭头返回左
	【mui-icon-refresh】返回箭头
	【mui-icon-refreshempty】半圆刷新
	【mui-icon-reload】全圆刷新
	【mui-icon-loop】全圆刷新
	【mui-icon-spinner mui-spin】黑白全圆刷新
	【mui-icon-spinner-cycle mui-spin】正在加载图标
	【mui-icon-star】空星五角星
	【mui-icon-starhalf】半黑半白五角星
	【mui-icon-plus】圆,里有+
	【mui-icon-plusempty】+
	【mui-icon-minus】圆,里有-
	【mui-icon-checkmarkempty】√图标
	【mui-icon-search】搜索图标
	【mui-icon-home】首页图标
	【mui-icon-navigate】航行图标
	【mui-icon-gear】设置图标
	【mui-icon-settings】菜单图标
	【mui-icon-list】黑色菜单图标
	【mui-icon-bars】普通三条线设置图标
	【mui-icon-paperplane】
	【mui-icon-info】白飞机图标
	【mui-icon-help】圈?图标
	【mui-icon-locked】锁图标
	【mui-icon-more】三个空圆图标
	【mui-icon-locked】白锁图标
	【mui-icon-flag】白旗图标
	【mui-icon-paperclip】收藏,像发卡图标
	【mui-icon-back】左上一页黑箭头
	【mui-icon-forward】右下一页黑箭头
	【mui-icon-arrowdown】下灰箭头
	【mui-icon-arrowleft】左上一页灰箭头
	【mui-icon-arrowright】右下一页灰箭头
	【mui-icon-arrowthinup】上灰箭头
	【mui-icon-arrowup】上黑箭头
	【mui-icon-arrowdown】下黑箭头
	【mui-icon-arrowleft】上灰箭头
	【mui-icon-arrowright】跳转下一页灰箭头
	【mui-icon-arrowthinup】上灰箭头
	【mui-icon-arrowthindown】下灰箭头
	【mui-icon-arrowthinleft】左灰箭头
	【mui-icon-arrowthinright】右灰箭头
	【mui-icon-pulldown】下黑箭头

	行内使用onclick=使用【dealOpen()】就能跳转到下一页

	→ 标签栏-界面结构 md
		创建:
			mTab即可创建
			方便:mt1
			DOM:
				nav 标签项
					a 一个标签项
						span 图标
						span 标题
					a 一个标签项
						span
						span
					a 一个标签项
						spam
						span
					a 一个标签项
						spam
						span
			样式:
				【mui-bar mui-bar-tab】是个栏,是个标签栏 为nav添加
				【mui-tab-item】每一个标签项,为a标签添加
					item一条
				【mui-ico】为第一个span添加图标
				【mui-tab-label】为第二个span添加,把文字放到图标下面
				【mui-active】设置激活标签项


			内容div添加【mui-content】
			子节点的div添加【mui-control-content mui-active】
			【mui-control-content】把界面隐藏
				control控制
		
		→ 表格视图 ml1
		DOM
					ul	就是表格视图
						li
						li
						li
						li
						li
				格式:
					【mui-table-view】表示表格视图
					【mui-teble-view-cell】 表示单元格
					【mui-navigate-right】 设置右侧箭头
					【mui-icon-search】设置搜索箭头
					【mui-icon-personadd】+添加朋友头像

				作用:普通表格放里面,变圆角矩形表格
					【mui-card】替换mui-table-view
					
		→ 图文表格 ml3
		    	ul	表格
		    		li	单元格cell
		    			a 为了整个cell响应点击
		    				img cell上的图标
		    		li
		    		li
		    		li
		    		li
		    	样式:
		    		mui-media 表示带有媒体的对象
		    		mui-media-object cell中真正的媒体对象
		    		ui-media-body 除了图片之外的东西,文字
		    		mui-ellipsis 详情
		→ 图片轮播 ms2
		DOM:
		    		div	轮播
		    			div	放轮播图片
		    				div 第4张图(实现轮播)
		    				div 第1张图
		    				div 第2张图
		    				div 第3张图
		    				div 第4张图
		    				div 第1张图(实现轮播)
		    			div	放轮播图对应的小圆点

	常用快捷键:
		【mh1或2】header头部
		【mb1】数字角标无底色
		【mb3】body也就是内容
		【ml1】l就是table,也可能是list,出现表格视图的使用,ml1是普通列表
		【ml3】图文表格
		【ms2】轮播组件
		【mi4】搜索框
		【mi1】微信图标
		【mi2】文本框
		【mi3】带清除按钮的输入框
		【mi4】搜索框
		【mi5】语音输入
		【mb2】数字角标
		【mb4】块状按钮
		【mb5】普通按钮
		【mb6】按钮有底色,无边框
		
		【mt1】底部选项卡
		【mt2】底部div选项卡
		【mt3】可左右拖动选项卡

		【mo1】侧滑导航-主界面-菜单同时移动
		【mo2】主界面不动、菜单移动
		【mo3】主界面移动、菜单不动
		【mo4】缩放式侧滑（类手机QQ）

		【mp1】分页
		【mp2】弹出菜单
		【mp3】进度条,无限循环
		【mp4】进度条,有准确值
		【mp5】刷新容器

		【mr1】单选框
		【mr2】单选框居左
		【mr3】禁用单选框
		【mr4】默认选中指定项
		【mr5】Lable + 滑块
		【mr6】mui-row

		【ma1】折叠面板
		【ma2】h5模式弹出列表

		【ms1】mGallery-Table图文表格
		【ms2】mGallery图文轮播
		【ms3】mScroll 区域滚动
		【ms4】mscrollsegmented横向滚动,横向导航条
		【ms5】mSwitch开关 蓝色
		【ms6】mSwitch开关 绿色
		【ms7】mSwitch开关Mini-blue 开关左侧 蓝
		【ms8】mSwitch开关Min 开关左侧 绿
		【ms9】slide轮播组件
	
		【md1】DOM结构,htnl结构
		
		【mf1】表单和input,带右侧删除符号
		
		【mg1】九宫格
		
		【ml1】普通ul>li列表
		【ml2】图文列表,图标居右
		【ml3】图文列表,图标居左
			不想要表格默认底部边距
			.mui-table-view-cell{margin-bottom:0}
			不想要图片默认高
			.mui-table-view .mui-media-object{height:23px}
		【mc1】mCheckbox复选框
		【mc2】mCheckbox复选框居左
		【mc3】mCheckbox复选框禁用选项
		【mc4】mui-col-sm
		【mc5】mui-col-xs

		
		【mb1】mbadge(数字角标无底色)
		【mb2】mbadge(数学角标)
		【mb3】mBody(主体)
		【mb4】mButton(块状按钮)
		【mb5】mButton(按钮)
		【mb6】mButton(按钮无底色,有边框)

		【mn1】数字输入框


mui默认有权值,自定义class设置样式【width】,【height】,【background】,【border-radius】定位【right】 可能会不生效.所以后面都要加【!important】提升层级
	要不直接使用ID,提高层级




搭建本地服务器,使用【xampp】
XAMPP安装流程
				打开安装软件, 无脑下一步

			装好了服务器, 咱们的网页哪儿放?
				放在Web服务器网页文件根目录    htdocs

			如何访问
				本地:  本地IP: 127.0.0.1
						本地域名: localhost
						http://127.0.0.1/index.html

				局域网内: 使用对方的局域网IP访问
					192.168.0.3 局域网IP
					192.168.0.0 ~  192.168.255.255
					http://192.168.0.3/index.html

				整个地球的网络:
					条件: 要么是有 公网IP     202.201.33.25
					条件: 要么是有 公网域名	 www.zparkhr.com.cn

			默认首页
				服务器设置首页:  index.html index.php index.htm

	※注意:每次关机重启都要重新打开前三个服务,否则不生效,开机后关闭程序后,会继续在后台执行,所以还能使用

	搭建好tomcat服务器后
cmd粘贴ipconfig查看ip
	config配置


	artist艺术家,能手
	public 公众的
	interface界面,接口
	collect收藏
	details详情
	public 公众的
	favorite特别喜欢
	movie电影
	music音乐
	register登陆,注册


	JSON.parse(result).data.isFavorite 判断是否有收藏,默认为false


	在浏览器打开本地服务器css,js文件
	示范:
	view-source:http://192.168.0.100:8020/%E6%A3%AE%E5%B7%A2%E7%BD%91wap/css/index.css
	source根源


	orient标定方向
	vertical垂直的
	clamp加紧

【mui】[mui]
=======================================================================
	render提出
	example例子
	control控制,控件


var arr = [
	<li>aa</li>,
	React.createElement('li',null,'dd'),
]

	※注:在这里<li></li>标签其实是js对象,同等于React.createElement('标签名',null,'内容')


	//Hello组件
	var Hello = React.createClass({
		//组件的初始化方法
		//用户初始化状态state,其中初始化,使用this.state.xxx
		getInitialState:function(){
			//把name放到this.state
			return {"name" : "张三"}
		},
		//组件已经载入
		//作用:执行了之后,表示组件已经载入
		//以后组件内部网络下下载放在这里面
		componentDidMount : function (){
			console.log("componentDidMount");
		},
		
		//组件的渲染方法,必须的方法,所有的组建为了能够显示,必须提供这个方法,这个方法是由React库调用了	
		render : function (){
			var num = 20;
			return <div>hellow {this.state.name}{num}</div>
		}
	})


	ReactDOM.render(
		<div>hello world
		<Hello />
		</div>,
		document.getElementById("example")
	);

	【getInitialState】组件的初始化方法
		initial最初的
		state状况
	【componentDidMount】组件已经载入
		component组件
		did做
		mount安装

	【componentWillMount】组件即将加载
		Will即将
	【componentWillUnmount】组件即将销毁
	【getDefaultProps】组件载入的时候执行这个函数,获取到默认的参数

	【dealLeftClick】左侧按钮的事件处理方法
 	【dealRightClick】右侧按钮的事件处理方法

	react中的【return后面若想换行】.必须使用【()】大括号包起来
	再引入外部文件只要类型是【type="text/jsx"】,无论src引入的是什么后缀是什么【jsx,js,还是html】都能出现效果,这么一来就能使用html自定义的代码块功能了.这样不容易出错,即使没有高亮也行.宁可不看高亮,也要减少错误的可能性和几率.
	→【babel】嘈杂声,类型若jsx,HBuilder不显示,改成这个就会显示


四、【组件】
	React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类

	※注:组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。
	添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。

五:【this.props.children】
	组件的用法与原生的 HTML 标签完全一致，可以任意加入属性
	比如 <HelloMessage name="John"> ，就是 HelloMessage 组件加入一个 name 属性，值为 John。
	组件的属性可以在组件类的 this.props 对象上获取，
	比如 name 属性就可以通过 this.props.name 读取。上面代码的运行结果如下。

	循环遍历自己组件所有子节点
	React.Children.map(this.props.children,function(i){
		return 标签名包含{i}索引值
	}

	例子:
	var NotesList = React.createClass({
		render : function () {		
			return (
				<ol>
					{
						React.Children.map(this.props.children,function(i){
						return <li>{i}</li>
						})
					}
				</ol>
			)
		}
	});
	ReactDOM.render(
		<NotesList>
			<span>hello</span>
			<span>world</span>
		</NotesList>,
		document.body
	);

	上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取

	这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。
	React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。

七、【获取真实的DOM节点】
	组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM【virtual DOM】。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 【DOM diff】 ，它可以极大提高网页的性能表现。
	
	virtual虚拟

	点击按钮获取inout的焦点,这里
	【this.refs.这里定义ref名,可用中文.focus();】
	ref裁判
	var MyComponent = React.createClass({
		handleClick : function (){
			this.refs.myTextInput.focus();
		},
		render : function () {		
			return (
				<div>
					<input type="text" ref="myTextInput" name="" id="" value="" />
					<input type="button" name="" id="" value="Focus the text input" onClick={this.handleClick}/>
				</div>
			)
		}
	})

	上面代码中，组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。

需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。

	八、【this.state】
	组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI

	var LikeButton = React.createClass({
  getInitialState: function() {
    return {liked: false};
  },
  handleClick: function(event) {
    this.setState({liked: !this.state.liked});
  },
  render: function() {
    var text = this.state.liked ? 'like' : 'haven\'t liked';
    return (
      <p onClick={this.handleClick}>
        You {text} this. Click to toggle.
      </p>
    );
  }
});

ReactDOM.render(
  <LikeButton />,
  document.getElementById('example')
);
上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。

由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。
九、【表单】
var Input = React.createClass({
  getInitialState: function() {
    return {value: 'Hello!'};
  },
  handleChange: function(event) {
    this.setState({value: event.target.value});
  },
  render: function () {
    var value = this.state.value;
    return (
      <div>
        <input type="text" value={value} onChange={this.handleChange} />
        <p>{value}</p>
      </div>
    );
  }
});

ReactDOM.render(<Input/>, document.body);
	上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。

十、【组件的生命周期】
组件的生命周期分成三个状态：
	【Mounting】已插入真实 DOM
		mounting装备
	【Updating】正在被重新渲染
		updating更新
	【Unmounting】已移出真实 DOM
		unmounting更新装备
	React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。

	【componentWillMount()】组件 将会 载入
	【componentDidMount()】组件 已经 载入
	【componentWillUpdate(object nextProps, object nextState)】组件 将会更新 载入
	【componentDidUpdate(object prevProps, object prevState)】组件 做 更新
	【componentWillUnmount()】组件 将会 移除
此外，React 还提供两种特殊状态的处理函数。

	【componentWillReceiveProps(object nextProps)】已加载组件收到新的参数时调用
		receive收到
	【shouldComponentUpdate(object nextProps, object nextState)】组件判断是否重新渲染时调用这些方法 应该组件更新

var Hello = React.createClass({
  getInitialState: function () {
    return {
      opacity: 1.0
    };
  },

  componentDidMount: function () {
    this.timer = setInterval(function () {
      var opacity = this.state.opacity;
      opacity -= .05;
      if (opacity < 0.1) {
        opacity = 1.0;
      }
      this.setState({
        opacity: opacity
      });
    }.bind(this), 100);
  },

  render: function () {
    return (
      <div style={{opacity: this.state.opacity}}>
        Hello {this.props.name}
      </div>
    );
  }
});

ReactDOM.render(
  <Hello name="world"/>,
  document.body
);
	上面代码在hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。
	另外，组件的style属性的设置方式也值得注意，不能写成
	style="opacity:{this.state.opacity};"
	而要写成style={{opacity: this.state.opacity}}
这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。
十一、【Ajax】
件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI （查看 demo11 ）。


var UserGist = React.createClass({
  getInitialState: function() {
    return {
      username: '',
      lastGistUrl: ''
    };
  },

  componentDidMount: function() {
    $.get(this.props.source, function(result) {
      var lastGist = result[0];
      if (this.isMounted()) {
        this.setState({
          username: lastGist.owner.login,
          lastGistUrl: lastGist.html_url
        });
      }
    }.bind(this));
  },

  render: function() {
    return (
      <div>
        {this.state.username}'s last gist is
        <a href={this.state.lastGistUrl}>here</a>.
      </div>
    );
  }
});

ReactDOM.render(
  <UserGist source="https://api.github.com/users/octocat/gists" />,
  document.body
);
上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库。

我们甚至可以把一个Promise对象传入组件，请看Demo12。


ReactDOM.render(
  <RepoList
    promise={$.getJSON('https://api.github.com/search/repositories?q=javascript&sort=stars')}
  />,
  document.body
);
上面代码从Github的API抓取数据，然后将Promise对象作为属性，传给RepoList组件。

如果Promise对象正在抓取数据（pending状态），组件显示"正在加载"；如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。


var RepoList = React.createClass({
  getInitialState: function() {
    return { loading: true, error: null, data: null};
  },

  componentDidMount() {
    this.props.promise.then(
      value => this.setState({loading: false, data: value}),
      error => this.setState({loading: false, error: error}));
  },

  render: function() {
    if (this.state.loading) {
      return <span>Loading...</span>;
    }
    else if (this.state.error !== null) {
      return <span>Error: {this.state.error.message}</span>;
    }
    else {
      var repos = this.state.data.items;
      var repoList = repos.map(function (repo) {
        return (
          <li>
            <a href={repo.html_url}>{repo.name}</a> ({repo.stargazers_count} stars) <br/> {repo.description}
          </li>
        );
      });
      return (
        <main>
          <h1>Most Popular JavaScript Projects in Github</h1>
          <ol>{repoList}</ol>
        </main>
      );
    }
  }
});

	this.props.promise.then(
	value => this.setState({loading: false, data: value}),
	error => this.setState({loading: false, error: error}));
	这个没看懂，this.props.promise.then是什么意思？

	.then()是jquery的方法，参数(success(),error())
	=>是es6语法，我理解为
	componentDidMount() {
		this.props.promise.then(
		function(value){
			this.setState({loading: false, data: value})
		}.bind(this),
		function(error){
			this.setState({
				loading: false, error: error
			}
		)}.bind(this)
	)


	【source】根源,从什么获得 ,可在组件属性添加source="https://api.github.com/users/octocat/gists"获得数据
	【handle】操作

	【this.isMounted()】判断是否有载入状态,在if语句使用
		mounted安装,载入
	stars星
	Native当地的
	

	由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。

	props,在这里很常见的用法是传参,显然形参你改了也没用,而state这个属性就要好好把玩了,也说了,交互中很常见的状态

	只要调用setState 方法,就会自己调用 render 方法,重新渲染组件

问题:能否解释下 第十个Demo中的isMounted方法的作用和意义？谢谢。
回答:只有组件还处于挂载状态下，才有setState从而更新视图的意义。


	Demo2 控制台报错
	Each child in an array or iterator should have a unique “key” prop
	解决办法只要在循环的每个子项添加一个key就行了，代码如下：
	var names = ['Alice', 'Emily', 'Kate'];
		ReactDOM.render({
			names.map(function (name, key) {
			return Hello, {name}!
		})
		},
		document.getElementById('example')
	);

	您好，我在执行demo2/inde.html时，报错如下Warning: Each child in an array or iterator should have a unique "key" prop. Check the top-level render call using <div>. See https://fb.me/react-warning-keys for more information.
虽然对页面显示没有影响，但是我想知道为何会报这样的错误，以及如何解决？
我有试着百度结果，但是最终还是没有解决，希望您能够抽空解答一下，谢谢……

	由于React注重UI效率，使用Virtual DOM Diff来提高效率，最小化Html DOM渲染开销，所以遇到DOM nodelist时期望每个node有个key来做引用标识, 这仅仅是一个Warning，一般不会对你的App功能造成影响，但是应该注意此类问题，大规模View中可能会引发性能问题。
	解决此问题的方法就是给你的Virtual DOM Nodelist中每个Node加唯一的key标识。

	{List.map(function(item){
  		return (<li key={"Item-"+item.id}>{item.name}</li>);

	})}

	只有组件还处于挂载状态下，才有setState从而更新视图的意义。
	说通俗点，就是当组件渲染完成之后才设置组件的形态（以免get返回数据快过组件渲染速度，造成无法设置组件形态。）

说实话，目前react是最靠谱的web ui组件化方案了。
1.React的组件化才是web ui部件的正确方向

1.1.组件化集成html ,css,js自我包含一体化，方便复用。

不鼓励使用mvc模式。或者组件内部使用mvc来分离ui与js，但整个page页面是不提倡mvc的。。

1.2.相比angular。Js方便好用

2.React的问题与改进：

2.1. 可视化模板不容易得到dw的支持。。

作为模版，得到类似dw 这类可视化Html ide的支持的是必须的。。

改进建议：使用html文件作为组件，小型组件可以使用ajax读取载入，这样组件可以方便dw的设计。。大型组件可以使用ajax载入，也可以iframe方式载入。。

2.2.组件的html与js的集成是以js为基础的

这导致了界面可视化设计极差。。应该以html dom为基础，在html的基础上内嵌js。。Js本身就是代码，可视化要求相对较低。。Dom 标签使用常用的class 增加一个特点的oocss class来表明一个组件的类型，以及复合组件，或者可增加一个扩展属性。。

2.3.组件的属性以js为主

这带来查看属性值的调试的问题，如果可以在html标签上扩展属性，就方便调试，毕竟浏览器查看工具可以一目了然的查看属性的值


看不懂demo10里面
render: function () {
return (
<div style={{opacity: this.state.opacity}}>
Hello {this.props.name}
</div>
);
}
这儿style赋值为什么是双括号呢。。

写成这样是就清楚些了：
render: function () {
var style= {
opacity: this.state.opacity
}
return (
<div style={style}>
Hello {this.props.name}
</div>
);
}

外层括号是选择jsx变量，内层以及其中的内容表示一个对象，与上述的style对象作用相同
========================================================================
	bind()是ES5的方法，所以想兼容浏览器，需要自己写一个bind()函数。

	this.props 是组件被引用时在组件自身内部 用 this.props 接收 当前自身的所有属性value
	this.state 是组件自身内部操作

	class 和 for应该是ES6(ECMAScript 6)的保留关键字比较好点

	react最主要五大状态:
		一:创建组件类
		二:初始化状态
		三:载入状态
		四:更新视图
		五:加载视图
		六:显示页面





MVC 框架

=======================================================================
【MongoDB】[MongoDB]
## 什么是MongoDB
> 1.mongodb 是一个基于分布式文件储存的开源数据库
> 2.mongodb 将数据存储为一个文档(json) 数据结构是由键值对(key=value)组成
> 3.mongodb 文档类似于json 对象,字段可以包含对象 数组.

## 2.mongodb的安装
    64位安装 64位
    32为安装 32位
    默认安装

## 3.mongodb的启动
+ 默认路径 C:\Program Files\MongoDB\Server\3.4\bin
+ 按住shift键 右键在此处打开命令窗口
+ 除在 C盘以外 新建一个空的目录 例如: D:\MongoDB\data

## 4.启动 mongdb 服务器
+ 在命令行中输入mongod --dbpath=E:\MongoDB\data
       mongod --storageEngine mmapv1 --dbpath=E:\MongoDB\data
## 5.mongdb 默认端口 27017
    成功启动的标志 waitiong for connections on port 27017

## 6.启动mongodb的客户端
+ mongo
+ 有大于号时 成功启动

## 7.mongodb中的一些基本概念
+ 数据库 : 数据库是有集合组成
+ 集合: 集合文档组成,一个集合可以表示一个实体
+ 文档 : 文档就是一条记录,比如一个同学的信息可以当做一个文档

## 8.数据库的实际操作
+ 1.查看所有数据库 show dbs
    默认数据库 3.4 admin local 默认不使用它们
              3.2 local
+ 2. 创建数据库 : use 数据名称 例如 use student 创建学生数据库

+ 3. 查看当前数据库 : db(回车就可以)

+ 4. 创建集合 : db.createCollection('person');

+ 5. 查看当前集合 : show collections

+ 6. 集合下创建记录 :  db.h75.insert({})
    db.h75.insert({name:'姓名',age:1,height:180});
    db.h75.insert({name:'姓名2',age:25,height:182});
+ 7 查看所有记录 : db.集合名.find();
     例如:db.h75.find();

+ 8 怎么删除一个记录: db.h75.remove({});

+ 9 查看帮助: db.集合名.help();

+ 10 查找集合下的记录
    10.1 通过指定属性查找:db.h75.find({height : 182})
    10.2 只查找一条记录 : db.h75.findOne({height : 182})
    10.3 查询年龄大于25的记录:db.h75.find({age:{$gt : 25}})
    10.4 查询年龄大于等于25的记录 : db.h75.find({age:{$gte:25}})
    10.5 查询年龄小于25的记录 : db.h75.find({age:{$lt:25}})
    10.6 查询某条属性小于或等于多少的记录 : db.h75.find({age:{$lte:25}})
    10.7 查询大5岁 小于三十岁 : db.h75.find({age:{$gt:5,$lt:30}});
    10.8 查询年龄是25岁或者50岁 : db.h75.find({$or:[{age:25},{age:50}]});
    10.9 每一展示五条数据 : db.h75.find().limit(5);
    10.10 跳过前5条 展示剩下的数据:  db.h75.find().skip(5);
           db.h75.find().skip(10).limit(5); //跳过前十条,展示后5条

+ 11 更新记录 :  db.h75.update({'name' : '姓名'},{$set : {age : 15}});


=======================================================================
文本内容:
#002240
0 34 64

选中行代码颜色:
#643F2C 
100 63 44

html标签颜色:
#87FFFF
135 255 255

字符串和""和''的颜色
#31D900
49 217 0

当前选中行
#00182D
0 24 45


html注释颜色:
#0088C5
0 136 197



js赋值颜色
#FF628C
255 98 140



常用分析Bootstrap方法
首先布局:
	外层div添加container非流媒体布局






css面试题
怎么让一个不定宽高的 DIV，垂直水平居中

[div居中][css水平垂直居中][css水平居中][css垂直居中][css垂直居中图片][css水平居中图片][css居中图片][css居中定位]

第一种:给子节点居中 ,自身不居中
父级div添加:
	display:table-cell;
        vertical-align:middle;
        text-align: center; 
	→【优点】:子节点下img,a,p,h1文本内联元素都居住
	→【缺点】:父级div固定高宽,子级下div块集元素垂直不居中


第二种: ←推荐 响应式
父级:
	 position:relative;
子级:
	 position:absolute;
         top:50%;
         left:50%;
         margin:-高2分之一 0 0 -宽2分之一;
	→【优点】:支持自身在父级水平/垂直居中
	→【缺点】:只支持在父级本身div水平/垂直居中,不支持以下内容居中

第三种:←推荐 响应式
父级
	position:relative;
子级:
    	position:absolute;
    	top:0;
    	left:0;
    	bottom:0;
    	right:0;
    	margin:auto;
	→【优点】:同样支持自身在父级水平/垂直居中
	→【缺点】:只支持在父级本身div水平/垂直居中,不支持以下内容居中

第四种: ←推荐 响应式 但不兼容IE8以下,要考虑情况使用
	让div本身在父级居中,但不支持子级的文本
父级:
	  position:relative;
子级:
	 position:absolute;
         top:50%;
         left:50%;
         transform:translate(-50%,-50%)
	→【优点】:支持自身在父级水平/垂直居中
	→【缺点】:只支持在父级本身div水平/垂直居中,不支持以下内容居中,不支持IE8以下,要注意.


	→※:第一种不能和以下三种混用,因为会优先第一个.固定高宽,这样做流媒体和响应式布局非常不便


	【hack】
	_属性名 IE6支持
	+属性名	IE6,7支持
	*属性名 IE6,7支持
	*+ 选择器 IE7支持
	属性值\0 IE8和以上支持
	属性值\9 只有IE全版本能支持
	:root 选择器 高级浏览器都支持
	@-moz-document url-prefix() {
		选择器{属性名:属性值;}
	}
	prefix前缀

	@media screen and (-webkit-min-device-pixel-ratio:0) {
		选择器{属性名:属性值;}
	}
	screen屏幕
	device装置
	pixel像素
	ratio比例


	第五种: ←给子级 块集/内联元素水平/垂直居中
	display:inline-block;
	text-align:center;
	vertical-align:middle;


	【@media】多媒体查询
	@media (max-width:640px) {}
	@media (min-width:640px) and (max-width:768px) {}
	@media (min-width:768px) and (max-width:1000px) {}
	@media (min-width:640px) and (max-width:1000px) {}
	@media (min-width:1000px) {}
	→※:注:不设置高度,直接使用overflow:hidde;在多媒体查询设置时,会不生效,所以必须设置高度才能使用多媒体设置

	github托管平台

	目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。

	四种布局:
		【自适应布局】
		【流媒体布局】
		【响应式布局】
		【弹性布局】
	

	【固定 Fixed】
使用 px 和 pt 这样的绝对单位进行固定布局。在无论什么设备上保持固定的尺寸，在不适合的分辨率下可能导致大面积空白或横向滚动条。最经典，也是被证明极其不友好、维护困难的方法。
	【流动 Fluid
使用 % 百分比进行相对布局。可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。某些情况下可能导致错误的伸缩或者布局被破坏。
	【弹性 Elastic】
使用 em 或 rem 单位进行相对布局。避免了根据 px 布局在高分辨率下几乎无法辨认的缺点，又相对 % 百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示。需要一段时间适应而且不易从其他布局转换过来，但几乎是目前最好的布局方式。
	【伸缩 Flexbox】
使用 CSS3 Flex 系列属性进行相对布局。对于富媒体和复杂排版的支持非常强大，但是还未普及并且兼容性较差。
	【响应式 Responsive
使用 @media 媒体查询 给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，但是在同一个设备下实际还是固定的布局，并且因为浏览器的支持原因对介质的检测还不实用。
	【自适应 Adaptive】
通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是利用响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术综合统称。自适应几乎已经成为优秀页面布局的标准。

弹性布局在一众相对布局中毫无疑问拥有极大的优势。除了以上提到的几点之外，以下几点也是非常有用的特性：

	【优秀的兼容性】
不同于 FlexBox 等初生标准，浏览器对于 em 的支持非常的好，同时对于 rem 的支持也比预料中稍佳。如果使用 LESS 或者 SASS 等 CSS 预处理器，还可以做对于低版本浏览器 (IE8-) 的 px 降级处理。CanIUse 的兼容表
哇！我看不到像素点
使用绝对尺寸单位进行布局的最大缺点，就是在动辄1080P的手机屏幕上将小到难以阅读，同时过高的分辨率也会使媒体查询无法发挥应有的功效。但是如果使用 em 字体大小进行布局，就可以方便的利用系统默认字号设定了。
对于浏览器用户字体大小设置的支持
对于视力障碍和残障人士，可以在浏览器的设置中更改字体的大小，但不同浏览器迥异的缩放模式经常使得使用固定尺寸单位的网站布局崩溃，而这种时候 EMs 单位可以保证完全一致自然的效果。
对于页面缩放的响应式支持
在平常阅读中也常有缩放页面的需要，弹性布局可以在缩放中正确的激活响应式。反观使用绝对单位判断的响应式，可能在部分浏览器中当缩放的实际显示空间不够时仍然使用为大可视区域设计的样式，容易导致布局崩溃。不过在现代浏览器中已经会激活对应的查询。
保持一致的换行
完全使用 EMs 单位进行布局的话，缩放过程中文字和图片不会产生流动，可以完美的保持布局的美观和稳定。
尽管如此，随之而来的还有一些美中不足的小问题。如果还有发现其他弊端，也欢迎 在此回复 。

	【如何惹恼 Work Flow 上的其他人】
在完整的工作流程中，各种原型、视觉、切图很难全部使用 em 作为计量单位，只能在前端实现的时候转换。而且默认的 1em:16px 计算也较为不便，后面会提到一个巧妙的解决方法。
麻烦的父级元素 font-size 继承
如果使用 em 作为尺寸单位，因为 em 相对父元素 font-size 值进行计算的特性，如果中间有对元素的字体大小进行更改，子元素的全部布局就会出错。这点现在可以很方便的通过相对于根元素的 rem 单位计量来避免。
不该放大的图片
假如为图片使用了 em 设定尺寸，在响应不同设备的字体时就会按比例增大而导致模糊。但是如果使用常规的 px 设定尺寸，又会失去文字排版均一的好处。考虑到平常的设计中文字流动并没有影响，可以稍微牺牲可用性而用 px 设定图片尺寸。
养成坏习惯容易，好习惯难
从 ems 单位切换到 px 或者 pt 只需要简单的单位转换，而从绝对单位向弹性布局转换绝对不是一个好的体验。因此在项目开始时就应该确定好弹性布局的基础，否则后期迁移并不容易。
那么如何开始一个弹性布局的页面呢？不不不，除了使用 em 作为单位表示尺寸之外，还有一些可以用到的技巧：

	【为根元素设置 font-size: 100%】
在 IE 上的文字缩放选项并不符合常规情况下的预期，即在特大和特小的情况下缩放不是平滑的，很容易导致文字被缩放到难以阅读的程度。此时就可以为 <html> 元素指定 100% 的字体大小，以即时响应用户的缩放。
为文档元素设置 font-size: 62.5%
先前已经提到过，尽管所有浏览器都一致的保持着 16px 的默认字号，但是 1:16 的比例明显十分不方便计算。将字号设为 10px 会使 Ems 布局前功尽弃，此时通过设置为 16px 的 62.5% 就可以很方便的利用十进制进行计算了。当然如果你选择使用的是 rem 为单位，需要牺牲低版本 IE 的兼容性将 <html> 的 font-size 设为 62.5% 。
为媒体查询使用 ems
对于前面提到的对 Retina 高清分辨率屏幕的支持，使用 em 为单位的媒体查询就是一个有用的技巧。当每行能容纳的文本少于某个值时进行响应而不是宽度为某个像素进行响应，将会大大改善响应式设计的使用体验。
为 rem 使用预处理器
随着 rem 的推出，弹性布局最大的麻烦之一得到解决。但是尽管 em 的支持已很有历史， rem 却仅支持最新的几个浏览器版本，在低版本浏览器上的显示效果将会是灾难级的。提前使用 SASS 等 CSS 预处理器为低版本浏览器准备好一个 px 为单位的降级很有必要，这里不再详述，可自行查找相关资料。
基本上只要明确了以上几点，就可以按平常的方法继续进行网页的布局。不过正因为弹性布局是一个为阅读体验而生的技术，在这方面稍加注意，还可以更好的发挥弹性布局的优势。

	【让行高保持节奏】
这是一个提高阅读体验的绝妙方法 —— 让所有元素的行高始终保持为一个值的倍数，想想网页是平铺在一个有行线的笔记本上，让每个元素都完美的占据多格的中间而不压线。请注意，没有阅读体验的弹性布局一文不值。
	【提供不同文字大小的样式】
很多站点都会为了照顾不同用户提供大中小的样式表，在弹性布局下的实现更加容易。如果用户不懂得更改浏览器的显示设定，仅需要提供 body 元素 font-size 不同的几个样式表，即可马上对整个网页进行缩放。
	【不必关注像素，而是比例】
尽管为了配合视觉设计我们需要在实际过程中进行 px 到 em 的转换，但是因为缩放的存在，实际需要聚焦的核心不是尺寸本身而是整体布局的比例。只要确定正常视图下布局处在一个合理的大小和位置，剩下的交给 ems 就好了。
脱离样式表可用
这是和弹性布局无关的一条可用性建议。永远为网页保持合理的 DOM 结构，不为了样式服务颠倒顺序，让网页即使脱离样式表也十分完美。如此一来就算是在屏幕阅读器、字符浏览器等极端环境下，仍然可以保持最大化的体验。

	【为 rem 使用预处理器】
随着 rem 的推出，弹性布局最大的麻烦之一得到解决。但是尽管 em 的支持已很有历史， rem 却仅支持最新的几个浏览器版本，在低版本浏览器上的显示效果将会是灾难级的。提前使用 SASS 等 CSS 预处理器为低版本浏览器准备好一个 px 为单位的降级很有必要，这里不再详述，可自行查找相关资料。
基本上只要明确了以上几点，就可以按平常的方法继续进行网页的布局。不过正因为弹性布局是一个为阅读体验而生的技术，在这方面稍加注意，还可以更好的发挥弹性布局的优势。



2、【position 几个属性的作用？】
	答：position 的常见四个属性值： relative，absolute，fixed，static。一般都要配合"left"、"top"、"right" 以及 "bottom"

属性使用。
	1）【Static】：默认位置，设置为 static 的元素，它始终会处于页面流给予的位置（static  元素会忽略任何 top、

bottom、left 或 right  声明）。一般不常用。
	2）【Relative】：位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，意思就是如果设置了 relative 值，那么，它偏移的 top，right，bottom，left 的值都以它原来的位置为基准偏移，而不管其他元素会怎么 样。注意 relative 移动后的元素在原来的位置仍占据空间。
	3）【Absolute】：位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。意思就是如果它的 父容器设置了 position 属性，并且 position 的属性值为 absolute  或者 relative，那么就会依据父容器进行偏移。如果其父容器没有设置 position 属性，那么偏移是以 body 为依据。注意设置 absolute 属性的元素在标准流中不占位置。

	4）【Fixed】：位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。不论窗口滚动与否，元 素都会留在那个位置。它始终是以 body 为依据的。 注意设置 fixed 属性的元素在标准流中不占位置。

3、【px，em，rem 的区别？】
	答： 1）px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算 机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。
	2）em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置， 则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。
	3）rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小， 但相对的只是 HTML 根元素。
	4）区别：IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem 相对的只是 HTML 根 元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有 字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。

	4、 【什么是 BFC？】
	答： 1）定义：
BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有 Block-level box 参 与， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。
布局规则：
	A. 内部的 Box 会在垂直方向，一个接一个地放置。
	B. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。
	C. 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。 即使存在浮动也是如此。
	D. BFC 的区域不会与 float box 重叠。
	E. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
	F. 计算 BFC 的高度时，浮动元素也参与计算。

	3）【哪些元素会生成 BFC】
	A.  根元素
	B. float 属性不为 none
	C. position 为 absolute 或 fixed
	D. display 为 inline-block， table-cell， table-caption， flex， inline-flex
	F. overflow 不为 visible

	5、【表格自动换行怎么实现？】
	答：
	【word-break：normal】 使用浏览器默认的换行规则；
	【break-all】 允许单词内换行；
	【keep-all】 只能在半角空格或连字符处换行
	【word-wrap：normal】 是用浏览器默认的换行规则；break-word 在长单词或 URL 地址内部进行换行。
	


















js面试题
var a;
	console.log('a = ' + a); //undfined
	var b = 1;
	var c = a + b;
	console.log("c = " + c);//NaN
	var d = "";
	var e = b + d;
	console.log("e = " + e);//1
	var f = a + d;
	console.log("f = " + f);//undefined

bootlect
未定义变量和undefined和number,booleanter,未定义变量相加提示NaN
和""String变量相加提示undefined

	标识符：
		1.只能有数字、字母、下划线、$这4种符号组成
		2.首字母不能是数字
		3.不能是js语言的关键字和保留字
		4.严格区分大小写
		5.-、*、#类似的特殊字符不允许使用
		6.习惯上，采用驼峰式命名，除第一个单词外，剩余单词首字母大写 语义化



在浏览器地址栏的技巧
	这个很多人应该还是知道的，在浏览器地址栏可以直接运行JavaScript代码，做法是以javascript:开头后跟要执行的语句。比如：
	【javascript:alert('hello from address bar :)');】
	将以上代码贴到浏览器地址栏回车后alert正常执行，一个弹窗神现。
需要注意的是如果是通过copy paste代码到浏览器地址栏的话，IE及Chrome会自动去掉代码开头的javascript:，所以需要手动添加起来才能正确执行，而Firefox中虽然不会自动去掉，但它根本就不支持在地址栏运行JS代码，sigh~


这一技术在我的另一篇博文《让Chrome 接管邮件连接，收发邮件更方便了》中有使用到，利用在浏览器地址栏中执行JavaScript代码将Gmail设置为系统的邮件接管程序。

浏览器地址栏运行HTML代码
	【data:text/html,<h1>Hello, world!</h1>】
	直接在浏览器html显示内容
	【data:text/html, <html contenteditable>】
	把浏览器变成编辑器
归根结底多亏了HTML5中新加的contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。
推而广之，将以下代码放到console执行后，整个页面将变得可编辑，随意践踏吧~
	【document.body.contentEditable='true';】

利用a标签自动解析URL
很多时候我们有从一个URL中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在JS代码里先创建一个a标签然后将需要解析的URL赋值给a的href属性，然后就得到了一切我们想要的了。

	var a = document.createElement('a'); a.href = 'http://www.cnblogs.com/wayou/p/'; 
	console.log(a.host);
利用这一原理，稍微扩展一下，就得到了一个更加健壮的解析URL各部分的通用方法了。下面代码来自。
    function parseURL(url) {
        var a = document.createElement('a');
        a.href = url;
        return {
            source: url,
            protocol: a.protocol.replace(':', ''),
            host: a.hostname,
            port: a.port,
            query: a.search,
            params: (function() {
                var ret = {},
                    seg = a.search.replace(/^\?/, '').split('&'),
                    len = seg.length,
                    i = 0,
                    s;
                for (; i < len; i++) {
                    if (!seg[i]) {
                        continue;
                    }
                    s = seg[i].split('=');
                    ret[s[0]] = s[1];
                }
                return ret;
            })(),
            file: (a.pathname.match(/\/([^\/?#]+)$/i) || [, ''])[1],
            hash: a.hash.replace('#', ''),
            path: a.pathname.replace(/^([^\/])/, '/$1'),
            relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [, ''])[1],
            segments: a.pathname.replace(/^\//, '').split('/')
        };
    }

页面拥有ID的元素会创建全局变量
在一张HTML页面中，所有设置了ID属性的元素会在JavaScript的执行环境中创建对应的全局变量，这意味着document.getElementById像人的阑尾一样显得多余了。但实际项目中最好老老实实该怎么写就怎么写，毕竟常规代码出乱子的机会要小得多。

<div></div> <script type="text/javascript"> console.log(sample);</script>

加载CDN文件时，可以省掉HTTP标识
现在很流行的CDN即从专门的服务器加载一些通用的JS和CSS文件，出于安全考虑有的CDN服务器使用HTTPS方式连接，而有的是传统的HTTP，其实我们在使用时可以忽略掉这个，将它从URL中省去。

<script src="//domain.com/path/to/script.js"></script>
 这一点在之前一篇译文博客《jQuery编程最佳实践》中也有提到。
利用script标签保存任意信息
将script标签设置为type='text'然后可以在里面保存任意信息，之后可以在JavaScript代码中很方便地获取。
<script type="text"> <h1>This won't display</h1> </script>


var text = document.getElementById('template').innerHTML
CSS篇 关于CSS的恶作剧
相信你看完以下代码后能够预料到会出现什么效果。
*{ cursor: none!important; }
简单的文字模糊效果
以下两行简单的CSS3代码可达到将文字模糊化处理的目的，出来的效果有点像使用PS的滤镜，so cool!
p { color: transparent; text-shadow: #111 0 0 5px; }



有些公司招聘中说的P7、P6是什么意思?
1.阿里P6是高级工程师(阿里把晋升分为P和M两个序列。P是专业序列、M是管理序列，根据个人意愿及岗位需要、P和M之间是可以转的。一般来说P6(高工)对应是M1(主管)、P7(技术专家)对应的M2(经理)，以此类推一直到P14和M9); 
2.研究生毕业一般为P5，两至三年可以晋升到P6。阿里的晋升通道是畅通的，机制也是较健全的、能不能晋升及以什么速度晋升这些主要取决于自己; 
3.P7是能力的代表，不是工作时间的代表。但是常规来讲，研究生5-6年以上应该要达到P7。注意P7是技术专家。 
4.阿里是一个很开放并闷骚的文化，倡导的是客户第一、员工第二、股东第三的价值导向。 
5.在阿里不是只有M会去管人，P6\7一般都会负责带人，当然这个和团队人员情况及个人情况都有关系;由于业务发展的需要P6、P7在大部分研发团队都属于骨干。

	【Constructor构造器】
	构造函数，是一种特殊的方法，主要用来在创建对象时初始化对象，即为对象成员变量赋初始值。总与new运算符一起使用在创建对象的语句中，特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。

	除了创建对象，构造函数(constructor) 还做了另一件有用的事情—自动为创建的新对象设置了原型对象(prototype object) 。原型对象存放于 ConstructorFunction.prototype 属性中。


	【SGML】
	中文名称:标准通用标记语言
	外文名称:Standard Generalized Markup
	基本思想:分开文档的内容和样式
	中文缩写:通用标言
	类型:标记语言
	外语缩写:SGM或SGML(都作文件扩展名)
	其它称呼:标注语言,置标语言,标识语言
	可选参数:SGML-bctf,SGML-boot,charset

	【SEO】搜索引擎优化
	全名:Search Engine Optimization
	Engine引擎
	Optimization最优化
	在了解搜索引擎自然排名机制的基础上,对网站进行内部及外部的调整优化,改进网站在搜索引擎中的关键词自然排名,获得更多流量,从而达成网站销售及品牌建设的预期目标.
	
	
	混合开发
	【hybrid】
		

===============================================================================
【mySql】[mySql]
	cmd查看启动服务
	【net start】	

	把【C:\Program Files\MySQL\MySQL Server 5.6\bin;】路径配置到环境变量path内
	报错:Can't connect to MySQL server on 'localhost' (10061)
	运行C:\Program Files\MySQL\MySQL Server 5.6\bin下的【mysqld.exe】文件

	10061错误是网络连接失败，你的MYSQL服务肯定没有启动。

	用net start查看，绝对没有MYSQL服务存在，或者端口不是3306。

	你进入MYSQL的BIN目录，手动运行→【mysqld.exe】，查看一下MYSQL服务启动失败的原因，如果运行后没有反映，说MYSQL服务现在启动了，你的程序不会报告10061错误了。





【myeclipse】[myeclipse]
	汉化方法:
	MyEclipse 10下新建【Common】文件夹,复制进去【language】和【CreatePluginsConfig.java】

	文件(F)--新建Java 项目-输入【CreatePluginsConfig.java】
	File--New--Java Project

   在项目里面建立一个CreatePluginsConfig类 这个类是怎样创建的？
  （1）启动myeclipse，在主菜单上选择【File/new/Java Project】菜单项，创建一个Java项目。
  （2）在新建项目的包资源管理器中也就是窗口左侧那个包括项目名节点的面板中，展开新建项目节点，在src节点上单击鼠标右键，在弹出的快捷菜单中选择【New/Class】菜单项，在打开的对话框的name文本框中输入类名，也就是CreatePluginsConfig，单击OK按钮即可。
	
	运行吊事bug
	%localappdata%\Genuitec\MyEclipse 10\configuration\org.eclipse.equinox.simpleconfigurator
	myeclipse.ini
	最后
	【-Duser.language=zhs】保存





















